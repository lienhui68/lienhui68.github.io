<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="简介                                             是什么                            为什么会出现docker        一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环">
<meta property="og:type" content="article">
<meta property="og:title" content="docker_quickstart">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/300_DevOps/docker/docker_quickstart/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="简介                                             是什么                            为什么会出现docker        一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707155808.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707162435.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707163617.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707191543.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707191620.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707174347.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707212325.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707182044.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707182112.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707182127.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200020.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200311.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707202736.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200641.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200757.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707202219.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707203425.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707203732.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707231233.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708004319.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708004354.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708010459.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708030451.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708032515.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708033444.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708144204.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708151744.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708152635.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708152913.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708153303.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708153508.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708153535.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708162206.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708162803.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708162954.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708164318.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200708164649.png">
<meta property="article:published_time" content="2020-09-16T16:22:39.178Z">
<meta property="article:modified_time" content="2020-09-27T11:18:17.531Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="云计算">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200707155808.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>docker_quickstart | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/300_DevOps/docker/docker_quickstart/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">docker_quickstart</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-27</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">55分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a>简介</h1>
      
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707155808.png"  alt="" />
      </p>

        <h2 id="是什么"   >
          <a href="#是什么" class="heading-link"><i class="fas fa-link"></i></a>是什么</h2>
      

        <h3 id="为什么会出现docker"   >
          <a href="#为什么会出现docker" class="heading-link"><i class="fas fa-link"></i></a>为什么会出现docker</h3>
      
<p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。</p>
<p>docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<strong>软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用docker可以消除协作编码时“在我的机器上可正常工作”的问题</strong>。</p>
<a id="more"></a>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707162435.png"  alt="" />
      </p>
<p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿一个电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p>
<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让运维运团队得以部署应用程式，<strong>开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况</strong>。docker镜像的设计，<strong>使得docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作</strong>。</p>

        <h3 id="docker理念"   >
          <a href="#docker理念" class="heading-link"><i class="fas fa-link"></i></a>docker理念</h3>
      
<p>docker是基于Go语言实现的云开源项目。<br />
docker的主要目标是“Build，Ship and Run Any App,Anywhere”(在任何地方构建、发布并运行任何应用)，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707163617.png"  alt="" />
      <br />
Linux 容器工作的出现就解决了这样一个问题，而 docker 就是在它的基础上发展过来的。将应用运行在 docker 容器上面，而 docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong>。</p>

        <h3 id="docker基本组成"   >
          <a href="#docker基本组成" class="heading-link"><i class="fas fa-link"></i></a>docker基本组成</h3>
      
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707191543.png"  alt="" />
      </p>
<blockquote>
<p>docker client 就是跟docker沟通的命令终端窗口<br />
docker run 镜像， 要是没有本地没有镜像从仓库里拉一个镜像再生成容器再运行。<br />
3.1. 镜像<br />
docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 docker 容器，一个镜像可以创建很多容器。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707191620.png"  alt="" />
      </p>
</blockquote>
<p>3.2. 容器<br />
<strong>docker利用容器（Container）独立运行一个或一组应用。容器是用镜像创建的运行实例</strong>。它可以被启动、开始、停止、删除。可以把容器看做是一个简易版的 Linux 环境(包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p>3.3. 仓库<br />
仓库（Repository）是<strong>集中存放镜像文件</strong>的场所。<br />
仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 <span class="exturl"><a class="exturl__link"   href="https://hub.docker.com/"  target="_blank" rel="noopener">docker Hub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等。</p>
<p>3.4. 总结<br />
docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成 docker 容器。image 文件可以看作是容器的模板。docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<ul>
<li>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li>
<li>至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来就可以了。</li>
</ul>

        <h3 id="一句话"   >
          <a href="#一句话" class="heading-link"><i class="fas fa-link"></i></a>一句话</h3>
      
<p>docker是解决了运行环境和配置问题的软件容器平台，方便做持续集成并有助于整体发布的容器虚拟化工作。<br />
标准化的集装与隔离, 类似于简单的虚拟机。</p>

        <h2 id="能干嘛"   >
          <a href="#能干嘛" class="heading-link"><i class="fas fa-link"></i></a>能干嘛</h2>
      

        <h3 id="之前的虚拟化工作"   >
          <a href="#之前的虚拟化工作" class="heading-link"><i class="fas fa-link"></i></a>之前的虚拟化工作</h3>
      
<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。<br />
它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。虚拟机连硬件都模拟，应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707174347.png"  alt="" />
      </p>
<p>虚拟机缺点：1.资源占用多; 2.冗余步骤多; 3.启动慢</p>

        <h3 id="容器化虚拟工作"   >
          <a href="#容器化虚拟工作" class="heading-link"><i class="fas fa-link"></i></a>容器化虚拟工作</h3>
      
<p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化工作：Linux 容器（Linux Containers，缩写为 LXC）。</p>
<p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离</strong>。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707212325.png"  alt="" />
      </p>
<p>docker 和传统虚拟化方式的不同之处：</p>
<ul>
<li>传统虚拟机工作是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</li>
<li><strong>容器内的应用进程直接运行于宿主机的内核</strong>，容器内没有自己的内核，<strong>而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</li>
<li>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</li>
</ul>

        <h3 id="开发自运维devops"   >
          <a href="#开发自运维devops" class="heading-link"><i class="fas fa-link"></i></a>开发自运维(DevOps)</h3>
      
<ol>
<li>
<p>更快捷的应用交付和部署<br />
传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p>
</li>
<li>
<p>更便捷的升级和扩缩容<br />
随着微服务架构和docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p>
</li>
<li>
<p>更简单的系统运维<br />
应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p>
</li>
<li>
<p>更高效的计算资源利用<br />
docker是内核级虚拟化，其不像传统的虚拟化工作一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p>
</li>
</ol>
<blockquote>
<p>Hypervisor，又称虚拟机监视器（英语：virtual machine monitor，缩写为 VMM），是用来建立与执行虚拟机器的软件、固件或硬件。<br />
被Hypervisor用来执行一个或多个虚拟机器的电脑称为主体机器（host machine），这些虚拟机器则称为客体机器（guest machine）。hypervisor提供虚拟的作业平台来执行客体操作系统（guest operating systems），负责管理其他客体操作系统的执行阶段；这些客体操作系统，共同分享虚拟化后的硬件资源。</p>
</blockquote>

        <h3 id="企业级"   >
          <a href="#企业级" class="heading-link"><i class="fas fa-link"></i></a>企业级</h3>
      
<p>新浪<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707182044.png"  alt="" />
      <br />
美团<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707182112.png"  alt="" />
      <br />
蘑菇街<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707182127.png"  alt="" />
      </p>
<p>云工作会是一个趋势，之前在服务器上的应用很多都在往云上迁移</p>
<blockquote>
<p>今天的优势会被明天的趋势所取代，云端，客户端</p>
</blockquote>

        <h2 id="去哪下"   >
          <a href="#去哪下" class="heading-link"><i class="fas fa-link"></i></a>去哪下</h2>
      
<blockquote>
<p>学工作，必登官网</p>
</blockquote>
<ol>
<li>官网<br />
<span class="exturl"><a class="exturl__link"   href="http://www.docker.com"  target="_blank" rel="noopener">docker官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
<span class="exturl"><a class="exturl__link"   href="https://www.docker-cn.com/"  target="_blank" rel="noopener">docker中文网站</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>仓库<br />
<span class="exturl"><a class="exturl__link"   href="https://hub.docker.com/"  target="_blank" rel="noopener">docker Hub官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>

        <h1 id="安装"   >
          <a href="#安装" class="heading-link"><i class="fas fa-link"></i></a>安装</h1>
      

        <h2 id="安装步骤"   >
          <a href="#安装步骤" class="heading-link"><i class="fas fa-link"></i></a>安装步骤</h2>
      
<ol>
<li>去官网下载docker.dmg<br />
<span class="exturl"><a class="exturl__link"   href="http://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/"  target="_blank" rel="noopener">阿里云的mac版本的docker.dmg下载地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>下载安装好后根据电脑配置做一些资源设置，可以先使用默认值</li>
<li>配置镜像加速<br />
<span class="exturl"><a class="exturl__link"   href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors"  target="_blank" rel="noopener">阿里云容器镜像服务</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
3.1. 获取加速器地址<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200020.png"  alt="" />
      <br />
阿里云<br />
{<br />
“registry-mirrors”: [“<span class="exturl"><a class="exturl__link"   href="https://xxxx.mirror.aliyuncs.com"  target="_blank" rel="noopener">https://xxxx.mirror.aliyuncs.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>”]<br />
}<br />
3.2. 在docker中配置<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200311.png"  alt="" />
      <br />
3.3. 检验</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707202736.png"  alt="" />
      <br />
表示配置加速器ok</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200641.png"  alt="" />
      <br />
表示docker client和docker server的交互ok</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707200757.png"  alt="" />
      <br />
表示本地拉取和运行镜像ok<br />
<strong>docker run 干了什么</strong><br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707202219.png"  alt="" />
      </p>

        <h2 id="底层原理"   >
          <a href="#底层原理" class="heading-link"><i class="fas fa-link"></i></a>底层原理</h2>
      

        <h3 id="docker是怎么工作的"   >
          <a href="#docker是怎么工作的" class="heading-link"><i class="fas fa-link"></i></a>docker是怎么工作的</h3>
      
<p>docker是一个Client-Server结构的系统，docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 <strong>容器，是一个运行时环境，就是我们前面说到的集装箱</strong>。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707203425.png"  alt="" />
      </p>

        <h3 id="为什么docker比vm快"   >
          <a href="#为什么docker比vm快" class="heading-link"><i class="fas fa-link"></i></a>为什么docker比VM快</h3>
      
<ol>
<li>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</li>
<li>docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。从而避免引寻、加载操作系统内核这个个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,这个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个过程,因此新建一个docker容器只需要几秒钟。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707203732.png"  alt="" />
      </li>
</ol>

        <h1 id="常用命令"   >
          <a href="#常用命令" class="heading-link"><i class="fas fa-link"></i></a>常用命令</h1>
      

        <h2 id="帮助命令"   >
          <a href="#帮助命令" class="heading-link"><i class="fas fa-link"></i></a>帮助命令</h2>
      
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. docker version</span><br><span class="line">2. docker info</span><br><span class="line">3. docker --help</span><br></pre></td></tr></table></div></figure>

        <h2 id="镜像命令"   >
          <a href="#镜像命令" class="heading-link"><i class="fas fa-link"></i></a>镜像命令</h2>
      
<ol>
<li>列出本地主机上的镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] # 列出本地主机上的镜像</span><br><span class="line">	OPTIONS说明：</span><br><span class="line">		-a 列出本地所有的镜像(含中间映像层)</span><br><span class="line">		-q 只显示镜像ID</span><br><span class="line">		--digests 显示镜像的摘要信息</span><br><span class="line">		--no-trunc 显示完整的镜像信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> REPOSITORY：表示镜像的仓库源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TAG：镜像的标签</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> IMAGE ID：镜像ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CREATED：镜像创建时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SIZE：镜像大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同一仓库源的镜像可以有多个TAG，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG来定义不同的镜像。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</span></span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>搜索某个镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] 某个镜像名字</span><br><span class="line">	OPTIONS说明：</span><br><span class="line">		-s 列出收藏数不小于指定值的镜像</span><br><span class="line">		--no-trunc 显示完整的镜像描述</span><br><span class="line">		-automated 只列出automated build类型的镜像		</span><br><span class="line"><span class="meta">#</span><span class="bash"> search是从docker hub上搜索， pull/push才会从配置好的阿里云仓库中pull/push</span></span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>拉取镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名字[:TAG]</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>删除镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名字ID # 删除单个</span><br><span class="line">docker rmi -f 强制删除， 正在运行的也删 # 强制删除单个</span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG  # 删除多个</span><br><span class="line">docker rmi -f $(docker images -qa) # 删除全部</span><br></pre></td></tr></table></div></figure>

        <h2 id="容器命令"   >
          <a href="#容器命令" class="heading-link"><i class="fas fa-link"></i></a>容器命令</h2>
      
<ol>
<li>新建并启动容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">	OPTIONS说明（常用）：有些是一个减号，有些是两个减号</span><br><span class="line"> 		--name="容器新名字": 为容器指定一个名称；</span><br><span class="line"> 		-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</span><br><span class="line"> 		-i：以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">		-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">		-P: 随机端口映射；</span><br><span class="line">		-p: 指定端口映射，有以下四种格式</span><br><span class="line">		    ip:hostPort:containerPort</span><br><span class="line">      		ip::containerPort</span><br><span class="line">      		hostPort:containerPort # 比如tomcat 8888(宿主机):8080(容器内端口)</span><br><span class="line">      		containerPort</span><br><span class="line">eg:</span><br><span class="line">	docker run -it cnetos /bin/bash</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span></span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>列出所有当前正在运行的容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br><span class="line">	OPTIONS说明（常用）：</span><br><span class="line">		-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">		-l :显示最近创建的容器。</span><br><span class="line">		-n：显示最近n个创建的容器。</span><br><span class="line">		-q :静默模式，只显示容器编号。</span><br><span class="line">		--no-trunc :不截断输出。</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>退出容器<br />
3.1. 停止容器并退出</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></div></figure>
<p>3.2. 不停止容器退出<br />
快捷键ctrl+P+Q</p>
<ol start="4">
<li>启动容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID或者容器名</span><br></pre></td></tr></table></div></figure>
<ol start="5">
<li>重启容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID或者容器名</span><br></pre></td></tr></table></div></figure>
<ol start="6">
<li>停止容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID或者容器名</span><br></pre></td></tr></table></div></figure>
<ol start="7">
<li>强制停止容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器ID或者容器名</span><br></pre></td></tr></table></div></figure>
<ol start="8">
<li>删除容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器ID</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次删除多个容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line">docker ps -aq |xargs docker rm</span><br></pre></td></tr></table></div></figure>
<ol start="9">
<li>启动守护式容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos # 使用镜像centos:latest以后台模式启动一个容器</span><br></pre></td></tr></table></div></figure>
<p><strong>注意</strong>：此时使用docker ps -a 进行查看, 会发现容器已经退出。很重要的一点:docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p>
<p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如<br />
service nginx start<br />
但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行。</p>
<ol start="10">
<li>查看容器日志</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail 容器ID</span><br><span class="line">	-t 时间戳</span><br><span class="line">	-f 跟随最新的日志打印</span><br><span class="line">	--tail 数字  显示最后多少条</span><br></pre></td></tr></table></div></figure>
<ol start="11">
<li>查看容器内运行的进程</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></div></figure>
<ol start="12">
<li>查看容器内部细节</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></div></figure>
<ol start="13">
<li>进入正在运行的容器并以命令行交互</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在容器中打开新的终端，并且可以启动新的进程</span></span><br><span class="line">docker exec -it 容器ID bashshell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接进入容器启动命令的终端，不会启动新的进程</span></span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></div></figure>
<ol start="14">
<li>从容器内拷贝文件到主机上</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></div></figure>

        <h2 id="小总结"   >
          <a href="#小总结" class="heading-link"><i class="fas fa-link"></i></a>小总结</h2>
      
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200707231233.png"  alt="" />
      </p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line">build     Build an image from a dockerfile              # 通过 dockerfile 定制镜像</span><br><span class="line">commit    Create a new image from a container changes   # 提交当前容器为新的镜像</span><br><span class="line">cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line">diff      Inspect changes on a container's filesystem   # 查看 docker 容器变化</span><br><span class="line">events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span><br><span class="line">exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class="line">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line">history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class="line">images    List images                                   # 列出系统当前镜像</span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line">info      Display system-wide information               # 显示系统相关信息</span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class="line">logout    Log out from a docker registry server          # 从当前 docker registry 退出</span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class="line">pause     Pause all processes within a container        # 暂停容器</span><br><span class="line">ps        List containers                               # 列出容器列表</span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">restart   Restart a running container                   # 重启运行的容器</span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line">rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line">search    Search for an image on the docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line">start     Start a stopped containers                    # 启动容器</span><br><span class="line">stop      Stop a running containers                     # 停止容器</span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></div></figure>

        <h1 id="镜像"   >
          <a href="#镜像" class="heading-link"><i class="fas fa-link"></i></a>镜像</h1>
      

        <h2 id="镜像是什么"   >
          <a href="#镜像是什么" class="heading-link"><i class="fas fa-link"></i></a>镜像是什么</h2>
      
<ol>
<li>
<p>UnionFS(联合文件系统)<br />
Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，<strong>它支持对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 docker 镜像的基础。镜像可以通过分层来进行继承，基于<strong>基础镜像</strong>（没有父镜像），可以制作各种具体的<strong>应用镜像</strong>。</p>
</li>
<li>
<p>docker镜像加载原理<br />
docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS。</p>
</li>
</ol>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，<strong>在docker镜像的最底层也是bootfs</strong>。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708004319.png"  alt="" />
      </p>
<p><strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M</strong>？<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708004354.png"  alt="" />
      </p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<ol start="3">
<li>
<p>分层的镜像<br />
pull的时候就能看到docker的镜像在一层一层的下载。</p>
</li>
<li>
<p>为什么docker镜像要采用这种分层结构<br />
最大的一个好处就是 - 共享资源<br />
比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
</li>
</ol>

        <h2 id="容器层镜像层"   >
          <a href="#容器层镜像层" class="heading-link"><i class="fas fa-link"></i></a>容器层&amp;镜像层</h2>
      
<p>docker镜像都是只读的，当容器启动时，一个新的可写层就被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>

        <h2 id="容器commit新镜像"   >
          <a href="#容器commit新镜像" class="heading-link"><i class="fas fa-link"></i></a>容器commit新镜像</h2>
      
<p>docker commit提交容器副本使之成为一个新的镜像。</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m='提交的描述信息' -a='作者' 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></div></figure>
<p>Demo:<br />
hub上新版本的tomcat webapps都是空的<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708010459.png"  alt="" />
      </p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. docker run -it -p 8888:8080 tomcat # 运行一个容器</span><br><span class="line">2. docker exec -it d5 /bin/bash # 在tomcat上做一些修改</span><br><span class="line">3. docker commit -a 'eh' -m 'add index.html' 44 eh/tomcat:1.1.2 # 以它为模板提交一个新镜像</span><br><span class="line">4. 进行对比</span><br></pre></td></tr></table></div></figure>

        <h1 id="容器数据卷"   >
          <a href="#容器数据卷" class="heading-link"><i class="fas fa-link"></i></a>容器数据卷</h1>
      

        <h2 id="是什么-2"   >
          <a href="#是什么-2" class="heading-link"><i class="fas fa-link"></i></a>是什么</h2>
      
<p>有点类似Redis里面的rdb和aof文件，用来做数据持久化。</p>
<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p>
<p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷</p>
<p>特点：<br />
1：数据卷可在容器之间共享或重用数据<br />
2：卷中的更改可以直接生效<br />
3：数据卷中的更改不会包含在镜像的更新中<br />
4：数据卷的生命周期一直持续到没有容器使用它为止</p>

        <h2 id="添加数据卷"   >
          <a href="#添加数据卷" class="heading-link"><i class="fas fa-link"></i></a>添加数据卷</h2>
      
<ol>
<li>直接命令添加</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it -v /宿主机绝对路径目录:/容器内目录[:ro] 镜像名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it -v ./volumn2:/volumn2:ro eh/centos:2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ro不加 则在容器内可读写， 加了表示只读</span></span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708030451.png"  alt="" />
      </p>
<ol start="2">
<li>使用dockerFile添加<br />
2.1 可以在dockerFile中使用VOLUMN指令来个镜像添加一个或多个数据卷</li>
</ol>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[&quot;&#x2F;volume1&quot;,&quot;&#x2F;volume2&quot;,&quot;&#x2F;volume3&quot;]</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p>
</blockquote>
<p>2.2 构建dockerFile<br />
dockerFile</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># volume test</span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;&#x2F;volume1&quot;,&quot;&#x2F;volume2&quot;,&quot;&#x2F;volume3&quot;]</span><br><span class="line">CMD echo &quot;finished,--------success1&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></div></figure>
<p>2.3 docker build<br />
build后生成一个新的镜像</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f dockerFile -t eh&#x2F;centos:3 .</span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708032515.png"  alt="" />
      </p>
<p>2.4 run容器查看数据卷在宿主机上的默认位置<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708033444.png"  alt="" />
      <br />
此时如果尝试进入host上对应的目录会出错,提示目录不存在：<br />
<strong>解决办法</strong><br />
在Mac OS下，进入以下目录</p>
<blockquote>
<p>~/Library/Containers/com.docker.docker/Data/vms/0/</p>
</blockquote>
<p>可以看到目录下有一个tty设备，screen连接进去，host对应的volume可以在这个linux实例中找到,进入该目录，其中的文件与container中的/opt/graphite/conf目录下的内容一致：<br />
参考<span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/qq_36457702/article/details/101030793"  target="_blank" rel="noopener">【容器】docker之Mac下host与container之间Volume映射问题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<blockquote>
<p>然而Source这个地址在本机中并不存在，在更新后的docker中应当使用：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</span></span><br></pre></td></tr></table></div></figure>
<p>进去之后默认是空白页面，需要按下Enter：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">linuxkit-025000000001:/# pwd</span><br><span class="line">/</span><br><span class="line">linuxkit-025000000001:/# ls</span><br><span class="line">EFI         dev         lib         proc        sendtohost  usr</span><br><span class="line">bin         etc         media       root        srv         var</span><br><span class="line">boot        home        mnt         run         sys</span><br><span class="line">containers  init        opt         sbin        tmp</span><br><span class="line">linuxkit-025000000001:/# ls /var/lib/docker/volumes/83af3ea2681490a5804183e427da</span><br><span class="line">3aa50241e31d1a39145b082b5aeca945a6f7/_data</span><br><span class="line">50x.html    index.html</span><br><span class="line">linuxkit-025000000001:/#</span><br></pre></td></tr></table></div></figure>
<p>如果需要干掉这个screen，按ctrl+a + k，最后按y确认即可以kill掉这个screen了；<br />
如果只是暂时退出这个screen，下次再进去，使用ctrl+a + d，而如果需要再次进入的时候应当使用screen -dr，否则使用<code>screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</code>再进去会是一片乱码(+_+)，将这个screen干掉即可</p>
</blockquote>
<p>2.5 数据卷容器<br />
命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器<br />
dc01挂在好数据卷， dc02 继承 dc01</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc02 --volumes-from dc01 eh/centos</span><br></pre></td></tr></table></div></figure>
<p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</p>

        <h1 id="dockerfile"   >
          <a href="#dockerfile" class="heading-link"><i class="fas fa-link"></i></a>dockerFile</h1>
      
<p>dockerFile是用来构建docker镜像的构建文件，是由一系列命令和参数构成的脚本。<br />
构建步骤：编写dockerFile脚本 -&gt; docker build -&gt; docker run</p>

        <h2 id="dockerfile构建过程解析"   >
          <a href="#dockerfile构建过程解析" class="heading-link"><i class="fas fa-link"></i></a>dockerFile构建过程解析</h2>
      
<ol>
<li>语法<br />
a. 每条保留字指令都必须为大写字母且后面要跟随至少一个参数<br />
b. 指令从上到下顺序执行<br />
c. # 表示注释<br />
d. 每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
<li>大致流程<br />
a. docker从基础镜像运行一个容器<br />
b. 执行一条指令并对容器作出修改<br />
c. 执行类似docker commit的操作提交一个新的镜像层<br />
d. docker再基于刚提交的镜像运行一个新容器<br />
e. 执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<p>从应用软件的角度来看，dockerfile、docker镜像与docker容器分别代表软件的三个不同阶段，</p>
<ul>
<li>dockerfile是软件的原材料</li>
<li>docker镜像是软件的交付品</li>
<li>docker容器则可以认为是软件的运行态。</li>
</ul>
<p>dockerfile面向开发，docker镜像成为交付标准，docker容器则涉及部署与运维，三者缺一不可，合力充当docker体系的基石。<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708144204.png"  alt="" />
      </p>
<ol>
<li>
<p>dockerfile，需要定义一个dockerfile，dockerfile定义了进程需要的一切东西。dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p>
</li>
<li>
<p>docker镜像，在用dockerfile定义一个文件之后，docker build时会产生一个docker镜像，当运行 docker镜像时，会真正开始提供服务;</p>
</li>
<li>
<p>docker容器，容器是直接提供服务的。</p>
</li>
</ol>

        <h2 id="保留字"   >
          <a href="#保留字" class="heading-link"><i class="fas fa-link"></i></a>保留字</h2>
      
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FROM 基础镜像，当前新镜像是基于哪个镜像的</span><br><span class="line">MAINTAINER 镜像维护者的姓名和邮箱地址</span><br><span class="line">RUN 容器构建时需要运行的linux命令</span><br><span class="line">EXPOSE 当前容器对外暴露的端口</span><br><span class="line">WORKDIR 指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</span><br><span class="line">ENV 用来在构建镜像过程中设置环境变量 例如 ENV MY_PATH /usr/mytest，</span><br><span class="line">	那么MY_PATH这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量</span><br><span class="line">ADD 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩文件</span><br><span class="line">COPY 类似ADD，拷贝文件和目录到镜像中</span><br><span class="line">	将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</span><br><span class="line">	COPY src dest</span><br><span class="line">	COPY ["src", "dest"]</span><br><span class="line">VOLUME 容器数据卷，用于数据保存和持久化工作</span><br><span class="line">CMD 指定一个容器启动时要运行的命令</span><br><span class="line">	CMD指令的格式和RUN相似，也是两种格式</span><br><span class="line">	shell格式：CMD &lt;命令&gt;</span><br><span class="line">	exec格式：CMD ["可执行文件", "参数1", "参数2"...]</span><br><span class="line">	参数列表格式：CMD ["参数1", "参数2"...] 在指定了ENTRYPOINT指令后，用CMD指定具体的参数。</span><br><span class="line">	注意：dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换。</span><br><span class="line">ENTRYPOINT 指定一个容器启动时要运行的命令</span><br><span class="line">	ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数</span><br><span class="line">ONBUILD 当构建一个被继承的dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</span><br></pre></td></tr></table></div></figure>

        <h2 id="构建自定义tomcat镜像"   >
          <a href="#构建自定义tomcat镜像" class="heading-link"><i class="fas fa-link"></i></a>构建自定义tomcat镜像</h2>
      
<blockquote>
<p>如果本地没有centos镜像需要先docker pull centos 到本地。</p>
</blockquote>
<ol>
<li>创建镜像构建过程中上下文环境目录</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> david @ Davids-Macbook-Pro <span class="keyword">in</span> ~ [15:01:38]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir dockerContext_Tomcat</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> dockerContext_Tomcat</span></span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>将jdk和tomcat安装压缩包拷贝进上下文目录中, 创建一个c.txt文件</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp ~/Downloads/jdk-8u251-linux-x64.tar.gz .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp ~/Downloads/apache-tomcat-8.5.57.tar.gz .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch c.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello dockerfile"</span> &gt; c.txt</span></span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>编写dockerfile文件</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim dockerfile</span><br></pre></td></tr></table></div></figure>
<p>文件内容如下：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM         centos</span><br><span class="line">MAINTAINER    eh&lt;lienhui1992@yeah.net&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">把宿主机当前上下文的c.txt拷贝到容器/usr/<span class="built_in">local</span>/路径下</span></span><br><span class="line">COPY c.txt /usr/local/cincontainer.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">把java与tomcat添加到容器中</span></span><br><span class="line">ADD jdk-8u251-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-8.5.57.tar.gz /usr/local/</span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim编辑器</span></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"><span class="meta">#</span><span class="bash">设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"><span class="meta">#</span><span class="bash">配置java与tomcat环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_251</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-8.5.57</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-8.5.57</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash">容器运行时监听的端口</span></span><br><span class="line">EXPOSE  8080</span><br><span class="line"><span class="meta">#</span><span class="bash">启动时运行tomcat</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ENTRYPOINT [<span class="string">"/usr/local/apache-tomcat-8.5.57/bin/startup.sh"</span> ]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CMD [<span class="string">"/usr/local/apache-tomcat-8.5.57/bin/catalina.sh"</span>,<span class="string">"run"</span>]</span></span><br><span class="line">CMD /usr/local/apache-tomcat-8.5.57/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.5.57/bin/logs/catalina.out</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>build新镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t eh/centos .</span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708151744.png"  alt="" />
      <br />
可以看到一条指令执行完就构建好了一个镜像，直到所有指令都执行完毕，最终的镜像才构建成功</p>
<ol start="5">
<li>检验</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9080:8080 --name myt9 -v ~/dockerContext_Tomcat/test:/usr/local/apache-tomcat-8.5.57/webapps/test -v ~/dockerContext_Tomcat/logs/:/usr/local/apache-tomcat-8.5.57/logs --privileged=true eh/centos</span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708152635.png"  alt="" />
      </p>
<blockquote>
<p>docker挂载主机目录docker访问出现cannot open directory .: Permission denied<br />
解决办法：在挂载目录后多加一个–privileged=true参数即可</p>
</blockquote>
<ol start="6">
<li>将web服务test发布，第5步已经配置好了容器数据卷，只需要将web工程目录放在宿主机test目录下即可<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708152913.png"  alt="" />
      </li>
</ol>
<p>6.1 新建web.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<p>6.2 新建a.jsp</p>
<figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    -----------welcome------------</span><br><span class="line">    &lt;%=<span class="string">"i am in docker tomcat self "</span>%&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;% System.out.println(<span class="string">"=============docker tomcat self"</span>);%&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>
<ol start="7">
<li>重启容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart e2</span><br></pre></td></tr></table></div></figure>
<ol start="8">
<li>
<p>访问a.jsp<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708153303.png"  alt="" />
      </p>
</li>
<li>
<p>查看宿主机 logs下日志</p>
</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /Users/david/dockerContext_Tomcat/logs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat catalina.out</span></span><br></pre></td></tr></table></div></figure>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708153508.png"  alt="" />
      </p>
<p>小总结<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708153535.png"  alt="" />
      </p>

        <h1 id="常用安装"   >
          <a href="#常用安装" class="heading-link"><i class="fas fa-link"></i></a>常用安装</h1>
      
<p><strong>总体步骤</strong><br />
搜索镜像(search)-&gt;拉取镜像(pull)-&gt;查看镜像(images)-&gt;运行镜像(run)-&gt;停止容器(stop)-&gt;移除容器(rm)</p>
<p>下面主要记下常用软件需要挂载的目录</p>
<ol>
<li>tomcat</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9080:8080 --name myt9 </span><br><span class="line">-v ~/dockerContext_Tomcat/test:/usr/local/apache-tomcat-8.5.57/webapps/test # 项目文件夹</span><br><span class="line">-v ~/dockerContext_Tomcat/logs/:/usr/local/apache-tomcat-8.5.57/logs # 日志文件价</span><br><span class="line">--privileged=true eh/centos</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>mysql</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 12345:3306 --name mysql  # 将主机的12345端口映射到docker容器的3306端口。</span><br><span class="line">-v ~/mysql/conf.d:/etc/mysql/conf.d # 将主机~/mysql录下的conf.d 挂载到容器的 /etc/mysql/conf.d</span><br><span class="line">-v ~/mysql/logs:/logs  # 将主机~/mysql目录下的 logs 目录挂载到容器的 /logs。</span><br><span class="line">-v ~/mysql/data:/var/lib/mysql # 将主机~/mysql目录下的data目录挂载到容器的 /var/lib/mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 # 初始化 root 用户的密码。</span><br><span class="line">-d mysql:5.6</span><br></pre></td></tr></table></div></figure>
<p>此时外部就可以远程连接运行在docker上的mysql服务</p>
<ol start="3">
<li>redis</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379</span><br><span class="line">-v ~/redis/data:/data # # 数据</span><br><span class="line">-v ~/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf #配置</span><br><span class="line">-d redis:3.2</span><br><span class="line">redis-server /usr/local/ect/redis/redis.conf --appendonly yes # 进入redis容器 终端执行shell指令</span><br></pre></td></tr></table></div></figure>
<p>客户端连接</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 08 redis-cli</span><br></pre></td></tr></table></div></figure>
<p>进入到~/mysql/data目录查看是否有持久化文件(aof、rdb)生成。</p>

        <h1 id="本地镜像发布到阿里云"   >
          <a href="#本地镜像发布到阿里云" class="heading-link"><i class="fas fa-link"></i></a>本地镜像发布到阿里云</h1>
      
<ol>
<li>
<p>push 流程<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708162206.png"  alt="" />
      </p>
</li>
<li>
<p>镜像的生成方法<br />
a. 从dockerfile build<br />
b. 从容器 commit</p>
</li>
<li>
<p>将本地镜像推送到registry<br />
3.1. 创建镜像仓库 命名空间/仓库名称<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708162803.png"  alt="" />
      <br />
后面选择本地仓库</p>
</li>
</ol>
<p>3.2.<br />
获取registry地址<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708162954.png"  alt="" />
      </p>
<p>推送和查看 参考<span class="exturl"><a class="exturl__link"   href="https://cr.console.aliyun.com/repository/cn-hangzhou/lienhui68/tomcat/details"  target="_blank" rel="noopener">操作指南</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
4. 推送<br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708164318.png"  alt="" />
      </p>
<ol start="5">
<li>拉取</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull registry.cn-hangzhou.aliyuncs.com/lienhui68/tomcat:[镜像版本号]</span></span><br></pre></td></tr></table></div></figure>
<ol start="6">
<li>公有云上查看<br />
<span class="exturl"><a class="exturl__link"   href="https://promotion.aliyun.com/ntms/act/kubernetes.html"  target="_blank" rel="noopener">search页面</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />

        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200708164649.png"  alt="" />
      </li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/300_DevOps/docker/docker_quickstart/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/300_DevOps/docker/docker_quickstart/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/docker/">docker</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/300_DevOps/docker/docker%E4%BD%BF%E7%94%A8%E7%AF%87/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">docker使用篇</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/%E9%94%81/"><span class="paginator-prev__text">锁</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">
          简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#是什么"><span class="toc-number">1.1.</span> <span class="toc-text">
          是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么会出现docker"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          为什么会出现docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker理念"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          docker理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker基本组成"><span class="toc-number">1.1.3.</span> <span class="toc-text">
          docker基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一句话"><span class="toc-number">1.1.4.</span> <span class="toc-text">
          一句话</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#能干嘛"><span class="toc-number">1.2.</span> <span class="toc-text">
          能干嘛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#之前的虚拟化工作"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          之前的虚拟化工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器化虚拟工作"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          容器化虚拟工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发自运维devops"><span class="toc-number">1.2.3.</span> <span class="toc-text">
          开发自运维(DevOps)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#企业级"><span class="toc-number">1.2.4.</span> <span class="toc-text">
          企业级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#去哪下"><span class="toc-number">1.3.</span> <span class="toc-text">
          去哪下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安装"><span class="toc-number">2.</span> <span class="toc-text">
          安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装步骤"><span class="toc-number">2.1.</span> <span class="toc-text">
          安装步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#底层原理"><span class="toc-number">2.2.</span> <span class="toc-text">
          底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker是怎么工作的"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          docker是怎么工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么docker比vm快"><span class="toc-number">2.2.2.</span> <span class="toc-text">
          为什么docker比VM快</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常用命令"><span class="toc-number">3.</span> <span class="toc-text">
          常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#帮助命令"><span class="toc-number">3.1.</span> <span class="toc-text">
          帮助命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像命令"><span class="toc-number">3.2.</span> <span class="toc-text">
          镜像命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器命令"><span class="toc-number">3.3.</span> <span class="toc-text">
          容器命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小总结"><span class="toc-number">3.4.</span> <span class="toc-text">
          小总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#镜像"><span class="toc-number">4.</span> <span class="toc-text">
          镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像是什么"><span class="toc-number">4.1.</span> <span class="toc-text">
          镜像是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器层镜像层"><span class="toc-number">4.2.</span> <span class="toc-text">
          容器层&amp;镜像层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器commit新镜像"><span class="toc-number">4.3.</span> <span class="toc-text">
          容器commit新镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器数据卷"><span class="toc-number">5.</span> <span class="toc-text">
          容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#是什么-2"><span class="toc-number">5.1.</span> <span class="toc-text">
          是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加数据卷"><span class="toc-number">5.2.</span> <span class="toc-text">
          添加数据卷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dockerfile"><span class="toc-number">6.</span> <span class="toc-text">
          dockerFile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dockerfile构建过程解析"><span class="toc-number">6.1.</span> <span class="toc-text">
          dockerFile构建过程解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保留字"><span class="toc-number">6.2.</span> <span class="toc-text">
          保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建自定义tomcat镜像"><span class="toc-number">6.3.</span> <span class="toc-text">
          构建自定义tomcat镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常用安装"><span class="toc-number">7.</span> <span class="toc-text">
          常用安装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#本地镜像发布到阿里云"><span class="toc-number">8.</span> <span class="toc-text">
          本地镜像发布到阿里云</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">314</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>