<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="本章主要内容  ByteBuf ——Netty 的数据容器 API 的详细信息 用例 内存分配">
<meta property="og:type" content="article">
<meta property="og:title" content="ByteBuf">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Netty%E5%AE%9E%E6%88%98/5_ByteBuf/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="本章主要内容  ByteBuf ——Netty 的数据容器 API 的详细信息 用例 内存分配">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200905181544.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200905210027.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200905211824.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200905211938.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906053416.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906053446.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906055334.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906055401.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906060635.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906060723.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906061311.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906061449.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906061727.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200906062226.png">
<meta property="article:published_time" content="2020-08-01T01:04:05.000Z">
<meta property="article:modified_time" content="2020-09-16T16:26:16.506Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200905181544.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>ByteBuf | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Netty%E5%AE%9E%E6%88%98/5_ByteBuf/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">ByteBuf</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-08-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">52分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p><strong>本章主要内容</strong></p>
<ul>
<li>ByteBuf ——Netty 的数据容器</li>
<li>API 的详细信息</li>
<li>用例</li>
<li>内存分配</li>
</ul>
<a id="more"></a>
<p>正如前面所提到的，网络数据的基本单位总是字节。Java NIO 提供了 的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。</p>
<p>Netty的ByteBuffer 替代品是 ByteBuf ， 一个强大的实现，既解决了 JDK API 的局限性， 又为网络应用程序的开发者提供了更好的 API。</p>
<p>在本章中我们将会说明和 JDK 的 ByteBuffer 相比， ByteBuf 的卓越功能性和灵活性。这 也将有助于更好地理解 Netty 数据处理的一般方式，并为将在第 6 章中针对 ChannelPipeline 和 ChannelHandler 的讨论做好准备。</p>

        <h1 id="bytebuf的api"   >
          <a href="#bytebuf的api" class="heading-link"><i class="fas fa-link"></i></a>ByteBuf的API</h1>
      
<p>Netty 的数据处理 API 通过两个组件暴露—— abstract class ByteBuf 和 interface ByteBufHolder 。</p>
<p>下面是一些 ByteBuf API 的优点：</p>
<ul>
<li>它可以被用户自定义的缓冲区类型扩展；</li>
<li>通过内置的复合缓冲区类型实现了透明的零拷贝；</li>
<li>容量可以按需增长（类似于 JDK 的StringBuilder）；</li>
<li>在读和写这两种模式之间切换不需要调用ByteBuffer的flip() 方法；</li>
<li>读和写使用了不同的索引；</li>
<li>支持方法的链式调用；</li>
<li>支持引用计数；</li>
<li>支持池化。</li>
</ul>
<p>其他类可用于管理 ByteBuf 实例的分配，以及执行各种针对于数据容器本身和它所持有的 数据的操作。我们将在仔细研究 ByteBuf 和 ByteBufHolder 时探讨这些特性。</p>

        <h1 id="bytebuf类netty的数据容器"   >
          <a href="#bytebuf类netty的数据容器" class="heading-link"><i class="fas fa-link"></i></a>ByteBuf类——Netty的数据容器</h1>
      
<p>因为所有的网络通信都涉及字节序列的移动，所以高效易用的数据结构明显是必不可少的。 Netty 的 ByteBuf 实现满足并超越了这些需求。让我们首先来看看它是如何通过使用不同的索引 来简化对它所包含的数据的访问的吧。</p>

        <h2 id="它是如何工作的"   >
          <a href="#它是如何工作的" class="heading-link"><i class="fas fa-link"></i></a>它是如何工作的</h2>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">"你好"</span>.getBytes(Charsets.UTF_8));</span><br><span class="line">System.out.println(byteBuf.toString(Charsets.UTF_8));</span><br></pre></td></tr></table></div></figure>
<p>ByteBuf 维护了两个不同的索引：一个用于读取，一个用于写入。当你从 ByteBuf 读取时， 它的 readerIndex 将会被递增已经被读取的字节数。同样地，当你写入 ByteBuf 时，它的 writerIndex 也会被递增。图 5-1 展示了一个空 ByteBuf 的布局结构和状态。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200905181544.png"  alt="" />
      </p>
<p>要了解这些索引两两之间的关系，请考虑一下，如果打算读取字节直到 readerIndex 达到 和 writerIndex 同样的值时会发生什么。在那时，你将会到达“可以读取的”数据的末尾。就 如同试图读取超出数组末尾的数据一样，试图读取超出该点的数据将会触发一个 IndexOutOfBoundsException 。</p>
<p>名称以 read 或者 write 开头的 ByteBuf 方法，将会推进其对应的索引，而名称以 set 或 者 get 开头的操作则不会。后面的这些方法将<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>在作为一个参数传入的一个相对索引上执行操作</span>。</p>
<p>可以指定 ByteBuf 的最大容量。试图移动写索引（即 writerIndex ）超过这个值将会触 发一个异常 。（默认的限制是 Integer.MAX_VALUE 。）</p>
<blockquote>
<p>也就是说用户直接或者间接使 capacity(int)或者 ensureWritable(int)方法来增加超过该最大 容量时抛出异常。—译者注</p>
</blockquote>

        <h2 id="bytebuf的使用模式"   >
          <a href="#bytebuf的使用模式" class="heading-link"><i class="fas fa-link"></i></a>ByteBuf的使用模式</h2>
      
<p>在使用 Netty 时，你将遇到几种常见的围绕 ByteBuf 而构建的使用模式。在研究它们时，我们心里想着图 5-1 会有所裨益 —— 一个由不同的索引分别控制读访问和写访问的字节数组。</p>

        <h3 id="堆缓冲区"   >
          <a href="#堆缓冲区" class="heading-link"><i class="fas fa-link"></i></a>堆缓冲区</h3>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:bold'>最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。 这种模式被称为支撑数组 （backing array），它能在没有使用池化的情况下提供快速的分配和释放。</span>这种方式，如代码清单 5-1 所示，非常适合于有遗留的数据需要处理的情况。</p>
<p><strong>代码清单 5-1 支撑数组</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf heapBuf = Unpooled.copiedBuffer(<span class="string">"Hello world"</span>.getBytes(Charsets.UTF_8));</span><br><span class="line">        <span class="comment">// 如果使用下面这种方式则会有问题，支持数组的长度计算：</span></span><br><span class="line">        <span class="comment">// int length = (int) ((double) src.remaining() * encoder.maxBytesPerChar()) + extraCapacity;</span></span><br><span class="line">        <span class="comment">// utf8 每个字符占3个字节，所以会在原始字符个数上乘以3</span></span><br><span class="line">        <span class="comment">// ByteBuf heapBuf = Unpooled.copiedBuffer("Hello world", Charsets.UTF_8);</span></span><br><span class="line">        <span class="keyword">if</span> (heapBuf.hasArray()) &#123; <span class="comment">// 检查 ByteBuf 是否 有一个支撑数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] array = heapBuf.array(); <span class="comment">// 如果有，则获取 对该数组的引用</span></span><br><span class="line">            <span class="comment">// 计算第一个字节 的偏移量。</span></span><br><span class="line">            <span class="keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.readerIndex();</span><br><span class="line">            <span class="comment">// 获得可读 字节数</span></span><br><span class="line">            <span class="keyword">int</span> length = heapBuf.readableBytes();</span><br><span class="line">            <span class="comment">// 使用数组、偏移量和长度 作为参数调用你的方法</span></span><br><span class="line">            handleArray(array, offset, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleArray</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"array: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : array) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"内置数组长度: "</span> + array.length);</span><br><span class="line">        System.out.println(<span class="string">"offset: "</span> + offset);</span><br><span class="line">        System.out.println(<span class="string">"length: "</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">array: </span><br><span class="line">Hello world</span><br><span class="line">内置数组长度: <span class="number">11</span></span><br><span class="line">offset: <span class="number">0</span></span><br><span class="line">length: <span class="number">11</span></span><br></pre></td></tr></table></div></figure>
<p><strong>注意</strong>： 当 hasArray() 方法返回 false 时， 尝试访问支撑数组将触发一个Unsupported OperationException 。这个模式类似于 JDK 的 ByteBuffer 的用法。</p>

        <h3 id="直接缓冲区"   >
          <a href="#直接缓冲区" class="heading-link"><i class="fas fa-link"></i></a>直接缓冲区</h3>
      
<p>直接缓冲区是另外一种 ByteBuf 模式。我们期望用于对象创建的内存分配永远都来自于堆 中，但这并不是必须的——NIO 在 JDK 1.4 中引入的 ByteBuffer 类允许 JVM 实现通过本地调 用来分配内存。这主要是为了避免在每次调用本地 I/O 操作之前（或者之后）将缓冲区的内容复 制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。</p>
<blockquote>
<p>中间缓冲区指的就是内核缓冲区</p>
</blockquote>
<p>ByteBuffer的Javadoc 明确指出：“直接缓冲区的内容将驻留在常规的会被垃圾回收的堆 之外。”这也就解释了为何直接缓冲区对于网络数据传输是理想的选择。如果你的数据包含在一 个在堆上分配的缓冲区中，那么事实上，在通过套接字发送它之前，JVM将会在内部把你的缓冲 区复制到一个直接缓冲区中。</p>
<p>直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。如果你 正在处理遗留代码，你也可能会遇到另外一个缺点：因为数据不是在堆上，所以你不得不进行一 次复制，如代码清单 5-2 所示。</p>
<p><strong>代码清单 5-2 访问直接缓冲区的数据</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认初始大小 256个字节, 最大大小 Integer.MAX_VALUE</span></span><br><span class="line">        ByteBuf directBuf = Unpooled.directBuffer();</span><br><span class="line">        directBuf.writeBytes(<span class="string">"Hello world"</span>.getBytes(Charsets.UTF_8));</span><br><span class="line">        <span class="comment">// 检查 ByteBuf 是否由数 组支撑。如果不是，则 这是一个直接缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (!directBuf.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = directBuf.readableBytes(); <span class="comment">// 获取可读 字节数</span></span><br><span class="line">            <span class="comment">// 分配一个新的数组来保存 具有该长度的字节数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">            <span class="comment">// 将字节复制到该数组</span></span><br><span class="line">            directBuf.getBytes(directBuf.readerIndex(), array);</span><br><span class="line">            <span class="comment">// 使用数组、偏移量和长度 作为参数调用你的方法</span></span><br><span class="line">            handleArray(array, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleArray</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"array: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : array) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"内置数组长度: "</span> + array.length);</span><br><span class="line">        System.out.println(<span class="string">"offset: "</span> + offset);</span><br><span class="line">        System.out.println(<span class="string">"length: "</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">array: </span><br><span class="line">Hello world</span><br><span class="line">内置数组长度: <span class="number">11</span></span><br><span class="line">offset: <span class="number">0</span></span><br><span class="line">length: <span class="number">11</span></span><br></pre></td></tr></table></div></figure>
<p>显然，与使用支撑数组相比，这涉及的工作更多（如果需要作为数组访问的话）。因此，如果事先知道容器中的数据将会被 作为数组来访问，你可能更愿意使用堆内存。</p>

        <h3 id="复合缓冲区"   >
          <a href="#复合缓冲区" class="heading-link"><i class="fas fa-link"></i></a>复合缓冲区</h3>
      
<p>第三种也是最后一种模式使用的是复合缓冲区，它<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:bold'>为多个 ByteBuf 提供一个聚合视图</span>。在 这里你可以根据需要添加或者删除 ByteBuf 实例，这是一个 JDK 的 ByteBuffer 实现完全缺 失的特性。</p>
<p>Netty 通过一个 ByteBuf子类—— CompositeByteBuf ——实现了这个模式， <span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>它提供了一 个将多个缓冲表示为单个合并缓冲区的虚拟表示。</span></p>
<blockquote>
<p><strong>警告</strong></p>
<p>CompositeByteBuf 中的 ByteBuf 实例可能同时包含直接内存分配和非直接内存分配。 如果其中只有一个实例，那么对 CompositeByteBuf 上的 hasArray() 方法的调用将返回该组 件上的 hasArray() 方法的值；否则它将返回 false 。</p>
</blockquote>
<p>为了举例说明，让我们考虑一下一个由两部分——头部和主体——组成的将通过 HTTP 协议 传输的消息。这两部分由应用程序的不同模块产生，将会在消息被发送的时候组装。该应用程序 可以选择为多个消息重用相同的消息主体。当这种情况发生时，对于每个消息都将会创建一个新 的头部。</p>
<p>因为我们不想为每个消息都重新分配这两个缓冲区，所以使用 CompositeByteBuf 是一个 完美的选择。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>它在消除了没必要的复制的同时，暴露了通用的 ByteBuf API。</span>图 5-2 展示了生成 的消息布局。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200905210027.png"  alt="" />
      </p>
<p>代码清单 5-3 展示了如何通过使用 JDK 的 ByteBuffer 来实现这一需求。创建了一个包含 两个 ByteBuffer 的数组用来保存这些消息组件，同时创建了第三个 ByteBuffer 用来保存所 有这些数据的副本。</p>
<p><strong>代码清单 5-3 使用 ByteBuffer 的复合缓冲区模式</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ...;</span><br><span class="line">ByteBuffer body = ...;</span><br><span class="line"><span class="comment">// Use an array to hold the message parts</span></span><br><span class="line">ByteBuffer[] message = <span class="keyword">new</span> ByteBuffer[]&#123;header, body&#125;;</span><br><span class="line"><span class="comment">// Create a new ByteBuffer and use copy to merge the header and body</span></span><br><span class="line">ByteBuffer message2 = ByteBuffer.allocate(header.remaining() + body.remaining());</span><br><span class="line">message2.put(header);</span><br><span class="line">message2.put(body);</span><br><span class="line">message2.flip();</span><br></pre></td></tr></table></div></figure>
<p>分配和复制操作，以及伴随着对数组管理的需要，使得这个版本的实现效率低下而且笨拙。 代码清单 5-4 展示了一个使用了 CompositeByteBuf 的版本。</p>
<p><strong>代码清单 5-4 使用 CompositeByteBuf 的复合缓冲区模式</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf header = ...; <span class="comment">// can be backing(支撑) or direct</span></span><br><span class="line">ByteBuf body = ...; <span class="comment">// can be backing or direct</span></span><br><span class="line">CompositeByteBuf messageBuf = Unpooled.compositeBuffer();</span><br><span class="line"><span class="comment">// 将 ByteBuf 实例追加 到 CompositeByteBuf</span></span><br><span class="line">messageBuf.addComponent(header);</span><br><span class="line">messageBuf.addComponent(body);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 删除位于索引位置为 0 （第一个组件）的 ByteBuf</span></span><br><span class="line">messageBuf.removeComponent(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 循环遍历所有 的 ByteBuf 实例</span></span><br><span class="line"><span class="keyword">for</span> (ByteBuf byteBuf : messageBuf) &#123;</span><br><span class="line">    System.out.println(byteBuf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>CompositeByteBuf 可能不支持访问其支撑数组，因此访问 CompositeByteBuf 中的数据类似于（访问）直接缓冲区的模式，如代码清单 5-5 所示。</p>
<p><strong>代码清单 5-5 访问 CompositeByteBuf 中的数据</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line"><span class="comment">// 获得可读 字节数</span></span><br><span class="line"><span class="keyword">int</span> length = compBuf.readableBytes();</span><br><span class="line"><span class="comment">// 分配一个具有可读字节 数长度的新数组</span></span><br><span class="line"><span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line"><span class="comment">// 将字节读到 该数组中</span></span><br><span class="line">compBuf.getBytes(compBuf.readerIndex(), array);</span><br><span class="line"><span class="comment">// 使用偏移量和长度作 为参数使用该数组</span></span><br><span class="line">handleArray(array, <span class="number">0</span>, array.length);</span><br></pre></td></tr></table></div></figure>
<p>需要注意的是，Netty使用了 CompositeByteBuf 来优化套接字的I/O操作，尽可能地消除了 由JDK的缓冲区实现所导致的性能以及内存使用率的惩罚。 这种优化发生在Netty的核心代码中， 因此不会被暴露出来，但是你应该知道它所带来的影响。</p>
<blockquote>
<p>这尤其适用于 JDK 所使用的一种称为分散/收集 I/O（Scatter/Gather I/O）的工作，定义为“一种输入和 输出的方法，其中，单个系统调用从单个数据流写到一组缓冲区中，或者，从单个数据源读到一组缓冲 区中”</p>
</blockquote>
<p><strong>CompositeByteBuf API</strong> 除了从 ByteBuf 继承的方法， CompositeByteBuf 提供了大量的附 加功能。请参考 Netty 的 Javadoc 以获得该 API 的完整列表。</p>

        <h1 id="字节级操作"   >
          <a href="#字节级操作" class="heading-link"><i class="fas fa-link"></i></a>字节级操作</h1>
      
<p>ByteBuf 提供了许多超出基本读、写操作的方法用于修改它的数据。在接下来的章节中， 我们将会讨论这些中最重要的部分。</p>

        <h2 id="随机访问索引"   >
          <a href="#随机访问索引" class="heading-link"><i class="fas fa-link"></i></a>随机访问索引</h2>
      
<p>如同在普通的 Java 字节数组中一样， ByteBuf 的索引是从零开始的：第一个字节的索引是 0，最后一个字节的索引总是 capacity() - 1 。代码清单 5-6 表明，对存储机制的封装使得遍 历 ByteBuf 的内容非常简单。</p>
<p><strong>代码清单 5-6 访问数据</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Hello world"</span>.getBytes(Charsets.UTF_8));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.capacity(); i++) &#123;</span><br><span class="line">    <span class="keyword">byte</span> b = buf.getByte(i);</span><br><span class="line">    System.out.println((<span class="keyword">char</span>) b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>需要注意的是，使用那些需要一个索引值参数的方法（的其中）之一来访问数据既不会改变 readerIndex 也不会改变 writerIndex 。如果有需要，也可以<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>通过调用 readerIndex(index) 或者 writerIndex(index) 来手动移动这两者。</span></p>

        <h2 id="顺序访问索引"   >
          <a href="#顺序访问索引" class="heading-link"><i class="fas fa-link"></i></a>顺序访问索引</h2>
      
<p>虽然 ByteBuf 同时具有读索引和写索引，但是 JDK 的 ByteBuffer 却只有一个索引，这 也就是为什么必须调用 flip() 方法来在读模式和写模式之间进行切换的原因。图 5-3 展示了 ByteBuf 是如何被它的两个索引划分成 3 个区域的。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200905211824.png"  alt="" />
      </p>

        <h2 id="可丢弃字节"   >
          <a href="#可丢弃字节" class="heading-link"><i class="fas fa-link"></i></a>可丢弃字节</h2>
      
<p>在图 5-3 中标记为可丢弃字节的分段包含了已经被读过的字节。通过调用 discardRead- Bytes() 方法，可以丢弃它们并回收空间。这个分段的初始大小为 0，存储在 readerIndex 中， 会随着 read 操作的执行而增加（ get* 操作不会移动 readerIndex ）。</p>
<p>图 5-4 展示了图 5-3 中所展示的缓冲区上调用 discardReadBytes() 方法后的结果。可以看 到，可丢弃字节分段中的空间已经变为可写的了。注意，在调用 discardReadBytes() 之后，对 可写分段的内容并没有任何的保证 。</p>
<blockquote>
<p>因为只是移动了可以读取的字节以及 writerIndex，而没有对所有可写入的字节进行擦除写。</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200905211938.png"  alt="" />
      </p>
<p>虽然你可能会倾向于频繁地调用 discardReadBytes() 方法以确保可写分段的最大化，但是 请注意，这将<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>极有可能会导致内存复制</span>，因为可读字节（图中标记为 CONTENT 的部分）必须被移 动到缓冲区的开始位置。我们建议只在有真正需要的时候才这样做，例如，当内存非常宝贵的时候。</p>

        <h2 id="可读字节"   >
          <a href="#可读字节" class="heading-link"><i class="fas fa-link"></i></a>可读字节</h2>
      
<p>ByteBuf 的可读字节分段存储了实际数据。新分配的、包装的或者复制的缓冲区的默认的 readerIndex 值为 0。任何名称以 read 或者 skip 开头的操作都将检索或者跳过位于当前 readerIndex 的数据，并且将它增加已读字节数。</p>
<p>如果被调用的方法需要一个 ByteBuf 参数作为写入的目标，并且没有指定目标索引参数， 那么该目标缓冲区的 writerIndex 也将被增加，例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unpooled.copiedBuffer,初始大小和最大大小都为字符序列字节大小</span></span><br><span class="line">ByteBuf src = Unpooled.copiedBuffer(<span class="string">"Hello"</span>.getBytes(Charsets.UTF_8));</span><br><span class="line"><span class="comment">// 必须要初始化initialCapacity,否则默认的initialCapacity是256，</span></span><br><span class="line"><span class="comment">// src只有5个可读字节，dest从src读5个字节后接着读，就会报IndexOutOfBoundsException</span></span><br><span class="line">ByteBuf dest = Unpooled.buffer(<span class="number">5</span>);</span><br><span class="line">System.out.println(src.toString() + dest.toString());</span><br><span class="line">src.readBytes(dest);</span><br><span class="line">System.out.println(src.toString() + dest.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">UnpooledHeapByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">5</span>, cap: <span class="number">5</span>/<span class="number">5</span>)UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">0</span>, cap: <span class="number">5</span>)</span><br><span class="line">UnpooledHeapByteBuf(ridx: <span class="number">5</span>, widx: <span class="number">5</span>, cap: <span class="number">5</span>/<span class="number">5</span>)UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">5</span>, cap: <span class="number">5</span>)</span><br></pre></td></tr></table></div></figure>
<p><span style='color:red;background:yellow;font-size:文字大小;font-weight:'>如果尝试在缓冲区的可读字节数已经耗尽时从中读取数据，那么将会引发一个 IndexOutOfBoundsException 。</span></p>
<p>代码清单 5-7 展示了如何读取所有可以读的字节。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unpooled.copiedBuffer,初始大小和最大大小都为字符序列字节大小</span></span><br><span class="line">ByteBuf src = Unpooled.copiedBuffer(<span class="string">"Hello"</span>.getBytes(Charsets.UTF_8));</span><br><span class="line"><span class="comment">// 这次没有初始化initialCapacity,默认的initialCapacity是256，挨个字节读取就没有问题</span></span><br><span class="line">ByteBuf dest = Unpooled.buffer();</span><br><span class="line"><span class="keyword">while</span> (src.isReadable()) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * writeByte</span></span><br><span class="line"><span class="comment">     * Sets the specified byte at the current &#123;<span class="doctag">@code</span> writerIndex&#125;</span></span><br><span class="line"><span class="comment">     * and increases the &#123;<span class="doctag">@code</span> writerIndex&#125; by &#123;<span class="doctag">@code</span> 1&#125; in this buffer.</span></span><br><span class="line"><span class="comment">     * The 24 high-order bits of the specified value are ignored.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">     *         if &#123;<span class="doctag">@code</span> this.writableBytes&#125; is less than &#123;<span class="doctag">@code</span> 1&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dest.writeByte(src.readByte());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dest.toString());</span><br></pre></td></tr></table></div></figure>

        <h2 id="可写字节"   >
          <a href="#可写字节" class="heading-link"><i class="fas fa-link"></i></a>可写字节</h2>
      
<p>可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域。 新分配的缓冲区的 writerIndex 的默认值为 0。任何名称以 write 开头的操作都将从当前的 writerIndex 处 开始写数据，并将它增加已经写入的字节数。如果写操作的目标也是 ByteBuf ，并且没有指定 源索引的值，则源缓冲区的 readerIndex 也同样会被增加相同的大小。这个调用如下所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    writeBytes(src, <span class="number">0</span>, src.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果尝试往目标写入超过目标容量的数据，将会引发一个 IndexOutOfBoundException 。 代码清单5-8 是一个用随机整数值填充缓冲区，直到它空间不足为止的例子。 writeableBytes() 方法在这里被用来确定该缓冲区中是否还有足够的空间。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fills the writable bytes of a buffer with random integers.</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">ByteBuf dest = Unpooled.buffer(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    dest.writeInt(random.nextInt());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">IndexOutOfBoundsException: writerIndex(<span class="number">4</span>) + minWritableBytes(<span class="number">4</span>) <span class="function">exceeds <span class="title">maxCapacity</span><span class="params">(<span class="number">5</span>)</span></span></span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>在往 ByteBuf 中写入数据时，其将首先确保目标 ByteBuf 具有足够的可写入空间来容纳当前要写入 的数据，如果没有，则将检查当前的写索引以及最大容量是否可以在扩展后容纳该数据，可以则会分配 并调整容量，否则就会抛出该异常。</p>
</blockquote>

        <h2 id="索引管理"   >
          <a href="#索引管理" class="heading-link"><i class="fas fa-link"></i></a>索引管理</h2>
      
<p>JDK 的 InputStream 定义了 mark(int readlimit) 和 reset() 方法，这些方法分别 被用来将流中的当前位置标记为指定的值，以及将流重置到该位置。</p>
<p>同样，可以通过调用 markReaderIndex() 和 markWriterIndex() 、 resetWriterIndex()   、  resetReaderIndex() 来标记和重置 ByteBuf 的 readerIndex 和 writerIndex 。这些和 InputStream 上的调用类似，只是没有 readlimit 参数来指定标记什么时候失效。</p>
<p>也可以通过调用 readerIndex(int) 或者 writerIndex(int) 来将索引移动到指定位置。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:bold'>试 图将任何一个索引设置到一个无效的位置都将导致一个 IndexOutOfBoundsException 。</span></p>
<p>可以通过调用 clear() 方法来将 readerIndex 和 writerIndex 都设置为 0。注意，这 并不会清除内存中的内容。图 5-5（重复上面的图 5-3）展示了它是如何工作的。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906053416.png"  alt="" />
      </p>
<p>和之前一样， ByteBuf 包含 3 个分段。图 5-6 展示了在 clear() 方法被调用之后 ByteBuf 的状态。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906053446.png"  alt="" />
      </p>
<p>调用 clear() 比调用 discardReadBytes() 轻量得多，因为它将只是重置索引而不会复 制任何的内存。</p>

        <h2 id="查找操作"   >
          <a href="#查找操作" class="heading-link"><i class="fas fa-link"></i></a>查找操作</h2>
      
<p>在 ByteBuf 中有多种可以用来确定指定值的索引的方法。最简单的是使用 indexOf() 方法。 较复杂的查找可以通过那些需要一个 ByteProcessor 作为参数的方法达成。</p>
<blockquote>
<p>在 Netty 4.1.x 之前可以使用ByteBufProcessor，不过在4.1之后该类已经废弃，请使用 io.netty.util.ByteProcessor。</p>
</blockquote>
<p>这个接口只定 义了一个方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">byte</span> value)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></div></figure>
<p>它将检查输入值是否是正在查找的值。</p>
<p>ByteProcessor 针对一些常见的值定义了许多便利的方法。假设你的应用程序需要和 所谓的包含有以NULL结尾的内容的Flash套接字 集成。调用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ...;</span><br><span class="line">buf.forEachByte(ByteProcessor.FIND_NUL);</span><br></pre></td></tr></table></div></figure>
<p>将简单高效地消费该 Flash 数据，因为在处理期间只会执行较少的边界检查。 代码清单 5-9 展示了一个查找回车符（<code>\r</code> ）的例子。</p>
<p><strong>代码清单 5-9 使用 ByteBufProcessor 来寻找 <code>\r</code></strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">"Hello\r"</span>.getBytes());</span><br><span class="line"><span class="keyword">int</span> index = buffer.forEachByte(ByteProcessor.FIND_CR);</span><br><span class="line">System.out.println(index);</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="派生缓冲区"   >
          <a href="#派生缓冲区" class="heading-link"><i class="fas fa-link"></i></a>派生缓冲区</h2>
      
<p>派生缓冲区为 ByteBuf 提供了以专门的方式来呈现其内容的视图。这类视图是通过以下方 法被创建的：</p>
<ul>
<li>duplicate()</li>
<li>slice()</li>
<li>slice(int, int) ；</li>
<li>Unpooled.unmodifiableBuffer(…)；</li>
<li>order(ByteOrder)；</li>
<li>readSlice(int)</li>
</ul>
<p>每个这些方法都将返回一个新的 ByteBuf 实例， 它具有自己的读索引、写索引和标记 索引。 其内部存储和 JDK 的 ByteBuffer 一样也是共享的。 这使得派生缓冲区的创建成本 是很低廉的， 但是这也意味着， <span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>如果你修改了它的内容， 也同时修改了其对应的源实例</span>， 所 以要小心。</p>
<p><strong>ByteBuf 复制</strong> ：如果需要一个现有缓冲区的真实副本，请使用 copy() 或者 copy(int, int) 法。不同于派生缓冲区，由这个调用所返回的 ByteBuf 拥有<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>独立的数据副本</span>。</p>
<p>代码清单 5-10 展示了如何使用 slice(int, int) 方法来操作 ByteBuf 的一个分段。</p>
<p><strong>代码清单 5-10 对 ByteBuf 进行切片</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个用于保存给定字符 串的字节的 ByteBuf</span></span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty in Action rocks!"</span>, Charsets.UTF_8);</span><br><span class="line"><span class="comment">// 创建该 ByteBuf 从索 引 0 开始到索引 5 结束的一个新切片</span></span><br><span class="line">ByteBuf sliced = buf.slice(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(sliced.toString(Charsets.UTF_8));</span><br><span class="line"><span class="comment">// 更新索引 0 处的字节</span></span><br><span class="line">buf.setByte(<span class="number">0</span>, (<span class="keyword">byte</span>)<span class="string">'J'</span>);</span><br><span class="line"><span class="comment">// 将会成功，因为数据是共享的，对其中 一个所做的更改对另外一个也是可见的</span></span><br><span class="line"><span class="keyword">assert</span> buf.getByte(<span class="number">0</span>) == sliced.getByte(<span class="number">0</span>); <span class="comment">// right</span></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">Netty</span><br></pre></td></tr></table></div></figure>
<p>现在，让我们看看 ByteBuf 的分段的副本和切片有何区别，如代码清单 5-11 所示。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 创建 ByteBuf 以保存 所提供的字符串的字节</span></span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty in Action rocks!"</span>, utf8);</span><br><span class="line"><span class="comment">// 创建该 ByteBuf 从索 引 0 开始到索引 15 结束的分段的副本</span></span><br><span class="line">ByteBuf copy = buf.copy(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"><span class="comment">// 将打印 “Netty in Action”</span></span><br><span class="line">System.out.println(copy.toString(utf8));</span><br><span class="line"><span class="comment">// 更新索引 0 处的字节</span></span><br><span class="line">buf.setByte(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'J'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会成功，因为数据不是共享的</span></span><br><span class="line"><span class="keyword">assert</span> buf.getByte(<span class="number">0</span>) != copy.getByte(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">Netty in Action</span><br></pre></td></tr></table></div></figure>
<p>除了修改原始 ByteBuf 的切片或者副本的效果以外，这两种场景是相同的。只要有可能， 使用 slice() 方法来避免复制内存的开销。</p>

        <h2 id="读写操作"   >
          <a href="#读写操作" class="heading-link"><i class="fas fa-link"></i></a>读/写操作</h2>
      
<p>正如我们所提到过的，有两种类别的读/写操作：</p>
<ul>
<li>get() 和 set() 操作，从给定的索引开始，并且保持索引不变；</li>
<li>read() 和 write() 操作，从给定的索引开始， 并且会根据已经访问过的字节数对索引进行调整。</li>
</ul>
<p>表 5-1 列举了最常用的get() 方法。完整列表请参考对应的 API 文档。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906055334.png"  alt="" />
      </p>
<p>大多数的这些操作都有一个对应的 set()方法。这些方法在表 5-2 中列出。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906055401.png"  alt="" />
      </p>
<p>代码清单 5-12 说明了 get() 和 set() 方法的用法，表明了它们不会改变读索引和写索引。</p>
<p><strong>代码清单 5-12 get() 和 set() 方法的用法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty in Action rocks!"</span>, utf8);</span><br><span class="line"><span class="comment">// 打印第一 个字符'N'</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>) buf.getByte(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 存储当前的 readerIndex 和 writerIndex</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="keyword">int</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 将索引 0 处的字 节更新为字符'B'</span></span><br><span class="line">buf.setByte(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'B'</span>);</span><br><span class="line"><span class="comment">// 打印第一个字 符，现在是'B'</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>) buf.getByte(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 将会成功，因为这些操作 并不会修改相应的索引</span></span><br><span class="line"><span class="keyword">assert</span> readerIndex == buf.readerIndex();</span><br><span class="line"><span class="keyword">assert</span> writerIndex == buf.writerIndex();</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">N</span><br><span class="line">B</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p><strong>注意</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer();</span><br><span class="line">buf.writeInt(<span class="number">1</span>);</span><br><span class="line">buf.writeInt(<span class="number">2</span>);</span><br><span class="line">buf.writeInt(<span class="number">3</span>);</span><br><span class="line">System.out.println(buf.getInt(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line">System.out.println(buf.getInt(<span class="number">1</span>)); <span class="comment">// 256</span></span><br><span class="line">System.out.println(buf.getInt(<span class="number">2</span>)); <span class="comment">// 65536</span></span><br></pre></td></tr></table></div></figure>
</blockquote>
<p>现在，让我们研究一下 read() 操作，其作用于当前的 readerIndex 或 writerIndex 这些方法将用于从 ByteBuf 中读取数据，如同它是一个流。表 5-3 展示了最常用的方法。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906060635.png"  alt="" />
      </p>
<p>几乎每个 read() 方法都有对应的 write() 方法，用于<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>将数据追加到 ByteBuf 中</span>。注意， 表 5-4 中所列出的这些方法的参数是需要写入的值，而不是索引值。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906060723.png"  alt="" />
      </p>
<p>代码清单 5-13 展示了这些方法的用法。</p>
<p><strong>代码清单 5-13 ByteBuf 上的 read() 和 write() 操作</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 创建一个新的 ByteBuf 以保存 给定字符串的字节,maxCapacity = Integer.MAX_VALUE</span></span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty in Action rocks!"</span>, utf8);</span><br><span class="line"><span class="comment">// 打印第一 个字符'N'</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>) buf.readByte());</span><br><span class="line"><span class="comment">// 存储当前的 readerIndex</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="comment">// 存储当前的 writerIndex</span></span><br><span class="line"><span class="keyword">int</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 将字符'?'追加 到缓冲区</span></span><br><span class="line">buf.writeByte((<span class="keyword">byte</span>) <span class="string">'?'</span>);</span><br><span class="line"><span class="keyword">assert</span> readerIndex == buf.readerIndex();</span><br><span class="line"><span class="comment">// 将会成功，因为 writeByte() 方法移动了 writerIndex</span></span><br><span class="line"><span class="keyword">assert</span> writerIndex != buf.writerIndex();</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">N</span><br></pre></td></tr></table></div></figure>

        <h2 id="更多的操作"   >
          <a href="#更多的操作" class="heading-link"><i class="fas fa-link"></i></a>更多的操作</h2>
      
<p>表 5-5 列举了由 ByteBuf 提供的其他有用操作。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906061311.png"  alt="" />
      </p>

        <h1 id="bytebufholder接口"   >
          <a href="#bytebufholder接口" class="heading-link"><i class="fas fa-link"></i></a>ByteBufHolder接口</h1>
      
<p>我们经常发现，除了实际的数据负载之外，我们还需要存储各种属性值。HTTP 响应便是一 个很好的例子，除了表示为字节的内容，还包括状态码、cookie 等。</p>
<p>为了处理这种常见的用例，Netty 提供了 ByteBufHolder 。 ByteBufHolder 也为 Netty 的 高级特性提供了支持，如缓冲区池化，其中可以从池中借用 ByteBuf ，并且在需要时自动释放。</p>
<p>ByteBufHolder 只有几种用于访问底层数据和引用计数的方法。表 5-6 列出了它们（这里 不包括它继承自 ReferenceCounted 的那些方法）。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906061449.png"  alt="" />
      </p>
<p>如果想要实现一个将其有效负载存储在 ByteBuf 中的消息对象，那么 ByteBufHolder 将 是个不错的选择。</p>

        <h1 id="bytebuf分配"   >
          <a href="#bytebuf分配" class="heading-link"><i class="fas fa-link"></i></a>ByteBuf分配</h1>
      
<p>在这一节中，我们将描述管理 ByteBuf 实例的不同方式。</p>

        <h2 id="按需分配bytebufallocator接口"   >
          <a href="#按需分配bytebufallocator接口" class="heading-link"><i class="fas fa-link"></i></a>按需分配：ByteBufAllocator接口</h2>
      
<p>为了降低分配和释放内存的开销，Netty 通过 interface ByteBufAllocator 实现了 （ ByteBuf 的）池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。使用池化是特定于应用程序的决定，其并不会以任何方式改变 ByteBuf API（的语义）。 表 5-7 列出了 ByteBufAllocator 提供的一些操作。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906061727.png"  alt="" />
      </p>
<blockquote>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>ioBuffer(), 默认地，当所运行的环境具有 sun.misc.Unsafe 支持时，返回基于直接内存存储的 ByteBuf，否则 返回基于堆内存存储的 ByteBuf；当指定使用 PreferHeapByteBufAllocator 时，则只会返回基 于堆内存存储的 ByteBuf。</span></p>
</blockquote>
<p>可以通过 <strong>Channel</strong> （每个都可以有一个不同的 ByteBufAllocator 实例）或者绑定到 ChannelHandler 的 <strong>ChannelHandlerContext</strong> 获取一个到 ByteBufAllocator 的引用。 代码清单 5-14 说明了这两种方法。</p>
<p><strong>代码清单 5-14 获取一个到 ByteBufAllocator 的引用</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"><span class="comment">// 从 Channel 获取一个到 ByteBufAllocator 的引用</span></span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">ChannelHandlerContext ctx = ...;</span><br><span class="line"><span class="comment">// 从 ChannelHandlerContext 获取一个 到 ByteBufAllocator 的引用</span></span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure>
<p>Netty提供了两种 ByteBufAllocator 的实现： PooledByteBufAllocator 和 Unpooled- ByteBufAllocator 。前者池化了 ByteBuf 的实例以提高性能并最大限度地减少内存碎片。此实 现使用了一种称为jemalloc 的已被大量现代操作系统所采用的高效方法来分配内存。后者的实现不池化 ByteBuf 实例，并且在每次它被调用时都会返回一个新的实例。</p>
<p>虽然Netty默认 使用了 PooledByteBufAllocator ， 但这可以很容易地<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>通过 ChannelConfig API或者在引导你的应用程序时指定一个不同的分配器来更改</span>。更多的细节可在第8 章中找到。</p>
<blockquote>
<p>这里指 Netty4.1.x，Netty4.0.x 默认使用的是 UnpooledByteBufAllocator。</p>
</blockquote>

        <h2 id="unpooled缓冲区"   >
          <a href="#unpooled缓冲区" class="heading-link"><i class="fas fa-link"></i></a>Unpooled缓冲区</h2>
      
<p>可能某些情况下，你未能获取一个到 ByteBufAllocator 的引用。对于这种情况，Netty 提 供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf 实例。表 5-8 列举了这些中最重要的方法。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200906062226.png"  alt="" />
      </p>
<p><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:bold'>Unpooled 类还使得 ByteBuf 同样可用于那些并不需要 Netty 的其他组件的非网络项目， 使得其能得益于高性能的可扩展的缓冲区 API。</span></p>

        <h2 id="bytebufutil类"   >
          <a href="#bytebufutil类" class="heading-link"><i class="fas fa-link"></i></a>ByteBufUtil类</h2>
      
<p>ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。因为这个 API 是通用的，并 且和池化无关，所以这些方法已然在分配类的外部实现。</p>
<p>这些静态方法中最有价值的可能就是 hexdump() 方法， 它以十六进制的表示形式打印 ByteBuf 的内容。这在各种情况下都很有用，例如，出于调试的目的记录 ByteBuf 的内容。十 六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的 版本还可以很容易地转换回实际的字节表示。</p>
<p>另一个有用的方法是 boolean equals(ByteBuf, ByteBuf) ，它被用来判断两个 ByteBuf 实例的相等性。如果你实现自己的 ByteBuf 子类，你可能会发现 ByteBufUtil 的其他有用方法。</p>

        <h1 id="引用计数"   >
          <a href="#引用计数" class="heading-link"><i class="fas fa-link"></i></a>引用计数</h1>
      
<p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的工作。Netty 在第 4 版中为 ByteBuf 和 ByteBufHolder 引入了 引用计数工作，它们都实现了 interface ReferenceCounted 。</p>
<p>引用计数背后的想法并不是特别的复杂；它主要涉及跟踪到某个特定对象的活动引用的数 量。一个 ReferenceCounted 实现的实例将通常以活动的引用计数为 1 作为开始。只要引用计 数大于 0，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。注意， 虽然<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>释放的确切语义可能是特定于实现的</span>，但是至少已经释放的对象应该不可再用了。</p>
<p>引用计数对于池化实现（如 PooledByteBufAllocator ）来说是至关重要的， 它降低了内存分配的开销。代码清单 5-15 和代码清单 5-16 展示了相关的示例。</p>
<p><strong>代码清单 5-15 引用计数</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"><span class="comment">// 从 Channel 获取 ByteBufAllocator</span></span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="comment">// 从 ByteBufAllocator 分配一个 ByteBuf</span></span><br><span class="line">ByteBuf buffer = allocator.directBuffer();</span><br><span class="line"><span class="comment">// 检查引用计数是否 为预期的 1</span></span><br><span class="line"><span class="keyword">assert</span> buffer.refCnt() == <span class="number">1</span>;</span><br></pre></td></tr></table></div></figure>
<p><strong>代码清单 5-16 释放引用计数的对象</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ...;</span><br><span class="line"><span class="comment">// 减少到该对象的活动引用。当减少到 0 时， 该对象被释放，并且该方法返回 true</span></span><br><span class="line"><span class="keyword">boolean</span> released = buffer.release();</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure>
<p>试图访问一个已经被释放的引用计数的对象，将会导致一个 IllegalReferenceCountException。</p>
<p>注意，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>一个特定的（ ReferenceCounted 的实现）类，可以用它自己的独特方式来定义它 的引用计数规则。例如，我们可以设想一个类，其 release() 方法的实现总是将引用计数设为 零，而不用关心它的当前值，从而一次性地使所有的活动引用都失效。</span></p>
<blockquote>
<p><strong>谁负责释放</strong></p>
<p>一般来说，是由最后访问（引用计数）对象的那一方来负责将它释放。在第 6 章中， 我们将会解释这个概念和 ChannelHandler 以及 ChannelPipeline 的相关性。</p>
<p>使用release注意事项：</p>
<ul>
<li>只对DirectByteBuf类型的对象进行回收，由于这类数据非jvm控制，和c语言类似，需要显示回收内存。至于回收时间，应当在最后一次使用之后。</li>
<li>inbound中的自带实现中,SimpleInbound实现了回收.</li>
<li>还有需要注意的是，ChannleHandlerContext的flush方法是默认release的。</li>
</ul>
</blockquote>
<p><strong>为什么要有引用计数器</strong></p>
<p>Netty里四种主力的ByteBuf，其中UnpooledHeapByteBuf 底下的byte[]能够依赖JVM GC自然回收；而UnpooledDirectByteBuf底下是DirectByteBuffer，如Java堆外内存扫盲贴所述，除了等JVM GC，最好也能主动进行回收；而PooledHeapByteBuf 和PooledDirectByteBuf，则必须要主动将用完的byte[]/ByteBuffer放回池里，否则内存就要爆掉。所以，Netty ByteBuf需要在JVM的GC机制之外，有自己的引用计数器和回收过程。</p>
<p><strong>引用计数器常识</strong></p>
<p>计数器基于 AtomicIntegerFieldUpdater，为什么不直接用AtomicInteger？因为ByteBuf对象很多，如果都把int包一层AtomicInteger花销较大，而AtomicIntegerFieldUpdater只需要一个全局的静态变量。</p>
<p>所有ByteBuf的引用计数器初始值为1。</p>
<p>调用release()，将计数器减1，等于零时， deallocate()被调用，各种回收。</p>
<p>调用retain()，将计数器加1，即使ByteBuf在别的地方被人release()了，在本Class没喊cut之前，不要把它释放掉。</p>
<p>由duplicate(), slice()和order(ByteOrder)所创建的ByteBuf，与原对象共享底下的buffer，也共享引用计数器，所以它们经常需要调用retain()来显示自己的存在。</p>
<p>当引用计数器为0，底下的buffer已被回收，即使ByteBuf对象还在，对它的各种访问操作都会抛出异常。</p>
<p><strong>谁来负责Release</strong></p>
<p>在C时代，我们喜欢让malloc和free成对出现，而在Netty里，因为Handler链的存在，ByteBuf经常要传递到下一个Hanlder去而不复还，所以规则变成了谁是最后使用者，谁负责释放。</p>
<p>另外，更要注意的是各种异常情况，ByteBuf没有成功传递到下一个Hanlder，还在自己地界里的话，一定要进行释放。</p>

        <h1 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h1>
      
<p>本章专门探讨了 Netty 的基于 ByteBuf 的数据容器。我们首先解释了 ByteBuf 相对于 JDK 所提供的实现的优势。我们还强调了该 API 的其他可用变体，并且指出了它们各自最佳适用的特 定用例。</p>
<p>我们讨论过的要点有：</p>
<ul>
<li>使用不同的读索引和写索引来控制数据访问；</li>
<li>使用内存的不同方式——基于字节数组和直接缓冲区；</li>
<li>通过 CompositeByteBuf 生成多个 ByteBuf 的聚合视图；</li>
<li>数据访问方法——搜索、切片以及复制；</li>
<li>读、写、获取和设置 API；</li>
<li>ByteBufAllocator 池化和引用计数</li>
</ul>
<p>在下一章中，我们将专注于 ChannelHandler ，它为你的数据处理逻辑提供了载体。因为 ChannelHandler 大量地使用了 ByteBuf ，你将开始看到 Netty 的整体架构的各个重要部分最终走到了一起。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Netty%E5%AE%9E%E6%88%98/5_ByteBuf/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Netty%E5%AE%9E%E6%88%98/5_ByteBuf/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/netty/">netty</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Netty%E5%AE%9E%E6%88%98/6_ChannelHandler%E5%92%8CChannelPipeline/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">ChannelHandler和ChannelPipeline</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Netty%E5%AE%9E%E6%88%98/4_%E4%BC%A0%E8%BE%93/"><span class="paginator-prev__text">传输</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#bytebuf的api"><span class="toc-number">1.</span> <span class="toc-text">
          ByteBuf的API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bytebuf类netty的数据容器"><span class="toc-number">2.</span> <span class="toc-text">
          ByteBuf类——Netty的数据容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#它是如何工作的"><span class="toc-number">2.1.</span> <span class="toc-text">
          它是如何工作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bytebuf的使用模式"><span class="toc-number">2.2.</span> <span class="toc-text">
          ByteBuf的使用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#堆缓冲区"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          堆缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接缓冲区"><span class="toc-number">2.2.2.</span> <span class="toc-text">
          直接缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合缓冲区"><span class="toc-number">2.2.3.</span> <span class="toc-text">
          复合缓冲区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字节级操作"><span class="toc-number">3.</span> <span class="toc-text">
          字节级操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#随机访问索引"><span class="toc-number">3.1.</span> <span class="toc-text">
          随机访问索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顺序访问索引"><span class="toc-number">3.2.</span> <span class="toc-text">
          顺序访问索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可丢弃字节"><span class="toc-number">3.3.</span> <span class="toc-text">
          可丢弃字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可读字节"><span class="toc-number">3.4.</span> <span class="toc-text">
          可读字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可写字节"><span class="toc-number">3.5.</span> <span class="toc-text">
          可写字节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引管理"><span class="toc-number">3.6.</span> <span class="toc-text">
          索引管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找操作"><span class="toc-number">3.7.</span> <span class="toc-text">
          查找操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#派生缓冲区"><span class="toc-number">3.8.</span> <span class="toc-text">
          派生缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读写操作"><span class="toc-number">3.9.</span> <span class="toc-text">
          读&#x2F;写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多的操作"><span class="toc-number">3.10.</span> <span class="toc-text">
          更多的操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bytebufholder接口"><span class="toc-number">4.</span> <span class="toc-text">
          ByteBufHolder接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bytebuf分配"><span class="toc-number">5.</span> <span class="toc-text">
          ByteBuf分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#按需分配bytebufallocator接口"><span class="toc-number">5.1.</span> <span class="toc-text">
          按需分配：ByteBufAllocator接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unpooled缓冲区"><span class="toc-number">5.2.</span> <span class="toc-text">
          Unpooled缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bytebufutil类"><span class="toc-number">5.3.</span> <span class="toc-text">
          ByteBufUtil类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引用计数"><span class="toc-number">6.</span> <span class="toc-text">
          引用计数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">7.</span> <span class="toc-text">
          小结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">325</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>