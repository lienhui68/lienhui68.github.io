<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="本章内容  Java 8的新特性以及其对编程风格颠覆性的影响 由Java 8萌生的一些尚未成熟的编程思想 Java 9以及Java 10可能发生的变化">
<meta property="og:type" content="article">
<meta property="og:title" content="结论以及Java的未来">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/16_%E7%BB%93%E8%AE%BA%E4%BB%A5%E5%8F%8AJava%E7%9A%84%E6%9C%AA%E6%9D%A5/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="本章内容  Java 8的新特性以及其对编程风格颠覆性的影响 由Java 8萌生的一些尚未成熟的编程思想 Java 9以及Java 10可能发生的变化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200818154932.png">
<meta property="article:published_time" content="2020-07-01T01:04:16.000Z">
<meta property="article:modified_time" content="2020-09-16T16:26:17.008Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="java8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200818154932.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>结论以及Java的未来 | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/16_%E7%BB%93%E8%AE%BA%E4%BB%A5%E5%8F%8AJava%E7%9A%84%E6%9C%AA%E6%9D%A5/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">结论以及Java的未来</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-07-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">10.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">56分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p><strong>本章内容</strong></p>
<ul>
<li>Java 8的新特性以及其对编程风格颠覆性的影响</li>
<li>由Java 8萌生的一些尚未成熟的编程思想</li>
<li>Java 9以及Java 10可能发生的变化</li>
</ul>
<a id="more"></a>
<p>我们在本书中讨论了很多内容，希望你现在已经有足够的信心开始使用Java 8编写你自己 的代码，或者编译书中提供的例子和测验。这一章里，我们会回顾我们的Java 8学习之路和函 数式编程这一潮流。除此之外，还会展望在Java 8之后的版本中可能出现的新的改进和重大的 新特性。</p>

        <h1 id="回顾-java-8-的语言特性"   >
          <a href="#回顾-java-8-的语言特性" class="heading-link"><i class="fas fa-link"></i></a>回顾 Java 8 的语言特性</h1>
      
<p>Java 8是一种实践性强、实用性好的语言，想要很好地理解它，方法之一是重温它的各种特 性。本章不会简单地罗列Java 8的各种特性，而是会将这些特性串接起来，希望大家不仅能理解 这些新特性，还能<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>从语言设计的高度理解Java 8中语言设计的连贯性</span>。作为回顾，本章的另一个 目的是阐释Java 8的这些新特性是如何促进Java函数式编程风格的发展的。请记住，这些新特性 并非语言设计上的突发奇想，而是一种刻意的设计，它源于两种趋势，即我们在第1章中所说的 形势的变化。</p>
<ul>
<li><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>对多核处理器处理能力的需求日益增长</span>，虽然硬件开发工作也在不断进步，但依据摩尔定律每年新增的晶体管数量已经无法使独立CPU核的速度更快了。简单来说，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>要让你的代码运行得更快，需要你的代码具备并行运算的能力</span>。</li>
<li>更简洁地调度以显示风格处理数据的数据集合，这一趋势不断增长。比如，创建一些数 据源，抽象所有数据以符合给定的标准，给结果运用一些操作，而不是概括结果或者将 结果组成集合以后再做进一步处理。这一风格与使用不变对象和集合相关，它们之后会 进一步生成不变值。</li>
</ul>
<p>不过这两种诉求都不能很好地得到传统的、面向对象编程的支持，命令式的方式和通过迭代 器访问修改字段都不能满足新的需要。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>在CPU的一个核上修改数据，在另一个核上读取该数据的值，这种方式的代价是非常高的，更不用说你还需要考虑容易出错的锁；</span>类似地，当你的思考局 限于通过迭代访问和修改现存的对象时，类流（stream-like）式编程方法看起来就非常地异类。 不过，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>这两种新的潮流都能通过使用函数式编程非常轻松地得到支持，这也解释了为什么Java 8 的重心要从我们最初理解的Java大幅地转型。</span></p>
<p>现在，我们一起从统一、宏观的角度来回顾一下，看看我们都从这本书中学习了哪些东西， 它们又是如何相互协作构建出一片新的编程天地的。</p>

        <h2 id="行为参数化lambda-以及方法引用"   >
          <a href="#行为参数化lambda-以及方法引用" class="heading-link"><i class="fas fa-link"></i></a>行为参数化（Lambda 以及方法引用）</h2>
      
<p>为了编写可重用的方法，比如filter，你需要为其指定一个参数，它能够精确地描述过滤 条件。虽然Java专家们使用之前的版本也能达到同样的目的（将过滤条件封装成类的一个方法， 传递该类的一个实例），但这种方案却很难推广，因为它通常非常臃肿，既难于编写，也不易于 维护。</p>
<p>正如你在第2章和第3章中所了解的，Java 8通过借鉴函数式编程，提供了一种新的方式—— <span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>通过向方法传递代码片段来解决这一问题。这种新的方法非常方便地提供了两种变体。</span></p>
<ul>
<li>
<p>传递一个Lambda表达式，即一段精简的代码片段，比如</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apple -&gt; apple.getWeight() &gt; <span class="number">150</span></span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>传递一个方法引用，该方法引用指向了一个现有的方法，比如这样的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apple::isHeavy</span><br></pre></td></tr></table></div></figure>
</li>
</ul>
<p>这些值具有类似<code>Function&lt;T, R&gt;</code>、<code>Predicate&lt;T&gt;</code>或者<code>BiFunction&lt;T, U, R&gt;</code>这样的类 型，值的接收方可以通过apply、test或其他类似的方法执行这些方法。Lambda表达式自身是 一个相当酷炫的概念，不过Java 8对它们的使用方式——将它们与全新的Stream API相结合，最终 把它们推向了新一代Java的核心。</p>

        <h2 id="流"   >
          <a href="#流" class="heading-link"><i class="fas fa-link"></i></a>流</h2>
      
<p>集合类、迭代器，以及for-each结构在Java中历史悠久，也为广大程序员所熟知。直接在 集合类中添加filter或者map这样的方法，利用我们前面介绍的Lambda实现类数据库查询对于 Java 8的设计者而言要简单得多。不过他们并没有采用这种方式，而是引入了一套全新的Stream API，即第4章到第7章所介绍的内容——这是值得我们深思的，他们为什么要这么做呢？</p>
<p>集合到底有什么问题，以至于我们需要另起炉灶替换掉它们，或通过一个类似却不同的概念 Stream对其进行增强。我们把二者之间的差异概括如下：如果你有一个数据量庞大的集合，你需 要对这个集合应用三个操作，比如对这个集合中的对象进行映射，对其中的两个字段进行求和， 这之后依据某种条件过滤出满足条件的和，最后对结果进行排序，即为得到结果你需要分三次遍 历集合。Stream API则与之相反，它<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>采用延迟算法将这些操作组成一个流水线，通过单次流遍历， 一次性完成所有的操作。</span>对于大型的数据集，这种操作方式要高效得多。不过，还有一些需要我 们考虑的因素，比如内存缓存，数据集越大，越需要尽可能地减少遍历的次数。</p>
<p>还有其他一些原因也会影响元素并发处理的能力，这些也非常关键，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>对高效地利用多处理器的能力至关重要</span>。Stream，尤其是它的parallel方法能帮助将一个Stream标记为适合进行并行 处理。还记得吗？并行处理和对象的可变状态是水火不容的，所以<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>核心的函数式概念</span>（如我们在 第4章中介绍的，包括无副作用的操作，通过Lambda表达式和方法引用对方法进行参数化，用内 部迭代替换外部迭代）对于并行使用map、filter或者其他方法发掘Stream的处理能力非常重要。</p>
<p>现在，让我们看看这些观念（介绍Stream时使用过这些术语）怎样直接影响了Completable- Future类的设计。</p>

        <h2 id="completablefuture"   >
          <a href="#completablefuture" class="heading-link"><i class="fas fa-link"></i></a>CompletableFuture</h2>
      
<p>Java从Java 5版本就提供了Future接口。Future对于充分利用多核处理能力是非常有益的， 因为它<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>允许一个任务在一个新的核上生成一个新的子线程</span>，新生成的任务可以和原来的任务同时 运行。原来的任务需要结果时，它可以通过get方法等待Future运行结束（生成其计算的结果值）。</p>
<p>第11章介绍了Java 8中对Future的CompletableFuture实现。这里再次利用了Lambda表达 式。一个非常有用，不过不那么精确的格言这么说：“Completable-Future对于Future的意 义就像Stream之于Collection。”让我们比较一下这二者。</p>
<ul>
<li>通过Stream你可以对一系列的操作进行流水线，通过map、filter或者其他类似的方法 提供行为参数化，它可有效避免使用迭代器时总是出现模板代码。</li>
<li>类似地，CompletableFuture提供了像thenCompose、 thenCombine、 allOf这样的 操作，对Future涉及的通用设计模式提供了函数式编程的细粒度控制，有助于避免使用 命令式编程的模板代码。</li>
</ul>
<p>这种类型的操作，虽然大多数只能用于非常简单的场景，不过仍然适用于Java 8的Optional 操作，我们一起来回顾下这部分内容。</p>

        <h2 id="optional"   >
          <a href="#optional" class="heading-link"><i class="fas fa-link"></i></a>Optional</h2>
      
<p>Java 8的库提供了<code>Optional&lt;T&gt;</code>类，这个类允许你在代码中指定哪一个变量的值既可能是类 型T的值，也可能是由静态方法Optional.empty表示的缺失值。无论是对于理解程序逻辑，抑 或是对于编写产品文档而言，这都是一个重大的好消息，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>你现在可以通过一种数据类型表示显式缺失的值——使用空指针的问题在于你无法确切了解出现空指针的原因，它是预期的情况，还是说由于之前的某一次计算出错导致的一个偶然性的空值，有了Optional之后你就不需要再使用之前容易出错的空指针来表示缺失的值了。</span></p>
<p>正如我们在第10章中讨论的，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>如果在程序中始终如一地使用<code>Optional&lt;T&gt;</code>，你的应用应该 永远不会发生NullPointerException异常。</span>你可以将这看成另一个绝无仅有的特性，它和Java 8中其他部分都不直接相关，问自己一个问题：“为什么用一种表示值缺失的形式替换另一种能帮 助我们更好地编写程序？”进一步审视，我们发现Optional类提供了map、filter和ifPresent 方法。。这些方法和Streams类中的对应方法有着相似的行为，它们都能以函数式的结构串接计算，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>由于库自身提供了缺失值的检测机制，不再需要用户代码的干预。这种进行内部检测还是外部检测的选择和在Stream库中进行内部迭代还是在用户代码中进行外部迭代的选择极其类似。</span></p>
<p>本节最后我们不再涉及函数式编程的内容，而是要讨论一下Java 8对库的前向兼容性支持， 这一工作受到了软件工程发展的推动。</p>

        <h2 id="默认方法"   >
          <a href="#默认方法" class="heading-link"><i class="fas fa-link"></i></a>默认方法</h2>
      
<p>Java 8中增加了不少新特性，但是它们一般都不对个体程序的行为带来影响。不过，有一件 事情是例外，那就是新增的默认方法。接口中新引入的默认方法对类库的设计者而言简直是如鱼 得水。Java 8之前，接口主要用于定义方法签名，现在它们还能为接口的使用者提供方法的默认 实现，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>如果接口的设计者认为接口中声明的某个方法并不需要每一个接口的用户显式地提供实 现，他就可以考虑在接口的方法声明中为其定义默认方法。</span></p>
<p>对类库的设计者而言，这是个伟大的新工具，原因很简单，它提供的能力能帮助类库的设计 者们定义新的操作，增强接口的能力，类库的用户们（即那些实现该接口的程序员们）不需要花 费额外的精力重新实现该方法。因此，默认方法与库的用户也有关系，它们屏蔽了将来的变化对 用户的影响。第9章针对这一问题进行了更加深入的探讨。</p>
<p>自此，我们已经完成了对Java 8中新概念的总结。现在我们会转向更为棘手的主题，那就是 Java 8之后的版本中可能会有哪些新的改进以及新的特性出现。</p>

        <h1 id="java的未来"   >
          <a href="#java的未来" class="heading-link"><i class="fas fa-link"></i></a>Java的未来</h1>
      
<p>让我们看看关于Java未来的一些讨论。关于这一主题的大多数内容都会在JDK改进提议（JDK Enhancement Proposal）中进行讨论，它的网址是http://openjdk.java.net/jeps/0。我们在这里想要讨 论的主要是一些看起来很合理、实现起来却颇有难度的部分，以及一些由于和现存特性的协作有 问题而无法引入到Java中的部分。</p>

        <h2 id="集合"   >
          <a href="#集合" class="heading-link"><i class="fas fa-link"></i></a>集合</h2>
      
<p>Java的发展是一个循序渐进的过程，它从来就不是一蹴而就的。Java中融入了大量伟大的思 想，比如：数组取代了集合，之后的Stream又进一步增强了集合的功能。当然，乌龙的情况也偶 有发生，有的特性其优势变得更加明显（比如集合之于数组），但我们在做替代时却忽略了被替 代特性的一些优点。一个比较典型的例子是容器的初始化。比如，Java中数组可以通过下面这种 形式，在声明数组的同时进行初始化：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double [] a = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">5.9</span>&#125;;</span><br></pre></td></tr></table></div></figure>
<p>它是以下这种语法的简略形式：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double [] a = <span class="keyword">new</span> Double[]&#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">5.9</span>&#125;;</span><br></pre></td></tr></table></div></figure>
<p>为处理诸如由数组表示的顺序数据结构，集合（通过Collection接口）提供了一种更优秀 也更一致的解决方案。 不过它们的初始化被忽略了。 让我们回想一下你是如何初始化一个 HashMap的。你只能通过下面这样的代码完成初始化工作：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">map.put(<span class="string">"raoul"</span>, <span class="number">23</span>); </span><br><span class="line">map.put(<span class="string">"mario"</span>, <span class="number">40</span>); </span><br><span class="line">map.put(<span class="string">"alan"</span>, <span class="number">53</span>);</span><br></pre></td></tr></table></div></figure>
<p>你可能更愿意通过下面的方式达到这一目标：</p>
<figure class="highlight scala"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt; map = #&#123;<span class="string">"Raoul"</span> -&gt; <span class="number">23</span>, <span class="string">"Mario"</span> -&gt; <span class="number">40</span>, <span class="string">"Alan"</span> -&gt; <span class="number">53</span>&#125;;</span><br></pre></td></tr></table></div></figure>
<p>这里的<code>#{...}</code>是一种集合常量，它们代表了集合中的一系列值组成的列表。这似乎是一个 毫无争议的特性，不过它当前在Java中还不支持。</p>

        <h2 id="类型系统的改进"   >
          <a href="#类型系统的改进" class="heading-link"><i class="fas fa-link"></i></a>类型系统的改进</h2>
      
<p>我 们 会 讨 论 对 Java 当 前 类 型 系 统 的 两 种 潜 在 可 能 的 改 进 ， 分 别 是 声 明 位 置 变 量 （declaration-site variance）和本地变量类型推断（local variable type inference）。</p>

        <h3 id="声明位置变量"   >
          <a href="#声明位置变量" class="heading-link"><i class="fas fa-link"></i></a>声明位置变量</h3>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>Java加入了对通配符的支持，来更灵活地支持泛型的子类型（subtyping）</span>, 或者我们可以更通俗地称之为“用户定义变量”（use-site variance）。这也是下面这段代码合法的原因：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; numbers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></div></figure>
<p>不过下面的这段赋值（省略了? extends）会产生一个编译错误：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; numbers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 类型不兼容</span></span><br></pre></td></tr></table></div></figure>
<p>很多编程语言（比如C#和Scala）都支持一种比较独特的变量机制，名为声明位置变量。它 们允许程序员们在定义泛型时指定变量。对于天生就为变量的类而言，这一特性尤其有用。比如， Iterator就是一个天生的协变量，而Comparator则是一个天生的逆变量。使用它们时你无需 考虑到底是应该使用<code>? extends</code>，还是使用<code>? super</code>。这也是说在Java中添加声明位置变量极其有用的原因，因为这些规范会在声明类时就出现。这样一来，程序员的认知负荷就会减少。注意， 截至本书写作时（2014年6月），已经有一个提议处于研究过程中，希望能在Java 9中引入声明位置变量 。</p>

        <h3 id="更多的类型推断"   >
          <a href="#更多的类型推断" class="heading-link"><i class="fas fa-link"></i></a>更多的类型推断</h3>
      
<p>最初在Java中，无论何时我们使用一个变量或方法，都需要同时给出它的类型。例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">convertUSDToGBP</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123; ExchangeRate e = ...; &#125;</span><br></pre></td></tr></table></div></figure>
<p>它包含了三种类型；这段代码给出了函数convertUSDToGBP的结果类型，它的参数money的类型，以及方法使用的本地变量e的类型。随着时间的推移，这种限制被逐渐放开了。首先，你可 以在一个表达式中忽略泛型参数的类型，通过上下文决定其类型。比如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></div></figure>
<p>这段代码在Java 7之后可以缩略为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></div></figure>
<p>其次，利用同样的思想，你可以将由上下文决定的类型交由一个表达式决定，即由Lambda 表达式来决定，比如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Boolean&gt; p = (Integer x) -&gt; booleanExpression;</span><br></pre></td></tr></table></div></figure>
<p>省略类型后，这段代码可以精简为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Boolean&gt; p = x -&gt; booleanExpression;</span><br></pre></td></tr></table></div></figure>
<p>这两种情况都是由编译器对省略的类型进行推断的。 如果一种类型仅包含单一的标识符，类型推断能带来一系列的好处，其中比较主要的一点是， 用一种类型替换另一种可以减少编辑工作量。不过，随着类型数量的增加，出现了由更加泛型的类型参数化的泛型，这时类型推断就带来了新的价值，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>它能帮助我们改善程序的可读性</span>。</p>
<blockquote>
<p>当然，以一种直观的方式进行类型推断也是非常重要的。类型推断最适合的情况是只存在一种可能性，或者一种 比较容易文档化的方式，借此重建用户省略的类型。如果系统推断出的类型与用户最初设想的类型并不一致，就 会带来很多问题；所以良好的类型推断设计在面临两种不可比较的类型时，都会给出一个默认的类型，利用默认 类型来避免出现随机选择错误的类型。</p>
</blockquote>
<p>Scala和C#中都允许使用关键词var替换本地变量的初始化声明，编译器会依据右边的变量填 充恰当的类型。比如，我们之前展示过的使用Java语法的myMap声明可以像下面这样改写：</p>
<figure class="highlight scala"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;();</span><br></pre></td></tr></table></div></figure>
<p>这种思想被称为本地变量类型推断，你可能期待Java中也提供类似的特性，因为它能消除冗余的类型，减少杂乱的代码。 然而，它也可能受到一些质疑，比如，类Car继承类Vehicle后，你进行了下面这样的声明：</p>
<figure class="highlight scala"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="type">Vehicle</span>();</span><br></pre></td></tr></table></div></figure>
<p>那么，你到底期望x的类型为Car还是Vehicle呢？这个例子中，一个简单的解释就能解决问题， 即<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>缺失的类型就是初始化器对象的类型（这里为Vehicle），由此我们可以得出一个结论，没有 初始化器时，不要使用var声明对象。</span></p>

        <h2 id="模式匹配"   >
          <a href="#模式匹配" class="heading-link"><i class="fas fa-link"></i></a>模式匹配</h2>
      
<p>我们曾经在第14章中讨论过， 函数式语言通常都会提供某种形式的模式匹配——作为 switch的一种改良形式。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>通过这种模式匹配，你可以查询“这个值是某个类的实例吗”，或者你 也可以选择递归地查询某个字段是否包含了某些值。</span></p>
<p>我们有必要提醒你，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>即使是传统的面向对象设计也已经不推荐使用switch了，现在大家更推荐的方式是采用一些设计模式（访问者、策略等）</span>，比如访问者模式，使用访问者模式时，程序利用dispatch方 法，依据数据类型来选择相应的控制流，不再使用传统的switch方式。这并非另一种编程语言 中的事——函数式编程语言中使用基于数据类型的模式匹配通常也是设计程序最便捷的方式。</p>
<p>将类Scala的模式匹配全盘地移植到Java中似乎是个巨大的工程，但是基于switch语法最近 的泛化（switch现在已经不再局限于只允许对String进行操作），你可以想象更加现代的语法 扩展会有哪些。现在，凭借instanceof，你可以通过switch直接对对象进行操作。这里，我们 会对14.4节中的示例进行重构，假设有这样一个类Expr，它有两个子类，分别是BinOp和Number：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (someExpr) &#123;</span><br><span class="line">    <span class="keyword">case</span> (op <span class="keyword">instanceof</span> BinOp):</span><br><span class="line">        doSomething(op.opname, op.left, op.right);</span><br><span class="line">    <span class="keyword">case</span> (n <span class="keyword">instanceof</span> Number):</span><br><span class="line">        dealWithLeafNode(n.val);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        defaultAction(someExpr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这里有几点需要特别注意。我们在<code>case (op instanceof BinOp):</code>这段代码中借用了模 式匹配的思想，op是一个新的局部变量（类型为BinOp），它和SomeExpr都绑定到了同一个值； 类似地，在Number的case判断中，n被转化为了Number类型的变量。而默认情况不需要进行任 何变量绑定。和采用串接的if-then-else加子类型转换比起来，这种实现方式避免了大量的模 板代码。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>习惯了传统面向对象方式的设计者很可能会说如果采用访问者模式在子类型中实现这种 “数据类型”式的分派，表达的效果会更好，不过从函数式编程的角度看，后者会导致相关代码散落于多个类的定义中，也不太理想。</span>这是一种典型的设计二分法（design dichotomy）问题，经常会在工作粉间挑起以“表达问题”（expression problem）为幌子的口舌之争。</p>
<blockquote>
<p>设计二分法：内容、形式</p>
</blockquote>

        <h2 id="更加丰富的泛型形式"   >
          <a href="#更加丰富的泛型形式" class="heading-link"><i class="fas fa-link"></i></a>更加丰富的泛型形式</h2>
      
<p>本节会讨论Java泛型的两个局限性，并探讨可能的解决方案。</p>

        <h3 id="具化泛型"   >
          <a href="#具化泛型" class="heading-link"><i class="fas fa-link"></i></a>具化泛型</h3>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>Java 5中初次引入泛型时，需要它们尽量保持与现存JVM的后向兼容性。</span>为了达到这一目的， <code>ArrayList&lt;String&gt;</code>和 <code>ArrayList&lt;Integer&gt;</code> 的运行时表示是相同的。 这被称作<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>泛型多态 （generic polymorphism）的消除模式（erasure model）</span>。这一选择伴随着一定程度的运行时消耗， 不过对于程序员而言，这无关痛痒，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>影响最大的是传给泛型的参数只能为对象类型</span>。如果Java支 持<code>ArrayList&lt;int&gt;</code>这种类型的泛型，那么你就可以在堆上分配由简单数据值构成的ArrayList 对象，比如42，不过这样一来ArrayList容器就无法了解它所容纳的到底是一个对象类型的值， 比如一个String，还是一个简单的int值，比如42。</p>
<p>某种程度上看，这并没有什么危害——如果你可以从<code>ArrayList&lt;int&gt;</code>中得到简单值42，或 者从<code>ArrayList&lt;String&gt;</code> 中得到 String 对象abc，为什么还要担忧 ArrayList 容器无法辨识 呢？非常不幸，答案是<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>垃圾收集</span>，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>因为一旦缺失了ArrayList中内容的运行时信息，JVM就无法判断ArrayList中的元素13到底是一个Integer的引用（可以被垃圾收集器标记为“in use”并 进行跟踪），还是int类型的简单数据（几乎可以说是无法跟踪的）。</span></p>
<p>C#语言中，<code>ArrayList&lt;String&gt;</code>、<code>ArrayList&lt;Integer&gt;</code>以及<code>ArrayList&lt;int&gt;</code>的运行时表示在原则上就是不同的。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>即使它们的值是相同的，也伴随着足够的运行时类型信息，这些信息可以帮助垃圾收集器判断一个字段值到底是引用，还是简单数据。这被称为泛型多态的具化模式， 或具化泛型。</span><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>“具化”这个词意味着“将某些默认隐式的东西变为显式的”。</span></p>
<p>很明显， 具化泛型是众望所归的， 它们能将简单数据类型及其对应的对象类型更好地融 合——下一节中，你会看到这之前的一些问题。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>实现具化泛型的主要难点在于，Java需要保持后向兼容性， 并且这种兼容需要同时覆盖JVM， 以及使用了反射且希望进行泛型清除的遗留代码。</span></p>

        <h3 id="泛型中特别为函数类型增加的语法灵活性"   >
          <a href="#泛型中特别为函数类型增加的语法灵活性" class="heading-link"><i class="fas fa-link"></i></a>泛型中特别为函数类型增加的语法灵活性</h3>
      
<p>自从被Java 5引入，泛型就证明了其独特的价值。它们还特别适用于表示Java 8中的Lambda 类型以及各种方法引用。通过下面这种方式你可以表示使用单一参数的函数：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; square = x -&gt; x * x;</span><br></pre></td></tr></table></div></figure>
<p>如果你有一个使用两个参数的函数，可以采用类型<code>BiFunction&lt;T, U, R&gt;</code>，这里的T表示 第一个参数的类型， U 表示第二个参数的类型， 而 R 是计算的结果。 不过， Java 8中并未提供 TriFunction这样的函数，除非你自己声明了一个！</p>
<p>同理，你不能用<code>Function&lt;T, R&gt;</code>引用表示某个不接受任何参数，返回值为R类型的函数； 只能通过<code>Supplier&lt;R&gt;</code>达到这一目的。</p>
<p>从本质上来说，Java 8的Lambda极大地拓展了我们的编程能力，但可惜的是，它的类型系统并未跟上代码灵活度提升的脚步。在很多的函数式编程语言中，你可以用<code>(Integer, Double) =&gt; String</code>这样的类型实现Java 8中<code>BiFunction&lt;Integer, Double, String&gt;</code>调用得到同样 的效果；类似地，可以用<code>Integer =&gt; String</code>表示<code>Function&lt;Integer, String&gt;</code>，甚至可以 用<code>() =&gt; String</code>表示<code>Supplier&lt;String&gt;</code>。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>你可以将=&gt;符号看作Function、BiFunction、 Supplier，以及其他相似函数的中缀表达式版本。</span>我们只需要对现有Java语言的类型格式稍作 扩展就能提供Scala语言那样更具可读性的类型，关于Java和Scala的比较我们已经在第15章中详细 讨论过了。</p>

        <h3 id="原型特化和泛型"   >
          <a href="#原型特化和泛型" class="heading-link"><i class="fas fa-link"></i></a>原型特化和泛型</h3>
      
<p>在Java语言中，所有的简单数据类型，比如int，都有对应的对象类型（以刚才的例子而言， 它是java.lang.Integer）；通常我们把它们称为不装箱类型和装箱类型。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>虽然这种区分有助于提升运行时的效率，但是这种方式定义的类型也可能带来一些困扰。</span>比如，有人可能会问为什 么Java 8中我们需要编写<code>Predicate&lt;Apple&gt;</code>，而不是直接采用<code>Function&lt;Apple, Boolean&gt;</code>的方式？事实上，<code>Predicate&lt;Apple&gt;</code>类型的对象在执行test方法调用时，其返回值依旧是简 单类型boolean。</p>
<p>与此相反，和所有泛型一样，Function只能使用对象类型的参数。以<code>Function&lt;Apple, Boolean&gt;</code> 为例， 它使用的是对象类型 Boolean ， 而不是简单数据类型 boolean 。 <span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>所以使用 <code>Predicate&lt;Apple&gt;</code>更加高效，因为它无需将boolean装箱为Boolean。</span></p>
<p>因为存在这样的问题， 导 致 类 库 的 设 计 者 在 Java 时 创 建 了 多 个 类 似 的 接 口 ， 比 如 LongToIntFunction 和 BooleanSupplier，而这又进一步增加了大家理解的负担。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>另一个例子和void之间的区别有关， void只能修饰不带任何值的方法，而Void对象实际包含了一个值，它有且仅有一个null值</span>—— 这是一个经常在论坛上讨论的问题。对于Function的特殊情况，比如<code>Supplier&lt;T&gt;</code>，你可以用 前面建议的新操作符将其改写为<code>() =&gt; T</code>，这进一步佐证了由于简单数据类型（primitive type） 与对象类型（object type）的差异所导致的分歧。我们在之前的内容中已经介绍了怎样通过具化 泛型解决这其中的很多问题。</p>

        <h2 id="对不变性的更深层支持"   >
          <a href="#对不变性的更深层支持" class="heading-link"><i class="fas fa-link"></i></a>对不变性的更深层支持</h2>
      
<p>Java 8只支持三种类型的值，分别为：</p>
<ul>
<li>简单类型值</li>
<li>指向对象的引用</li>
<li>指向函数的引用</li>
</ul>
<p>听我们说起这些，有些专业的读者可能会感到失望。我们在某种程度上会坚持自己的观点， 介绍说“现在方法可以使用这些值作为参数，并返回相应的结果了”。不过，我们也承认这其中 的确还存在着一定的问题，比如，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>当你返回一个指向可变数组的引用时，它多大程度上应该是一 个（算术）值？很明显，字符串或者不可变数组都是值，不过对于可变对象或者数组而言，情况 远非那么泾渭分明——你的方法可能返回一个元素以升序排列的数组，不过另一些代码可能在之 后对其中的某些元素进行修改。</span></p>
<p>如果我们想在Java中真正实现函数式编程，那么语言层面的支持就必不可少了，比如“不可 变值”。正如我们在第13章中所了解的那样，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>关键字final并未在真正意义上是要达到这一目标， 它仅仅避免了对它所修饰字段的更新。</span>我们看看下面这个例子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"><span class="keyword">final</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></div></figure>
<p>前者禁止了直接的赋值操作<code>arr = ...</code>，不过它并未阻止以<code>arr[1]=2</code>这样的方式对数组进 行修改；而后者禁止了对列表的赋值操作，但并未禁止以其他方法修改列表中的元素！<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>关键字 final对于简单数据类型的值操作效果很好，不过对于对象引用，它通常只是一种错误的安全感。</span></p>
<p>那么我们该如何解决这一问题呢？由于函数式编程对不能修改现存数据结构有非常严格的 要求，所以它提供了一个更强大的关键字，比如transitively_final，该关键字用于修饰引 用类型的字段，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>确保无论是直接对该字段本身的修改，还是对通过该字段能直接或间接访问到的对象的修改都不会发生。</span></p>
<p>这些类型体现了关于值的一个理念：<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>变量值是不可修改的，只有变量（它们存储着具体的值） 可以被修改，修改之后变量中包含了其他一些不可变值。</span>正如我们在本节开头所提及的，Java的 作者，包括我们，时不时地都喜欢针对Java中值与可变数组的转化展开讨论。接下来的一节，我 们会讨论一下值类型（value type），声明为值类型的变量只能包含不可变值，然而，除非使用了 final关键词进行修饰，否则变量的值还是能够进行更新。</p>

        <h2 id="值类型"   >
          <a href="#值类型" class="heading-link"><i class="fas fa-link"></i></a>值类型</h2>
      
<p>这一节，我们会讨论简单数据类型和对象类型之间的差异，并结合前文针对值类型的讨论， 希望能借此帮助你以函数式的方式进行编程，就像对象类型是面向对象编程不可缺失的一环那 样。我们讨论的很多问题都是相互交织的，所以，很难以区隔的方式解释某一个单独的问题。所 以，我们会从不同的角度定位这些问题。</p>

        <h3 id="为什么编译器不能对integer和int一视同仁"   >
          <a href="#为什么编译器不能对integer和int一视同仁" class="heading-link"><i class="fas fa-link"></i></a>为什么编译器不能对Integer和int一视同仁</h3>
      
<p>自从Java 1.1版本以来，Java语言逐渐具备了隐式地进行装箱和拆箱的能力，你可能会问现在 是否是一个恰当的时机， 让Java语言一视同仁地处理简单数据类型和对象数据类型， 比如将 Integer和int同等对待，依赖Java编译器将它们优化为JVM最适合的形式。</p>
<p>这个想法在原则上是非常美好的，不过让我们看看在Java中添加Complex类型后会引发哪些 问题，以及为什么装箱会导致这样的问题。用于建模复数的Complex包含了两个部分，分别是实 数（real）和虚数（imaginary），一种很直观的定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> re;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> im;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="title">add</span><span class="params">(Complex a, Complex b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(a.re + b.re, a.im + b.im);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>不过类型Complex的值为引用类型，对Complex的每个操作都需要进行对象分配——增加了 add中两次加法操作的开销。我们需要的是类似Complex的简单数据类型，我们也许可以称其为 complex。</p>
<p>这里的问题是我们想要一种“不装箱的对象”，可是无论Java还是JVM，对此都没有实质的 支持。至此，我们只能悲叹了，“噢，当然编译器可以对它进行优化”。坏消息是，这远比看起来 要复杂得多；虽然Java带有基于名为“逃逸分析”的编译器优化（这一工作自Java 1.1版本开始就 已经有了），它能在某些时候判断拆箱的结果是否正确，然而其能力依旧有一定的限制，它受制 于Java对对象类型的判断。以下面的这个难题为例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = d1;</span><br><span class="line">Double o1 = d1;</span><br><span class="line">Double o2 = d2;</span><br><span class="line">Double ox = o1;</span><br><span class="line">System.out.println(d1 == d2 ? <span class="string">"yes"</span> : <span class="string">"no"</span>);</span><br><span class="line">System.out.println(o1 == o2 ? <span class="string">"yes"</span> : <span class="string">"no"</span>);</span><br><span class="line">System.out.println(o1 == ox ? <span class="string">"yes"</span> : <span class="string">"no"</span>);</span><br></pre></td></tr></table></div></figure>
<p>最后这段代码输出的结果为“yes”“no”“yes”。专业的Java程序员可能会说“多愚蠢的代码， 每个人都知道最后这两行你应该使用equals而不是==”。不过，请允许我们继续用这个例子进行 说明。虽然所有这些简单变量和对象都保存了不可变值3.14，实际上也应该是没有差别的，但是 <span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>由于有对o1和o2的定义，程序会创建新的对象，而==操作符（利用特征比较）可以将这二者区 分开来。</span>请注意，对于简单变量，特征比较采用的是逐位比较（bitwise comparison），对于对象 类型它采用的是引用比较（reference equality）。因此，很多时候由于编译器需要遵守对象的语义， 我们随机创建的新的Double对象（Double对象继承自Object）也需要遵守该语义。你之前见 过这些讨论，无论是较早的时候关于值对象的讨论，还是第14章围绕更新持久化数据结构保证引 用透明性的方法讨论。</p>

        <h3 id="值对象无论简单类型还是对象类型都不能包打天下"   >
          <a href="#值对象无论简单类型还是对象类型都不能包打天下" class="heading-link"><i class="fas fa-link"></i></a>值对象——无论简单类型还是对象类型都不能包打天下</h3>
      
<p>关于这个问题，我们建议的解决方案是重新回顾一下Java的初心：(1) 任何事物，如果不是 简单数据类型，就是对象类型，所有的对象类型都继承自Object；(2) 所有的引用都是指向对象 的引用。</p>
<p>事情的发展是这样开始的。Java中有两种类型的值：<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>一类是对象类型，它们包含着可变的字 段</span>（除非使用了final关键字进行修饰），对这种类型值的特征，可以使用==进行比较；<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>还有一类是值类型，这种类型的变量是不能改变的，也不带任何的引用特征</span>（reference identity），简单 类型就属于这种更宽泛意义上的值类型。这样，我们就能创建用户自定义值的类型了（<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>这种类型 的变量推荐小写字符开头，突出它们与int和boolean这类简单类型的相似性</span>）。对于值类型， 默认情况下，硬件对int进行比较时会以一个字节接着一个字节逐次的方式进行，==会以同样的 方式一个元素接着一个元素地对两个变量进行比较。你可以将这看成对浮点比较的覆盖，不过这 里会进行一些更加复杂的操作。Complex是一个绝佳的例子用于介绍非简单类型的值；它们和C# 中的结构struct极其类似。</p>
<p>此外，值类型可以减少对存储的要求，因为它们并不包含引用特征。图16-1引用了容量为3 的一个数组，其中的元素0、1和2分别用淡灰、白色和深灰色标记。左边的图展示了一种比较典 型的存储需求，其中的Pair和Complex都是对象类型，而右边展示的是一种更优的布局，这里 的Pair和Complex都是值类型（注意，我们在这里特意使用了小写的pair和complex，目的就 是想强调它们与简单类型的相似性）。也请注意，值类型极有可能提供更好的性能，无论是数据访问（用单一的索引地址指令替换多层的指针转换），还是对硬件缓存的利用率（因为数据现在 采用的是连续存储）。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200818154932.png"  alt="" />
      </p>
<blockquote>
<p><strong>注意区分基本类型数组和引用类型数组在堆中的存储方式</strong></p>
<p>数组可以理解成一个对象，初始化时就会在堆中分配一段连续的空间，栈中保存该连续空间首地址引用</p>
<p>基本类型数组</p>
<p>连续的空间存放的是值，单层索引就能访问数据</p>
<p>引用类型数组</p>
<p>连续的空间存放的是引用，需要两层指针转换才能访问数据</p>
</blockquote>
<p>注意，由于值类型并不包含引用特征，编译器可以随意对它们进行装箱和拆箱。如果你将一 个complex变量作为参数从一个函数传递给另一个函数，编译器可以很自然地将它们拆分为两个 单独的double类型的参数。（由于JVM只提供了以64位寄存器传递值的方法返回指令，所以在 JVM中要实现不装箱，直接返回是比较复杂的。）不过，如果你传递一个很大的值作为参数（比 如说一个很大的不可变数组），那么编译器可以以透明的方式（透明于用户），对其进行装箱，将其转化为一个引用进程传递。类似的工作已经在C#中存在；下面引用了一段微软的介绍：</p>
<blockquote>
<p>结构看起来和类十分相似，但是二者之间存在重大差异，你应该了解它们之间的不 同。首先，类[这里指的是C#中的类]属于引用类型，而结构（struct）属于值类型。使用 结构，你可以创建对象<code>[比如sic]</code>，它的行为就像那些内置<code>[简单]</code>类型一样，享受同等的 待遇。</p>
</blockquote>
<p>截至本书写作时（2014年6月），Java也已经接受了一份采用值类型的具体建议。</p>

        <h3 id="装箱-泛型-值类型互相交织的问题"   >
          <a href="#装箱-泛型-值类型互相交织的问题" class="heading-link"><i class="fas fa-link"></i></a>装箱、泛型、值类型——互相交织的问题</h3>
      
<p><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:bold'>我们希望能够在Java中引入值类型，因为函数式编程处理的不可变对象并不含有特征。</span>我们 希望简单数据类型可以作为值类型的特例，但又不要有当前Java所携带的泛型的消除模式，因为 这意味着值类型不做装箱就不能使用泛型。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>由于对象的消除模式，简单类型（比如int）的对象 （装箱）版本（比如Integer）对集合和Java泛型依旧非常重要，不过它们继承自Object（并因 此引用相等），这被当成了一种缺点。</span>解决这些问题中的任何一个就意味着解决了所有的问题。</p>

        <h1 id="写在最后的话"   >
          <a href="#写在最后的话" class="heading-link"><i class="fas fa-link"></i></a>写在最后的话</h1>
      
<p>本书探索了Java 8新增加的一系列新特性；它们所代表的可能是自Java创建以来最大的一次 演进——<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>唯一可以与之相提并论的大的演进也是在10年之前，即Java 5中所引入的泛型。</span>这一章 里我们还了解了Java进一步发展所面临的压力。用一句话来总结，我们会说：</p>
<blockquote>
<p><strong>Java 8已经占据了一个非常好的位置，可以暂时歇口气，但这绝不是终点！</strong></p>
</blockquote>
<p>我们希望你能享受这一段Java 8的探索旅程，也希望本书能燃起你对了解函数式编程及Java 8 进一步发展的兴趣。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/16_%E7%BB%93%E8%AE%BA%E4%BB%A5%E5%8F%8AJava%E7%9A%84%E6%9C%AA%E6%9D%A5/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/16_%E7%BB%93%E8%AE%BA%E4%BB%A5%E5%8F%8AJava%E7%9A%84%E6%9C%AA%E6%9D%A5/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/java8/">java8</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/17_%E9%99%84%E5%BD%95A_%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9A%84%E6%9B%B4%E6%96%B0/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">附录A_其他语言特性的更新</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/15_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%B7%B7%E5%90%88_Java8%E5%92%8CScala%E7%9A%84%E6%AF%94%E8%BE%83/"><span class="paginator-prev__text">面向对象和函数式编程的混合_Java8和Scala的比较</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#回顾-java-8-的语言特性"><span class="toc-number">1.</span> <span class="toc-text">
          回顾 Java 8 的语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#行为参数化lambda-以及方法引用"><span class="toc-number">1.1.</span> <span class="toc-text">
          行为参数化（Lambda 以及方法引用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流"><span class="toc-number">1.2.</span> <span class="toc-text">
          流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completablefuture"><span class="toc-number">1.3.</span> <span class="toc-text">
          CompletableFuture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#optional"><span class="toc-number">1.4.</span> <span class="toc-text">
          Optional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认方法"><span class="toc-number">1.5.</span> <span class="toc-text">
          默认方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java的未来"><span class="toc-number">2.</span> <span class="toc-text">
          Java的未来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">2.1.</span> <span class="toc-text">
          集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型系统的改进"><span class="toc-number">2.2.</span> <span class="toc-text">
          类型系统的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#声明位置变量"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          声明位置变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更多的类型推断"><span class="toc-number">2.2.2.</span> <span class="toc-text">
          更多的类型推断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式匹配"><span class="toc-number">2.3.</span> <span class="toc-text">
          模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更加丰富的泛型形式"><span class="toc-number">2.4.</span> <span class="toc-text">
          更加丰富的泛型形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#具化泛型"><span class="toc-number">2.4.1.</span> <span class="toc-text">
          具化泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型中特别为函数类型增加的语法灵活性"><span class="toc-number">2.4.2.</span> <span class="toc-text">
          泛型中特别为函数类型增加的语法灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型特化和泛型"><span class="toc-number">2.4.3.</span> <span class="toc-text">
          原型特化和泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对不变性的更深层支持"><span class="toc-number">2.5.</span> <span class="toc-text">
          对不变性的更深层支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#值类型"><span class="toc-number">2.6.</span> <span class="toc-text">
          值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么编译器不能对integer和int一视同仁"><span class="toc-number">2.6.1.</span> <span class="toc-text">
          为什么编译器不能对Integer和int一视同仁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值对象无论简单类型还是对象类型都不能包打天下"><span class="toc-number">2.6.2.</span> <span class="toc-text">
          值对象——无论简单类型还是对象类型都不能包打天下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装箱-泛型-值类型互相交织的问题"><span class="toc-number">2.6.3.</span> <span class="toc-text">
          装箱、泛型、值类型——互相交织的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#写在最后的话"><span class="toc-number">3.</span> <span class="toc-text">
          写在最后的话</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">335</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>