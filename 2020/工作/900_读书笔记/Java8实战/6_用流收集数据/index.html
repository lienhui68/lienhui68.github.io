<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="本章内容  用Collectors类创建和使用收集器 将数据流归约为一个值 汇总：归约的特殊情况 数据分组和分区 开发自己的自定义收集器">
<meta property="og:type" content="article">
<meta property="og:title" content="用流收集数据">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/6_%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="本章内容  用Collectors类创建和使用收集器 将数据流归约为一个值 汇总：归约的特殊情况 数据分组和分区 开发自己的自定义收集器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810153856.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810160939.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810160958.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810161826.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810161944.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810165302.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810170323.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810171700.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810172013.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810181312.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810181437.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810181844.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810182110.png">
<meta property="article:published_time" content="2020-07-01T01:04:06.000Z">
<meta property="article:modified_time" content="2020-09-16T16:26:17.017Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="java8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200810153856.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>用流收集数据 | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/6_%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">用流收集数据</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-07-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">10.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">71分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p><strong>本章内容</strong></p>
<ul>
<li>用Collectors类创建和使用收集器</li>
<li>将数据流归约为一个值</li>
<li>汇总：归约的特殊情况</li>
<li>数据分组和分区</li>
<li>开发自己的自定义收集器</li>
</ul>
<a id="more"></a>
<p>我们在前一章中学到，流可以用类似于数据库的操作帮助你处理集合。你可以把Java 8的流 看作花哨又懒惰的数据集迭代器。它们支持两种类型的操作：中间操作（如filter或map）和 终端操作（如count、findFirst、forEach和reduce）。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>中间操作可以链接起来，将一个流转换为另一个流。这些操作不会消耗流，其目的是建立一个流水线。与此相反，终端操作会消耗流，以产生一个最终结果，例如返回流中的最大元素。</span>它们通常可以通过优化流水线来缩短 计算时间。</p>
<p>在本章中，你会发现collect是一个归约操作，就像reduce一样可以接 受各种做法作为参数， 将流中的元素累积成一个汇总结果。 具体的做法是通过定义新的 Collector接口来定义的，因此区分Collection、Collector和collect是很重要的。</p>
<hr />

        <h1 id="收集器简介"   >
          <a href="#收集器简介" class="heading-link"><i class="fas fa-link"></i></a>收集器简介</h1>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>结果——“做什么”，而不用操心执行的步骤——“如何做”。</span></p>
<p>要是做多级分组，指令式和函数式之间的区别就会更加明显：由于需要好多层嵌套循环和条 件，指令式代码很快就变得更难阅读、更难维护、更难修改。相比之下，函数式版本只要再加上 一个收集器就可以轻松地增强功能了。</p>

        <h2 id="收集器用作高级归约"   >
          <a href="#收集器用作高级归约" class="heading-link"><i class="fas fa-link"></i></a>收集器用作高级归约</h2>
      
<p>刚刚的结论又引出了优秀的函数式API设计的另一个好处：更易复合和重用。收集器非常有 用，因为用它可以简洁而灵活地定义collect用来生成结果集合的标准。更具体地说，对流调用 collect方法将对流中的元素触发一个归约操作（由Collector来参数化）。图6-1所示的归约操 作所做的工作和代码清单6-1中的指令式代码一样。它遍历流中的每个元素，并让Collector进行处理。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810153856.png"  alt="" />
      </p>
<p>reduce方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>Collector接口：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h2 id="预定义收集器"   >
          <a href="#预定义收集器" class="heading-link"><i class="fas fa-link"></i></a>预定义收集器</h2>
      
<p>在本章剩下的部分中，我们主要探讨预定义收集器的功能，也就是那些可以从Collectors 类提供的工厂方法（例如groupingBy）创建的收集器。它们主要提供了三大功能：</p>
<ul>
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li>元素分区</li>
</ul>

        <h1 id="归约和汇总"   >
          <a href="#归约和汇总" class="heading-link"><i class="fas fa-link"></i></a>归约和汇总</h1>
      
<p>在需要将流项目重组成集合时，一般会使用收集器（Stream方法collect 的参数）。再宽泛一点来说，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:bold'>但凡要把流中所有的项目合并成一个结果时就可以用。这个结果可以是任何类型，可以复杂如代表一棵树的多级映射(多级映射)，或是简单如一个整数。</span></p>
<p>我们先来举一个简单的例子，利用counting工厂方法返回的收集器，数一数菜单里有多少 种菜：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().collect(Collectors.counting());</span><br></pre></td></tr></table></div></figure>
<p>这还可以写得更为直接：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().count();</span><br></pre></td></tr></table></div></figure>
<p>counting收集器在和其他收集器联合使用的时候特别有用，后面会谈到这一点。</p>
<p>在本章后面的部分，我们假定你已导入了Collectors类的所有静态工厂方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br></pre></td></tr></table></div></figure>
<p>这样你就可以写counting()而用不着写Collectors.counting()之类的了。</p>

        <h2 id="查找流中的最大值和最小值"   >
          <a href="#查找流中的最大值和最小值" class="heading-link"><i class="fas fa-link"></i></a>查找流中的最大值和最小值</h2>
      
<p>假设你想要找出菜单中热量最高的菜。 你可以使用两个收集器， Collectors.maxBy 和 Collectors.minBy，来计算流中的最大或最小值。这两个收集器接收一个Comparator参数来 比较流中的元素。你可以创建一个Comparator来根据所含热量对菜肴进行比较，并把它传递给 Collectors.maxBy：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);</span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));</span><br></pre></td></tr></table></div></figure>

        <h2 id="汇总"   >
          <a href="#汇总" class="heading-link"><i class="fas fa-link"></i></a>汇总</h2>
      
<p>Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。它可接受一 个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的collect方 法后即执行我们需要的汇总操作。举个例子来说，你可以这样求出菜单列表的总热量：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</span><br></pre></td></tr></table></div></figure>
<p>Collectors.summingLong和Collectors.summingDouble方法的作用完全一样，可以用 于求和字段为long或double的情况。</p>
<p>但汇总不仅仅是求和；还有Collectors.averagingInt，连同对应的averagingLong和 averagingDouble可以计算数值的平均数：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));</span><br></pre></td></tr></table></div></figure>
<p>很多时候，你可能想要得到两个或更多这样的 结果，而且你希望只需一次操作就可以完成。在这种情况下，你可以使用summarizingInt工厂 方法返回的收集器。例如，通过一次summarizing操作你可以就数出菜单中元素的个数，并得 到菜肴热量总和、平均值、最大值和最小值：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));</span><br></pre></td></tr></table></div></figure>
<p>这个收集器会把所有这些信息收集到一个叫作IntSummaryStatistics的类里，它提供了 方便的取值（getter）方法来访问结果。打印menuStatisticobject会得到以下输出：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics&#123;count&#x3D;9, sum&#x3D;4300, min&#x3D;120, average&#x3D;477.777778, max&#x3D;800&#125;</span><br></pre></td></tr></table></div></figure>
<p>同样，相应的summarizingLong和summarizingDouble工厂方法有相关的LongSummary- Statistics 和 DoubleSummaryStatistics 类型， 适用于收集的属性是原始类型 long 或 double的情况。</p>

        <h2 id="连接字符串"   >
          <a href="#连接字符串" class="heading-link"><i class="fas fa-link"></i></a>连接字符串</h2>
      
<p>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符 串连接成一个字符串。这意味着你把菜单中所有菜肴的名称连接起来，如下所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().map(Dish::getName).collect(joining());</span><br></pre></td></tr></table></div></figure>
<p>请注意，joining在内部使用了StringBuilder来把生成的字符串逐个追加起来。此外还 要注意，如果Dish类有一个toString方法来返回菜肴的名称，那你无需用提取每一道菜名称的 函数来对原流做映射就能够得到相同的结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining());</span><br></pre></td></tr></table></div></figure>
<p>二者均可产生以下字符串：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">porkbeefchickenfrench friesriceseason fruitpizzaprawnssalmon</span><br></pre></td></tr></table></div></figure>
<p>但该字符串的可读性并不好。幸好，joining工厂方法有一个重载版本可以接受元素之间的 分界符，这样你就可以得到一个逗号分隔的菜肴名称列表：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().map(Dish::getName).collect(joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></div></figure>
<p>正如我们预期的那样，它会生成：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon</span><br></pre></td></tr></table></div></figure>

        <h2 id="广义的归约和汇总"   >
          <a href="#广义的归约和汇总" class="heading-link"><i class="fas fa-link"></i></a>广义的归约和汇总</h2>
      
<p>事实上，我们已经讨论的所有收集器，都是一个可以用reducing工厂方法定义的归约过程 的特殊情况而已。Collectors.reducing工厂方法是所有这些特殊情况的一般化。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可以说，先 前讨论的案例仅仅是为了方便程序员而已。（但是，请记得方便程序员和可读性是头等大事！）例 如，可以用reducing方法创建的收集器来计算你菜单的总热量，如下所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().collect(reducing( <span class="number">0</span>, Dish::getCalories, (i, j) -&gt; i + j));</span><br></pre></td></tr></table></div></figure>
<p>它需要三个参数。</p>
<ul>
<li>
<p>第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言0是一个合适的值。</p>
</li>
<li>
<p>第二个参数就是你在6.2.2节中使用的函数，将菜肴转换成一个表示其所含热量的int。</p>
</li>
<li>
<p>第三个参数是一个BinaryOperator，将两个项目累积成一个同类型的值。这里它就是对两个int求和。 同样，你可以使用下面这样单参数形式的reducing来找到热量最高的菜，如下所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(reducing( </span><br><span class="line">		(d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));</span><br></pre></td></tr></table></div></figure>
</li>
</ul>
<p>你可以把单参数reducing工厂方法创建的收集器看作三参数方法的特殊情况，它把流中的 第一个项目作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数。这 也意味着，要是把单参数reducing收集器传递给空流的collect方法，收集器就没有起点；正 如我们在6.2.1节中所解释的，它将因此而返回一个<code>Optional&lt;Dish&gt;</code>对象。</p>
<blockquote>
<p><strong>收集和归约</strong></p>
<p>归约定义</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>Stream接口的collect和reduce方法有何不同，因为两种方法通常会获得相同的结果。例如，你可以像下面这样使用reduce方法来实现toListCollector所做的工作：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).stream();</span><br><span class="line">        List&lt;Integer&gt; numbers = stream.reduce(</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;Integer&gt;(),</span><br><span class="line">                (List&lt;Integer&gt; l, Integer e) -&gt; &#123;</span><br><span class="line">                    l.add(e);</span><br><span class="line">                    <span class="keyword">return</span> l;</span><br><span class="line">                &#125;,</span><br><span class="line">                (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; &#123;</span><br><span class="line">                    l1.addAll(l2);</span><br><span class="line">                    <span class="keyword">return</span> l1;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></div></figure>
<p>这个解决方案有两个问题：一个语义问题和一个实际问题。</p>
<p>语义问题在于，reduce方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。与此相反，collect方法的设]计就是要改变容器，从而累积要输出的结果。这意味着，上面的代码片段是在滥用reduce方法，因为它在原地改变了作为累加器的List。</p>
<p>你在下一章中会更详细地看到，以错误的语义使用reduce方法还会造成一个实际问题：这个归约过程不能并行工作，因为由多个线程并发修改同一个数据结构可能会破坏List本身。在这种情况下，如果你想要线程安全，就需要每次分配一个新的List，而对象分配又会影响性能。这就是collect方法特别适合表达可变容器上的归约的原因，更关键的是它适合并行操作，本章后面会谈到这一点。</p>
</blockquote>
<ol>
<li>
<p><strong>收集框架的灵活性：以不同的方法执行同样的操作</strong></p>
<p>你还可以进一步简化前面使用 reducing 收集器的求和例子——引用 Integer 类的 sum 方 法，而不用去写一个表达同一操作的Lambda表达式。这会得到以下程序：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810160939.png"  alt="" />
      </p>
<p>从逻辑上说，归约操作的工作原理如图6-3所示：利用累积函数，把一个初始化为起始值的 累加器，和把转换函数应用到流中每个元素上得到的结果不断迭代合并起来。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810160958.png"  alt="" />
      </p>
<p>在现实中，我们在6.2节开始时提到的counting收集器也是类似地利用三参数reducing工厂 方法实现的。它把流中的每个元素都转换成一个值为1的Long型对象，然后再把它们相加：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt;</span><br><span class="line">    counting() &#123;</span><br><span class="line">        <span class="keyword">return</span> reducing(<span class="number">0L</span>, e -&gt; <span class="number">1L</span>, Long::sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p><strong>使用泛型?通配符</strong></p>
<p>在刚刚提到的代码片段中，你可能已经注意到了?通配符，它用作counting工厂方法返回的收集器签名中的第二个泛型类型。对这种记法你应该已经很熟悉了，特别是如果你经常使用Java的集合框架的话。在这里，它仅仅意味着收集器的累加器类型未知，换句话说，累加器本身可以是任何类型。我们在这里原封不动地写出了Collectors类中原始定义的方法签名，但在本章其余部分我们将避免使用任何通配符表示法，以使讨论尽可能简单。</p>
</blockquote>
<p>我们在第5章已经注意到，还有另一种方法不使用收集器也能执行相同操作——将菜肴流映 射为每一道菜的热量，然后用前一个版本中使用的方法引用来归约得到的流：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().map(Dish::getCalories).reduce(Integer::sum).get();</span><br></pre></td></tr></table></div></figure>
<p>最后，更简洁的方法是 把流映射到一个IntStream，然后调用sum方法，你也可以得到相同的结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().mapToInt(Dish::getCalories).sum();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><strong>根据情况选择最佳解决方案</strong></p>
<p>这再次说明了，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>函数式编程（特别是Java 8的Collections框架中加入的基于函数式风格原理设计的新API）通常提供了多种方法来执行同一个操作。</span>这个例子还说明，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>收集器在某种程度 上比Stream接口上直接提供的方法用起来更复杂，但好处在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。</span></p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>我们的建议是，尽可能为手头的问题探索不同的解决方案，但在通用的方案里面，始终选择最专门化的一个。无论是从可读性还是性能上看，这一般都是最好的决定。</span>例如，要计菜单的总热量，我们更倾向于最后一个解决方案（使用IntStream），因为它最简明，也很可能最易读。 同时，它也是性能最好的一个，因为IntStream可以让我们避免自动拆箱操作，也就是从Integer 到int的隐式转换，它在这里毫无用处。</p>
</li>
</ol>

        <h1 id="分组"   >
          <a href="#分组" class="heading-link"><i class="fas fa-link"></i></a>分组</h1>
      
<p>一个常见的数据库操作是根据一个或多个属性对集合中的项目进行分组。就像前面讲到按货 币对交易进行分组的例子一样，如果用指令式风格来实现的话，这个操作可能会很麻烦、啰嗦而 且容易出错。但是，如果用Java 8所推崇的函数式风格来重写的话，就很容易转化为一个非常容 易看懂的语句。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810161826.png"  alt="" />
      </p>
<p>我们把这个Function叫作分类函数，因为它用来把流中的元素分成不 同的组。如图6-4所示，分组操作的结果是一个Map，把分组函数返回的值作为映射的键，把流中 所有具有这个分类值的项目的列表作为对应的映射值。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810161944.png"  alt="" />
      </p>
<p>但是，分类函数不一定像方法引用那样可用，因为你想用以分类的条件可能比简单的属性访 问器要复杂。例如，你可能想把热量不到400卡路里的菜划分为“低热量”（diet），热量400到700 卡路里的菜划为“普通”（normal），高于700卡路里的划为“高热量”（fat）。由于Dish类的作者 没有把这个操作写成一个方法，你无法使用方法引用，但你可以把这个逻辑写成Lambda表达式：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> CaloricLevel &#123;DIET, NORMAL, FAT&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dish&gt; menu = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"pork"</span>, <span class="keyword">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"beef"</span>, <span class="keyword">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"chicken"</span>, <span class="keyword">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"french fries"</span>, <span class="keyword">true</span>, <span class="number">530</span>, Dish.Type.OTHER),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"rice"</span>, <span class="keyword">true</span>, <span class="number">350</span>, Dish.Type.OTHER),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"season fruit"</span>, <span class="keyword">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"pizza"</span>, <span class="keyword">true</span>, <span class="number">550</span>, Dish.Type.OTHER),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"prawns"</span>, <span class="keyword">false</span>, <span class="number">300</span>, Dish.Type.FISH),</span><br><span class="line">                <span class="keyword">new</span> Dish(<span class="string">"salmon"</span>, <span class="keyword">false</span>, <span class="number">450</span>, Dish.Type.FISH));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 你可能想把热量不到400卡路里的菜划分为“低热量”（diet），</span></span><br><span class="line"><span class="comment">         * 热量400到700 卡路里的菜划为“普通”（normal），</span></span><br><span class="line"><span class="comment">         * 高于700卡路里的划为“高热量”（fat）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream()</span><br><span class="line">                .collect(groupingBy(t -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.getCalories() &gt;= <span class="number">400</span> &amp;&amp; t.getCalories() &lt; <span class="number">700</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                &#125;));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> vegetarian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dish</span><span class="params">(String name, <span class="keyword">boolean</span> vegetarian, <span class="keyword">int</span> calories, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.vegetarian = vegetarian;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;MEAT, FISH, OTHER&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="多级分组"   >
          <a href="#多级分组" class="heading-link"><i class="fas fa-link"></i></a>多级分组</h2>
      
<p>如何对菜单中的菜肴按照类型和热量同时进行分组</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel = menu.stream()</span><br><span class="line">                .collect(groupingBy(Dish::getType,</span><br><span class="line">                        groupingBy(t -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (t.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.getCalories() &gt;= <span class="number">400</span> &amp;&amp; t.getCalories() &lt; <span class="number">700</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            &#125; <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;)));</span><br></pre></td></tr></table></div></figure>
<p>这里的外层Map的键就是第一级分类函数生成的值：“fish, meat, other”，而这个Map的值又是 一个Map，键是二级分类函数生成的值：“normal, diet, fat”。最后，第二级map的值是流中元素构 成的List，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>是分别应用第一级和第二级分类函数所得到的对应第一级和第二级键的值</span>：“salmon、 pizza…” <span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>这种多级分组操作可以扩展至任意层级，n级分组就会得到一个代表n级树形结构的n级 Map。</span></p>
<p>图6-5显示了为什么结构相当于n维表格，并强调了分组操作的分类目的。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810165302.png"  alt="" />
      </p>
<p>一般来说，把groupingBy看作“桶”比较容易明白。第一个groupingBy给每个键建立了 一个桶。然后再用下游的收集器去收集每个桶中的元素，以此得到n级分组。</p>

        <h2 id="按子组收集数据"   >
          <a href="#按子组收集数据" class="heading-link"><i class="fas fa-link"></i></a>按子组收集数据</h2>
      
<p>在上一节中，我们看到可以把第二个 groupingBy收集器传递给外层收集器来实现多级分 组。但进一步说，传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个 groupingBy 。 例如， 要数一数菜单中每类菜有多少个， 可以传递 counting 收集器作为 groupingBy收集器的第二个参数：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect( groupingBy(Dish::getType, counting()));</span><br></pre></td></tr></table></div></figure>
<p>还要注意，普通的单参数groupingBy(f)（其中f是分类函数）实际上是groupingBy(f, toList())的简便写法。</p>
<p>再举一个例子，你可以把前面用于查找菜单中热量最高的菜肴的收集器改一改，按照菜的类 型分类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; mostCaloricByType = menu.stream()</span><br><span class="line">                .collect(groupingBy(Dish::getType, maxBy(Comparator.comparing(Dish::getCalories))));</span><br></pre></td></tr></table></div></figure>
<p>这个分组的结果显然是一个map，以Dish的类型作为键，以包装了该类型中热量最高的Dish 的<code>Optional&lt;Dish&gt;</code>作为值：</p>
<blockquote>
<p>这个 Map 中的值是 Optional ，因为这是 maxBy 工厂方法生成的收集器的类型，但实际上， 如果菜单中没有某一类型的 Dish ，这个类型就不会对应一个 Optional. empty() 值， 而且根本不会出现在 Map 的键中。 groupingBy 收集器只有在应用分组条件后，第一次在 流中找到某个键对应的元素时才会把键加入分组 Map 中。这意味着 Optional 包装器在这 里不是很有用，因为它不会仅仅因为它是归约收集器的返回类型而表达一个最终可能不 存在却意外存在的值。</p>
</blockquote>
<p><strong>把收集器的结果转换为另一种类型</strong></p>
<p>因为分组操作的Map结果中的每个值上包装的Optional没什么用，所以你可能想要把它们 去掉。要做到这一点，或者更一般地来说，把收集器返回的结果转换为另一种类型，你可以使用 Collectors.collectingAndThen工厂方法返回的收集器，如下所示。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Dish&gt; mostCaloricByType = menu.stream()</span><br><span class="line">                .collect(groupingBy(Dish::getType,</span><br><span class="line">                        collectingAndThen(maxBy(Comparator.comparing(Dish::getCalories)), Optional::get)));</span><br></pre></td></tr></table></div></figure>
<p>这个工厂方法接受两个参数——要转换的收集器以及转换函数，并返回另一个收集器。这个 收集器相当于旧收集器的一个包装，collect操作的最后一步就是将返回值用转换函数做一个映 射。在这里，被包起来的收集器就是用maxBy建立的那个，而转换函数Optional::get则把返 回的Optional中的值提取出来。前面已经说过，这个操作放在这里是安全的，因为reducing 收集器永远都不会返回Optional.empty()。</p>
<p>把好几个收集器嵌套起来很常见，它们之间到底发生了什么可能不那么明显。图6-6可以直 观地展示它们是怎么工作的。从最外层开始逐层向里，注意以下几点。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810170323.png"  alt="" />
      </p>
<ul>
<li>
<p>收集器用虚线表示，因此groupingBy是最外层，根据菜肴的类型把菜单流分组，得到三 个子流。</p>
</li>
<li>
<p>groupingBy收集器包裹着collectingAndThen收集器，因此分组操作得到的每个子流 都用这第二个收集器做进一步归约。</p>
</li>
<li>
<p>collectingAndThen收集器又包裹着第三个收集器maxBy。</p>
</li>
<li>
<p>随后由归约收集器进行子流的归约操作，然后包含它的collectingAndThen收集器会对 其结果应用Optional:get转换函数。</p>
</li>
<li>
<p>对三个子流分别执行这一过程并转换而得到的三个值， 也就是各个类型中热量最高的 Dish，将成为groupingBy收集器返回的Map中与各个分类键（Dish的类型）相关联的值。</p>
</li>
</ul>
<p><strong>与groupingBy联合使用的其他收集器的例子</strong></p>
<p>一般来说，通过groupingBy工厂方法的第二个参数传递的收集器将会对分到同一组中的所 有流元素执行进一步归约操作。例如，你还重用求出所有菜肴热量总和的收集器，不过这次是对 每一组Dish求和：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Integer&gt; totalCaloriesByType =</span><br><span class="line">menu.stream().collect(groupingBy(Dish::getType, summingInt(Dish::getCalories)));</span><br></pre></td></tr></table></div></figure>
<p>然而常常和groupingBy联合使用的另一个收集器是mapping方法生成的。</p>
<p>这个方法接受两 个参数：一个函数对流中的元素做变换，另一个则将变换的结果对象收集起来。</p>
<p>其目的是在累加 之前对每个输入元素应用一个映射函数，这样就可以让接受特定类型元素的收集器适应不同类型的对象。</p>
<p>我们来看一个使用这个收集器的实际例子。比方说你想要知道，对于每种类型的Dish， 菜单中都有哪些CaloricLevel。我们可以把groupingBy和mapping收集器结合起来，如下所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream()</span><br><span class="line">                .collect(groupingBy(Dish::getType,</span><br><span class="line">                        mapping(t -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (t.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.getCalories() &gt;= <span class="number">400</span> &amp;&amp; t.getCalories() &lt; <span class="number">700</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            &#125; <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;, toSet())</span><br><span class="line">                ));</span><br></pre></td></tr></table></div></figure>
<p>请注意在上 一个示例中，对于返回的Set是什么类型并没有任何保证。但通过使用toCollection，你就可 以有更多的控制。例如，你可以给它传递一个构造函数引用来要求HashSet：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream()</span><br><span class="line">                .collect(groupingBy(Dish::getType,</span><br><span class="line">                        mapping(t -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (t.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.getCalories() &gt;= <span class="number">400</span> &amp;&amp; t.getCalories() &lt; <span class="number">700</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            &#125; <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;, toCollection(HashSet::<span class="keyword">new</span>))</span><br><span class="line">                ));</span><br></pre></td></tr></table></div></figure>

        <h1 id="分区"   >
          <a href="#分区" class="heading-link"><i class="fas fa-link"></i></a>分区</h1>
      
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810171700.png"  alt="" />
      </p>
<p>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函 数。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以 分为两组——true是一组，false是一组。</p>
<blockquote>
<p>请注意，用同样的分区谓词，对菜单List创建的流作筛选，然后把结果收集到另外一个List 中也可以获得相同的结果</p>
</blockquote>

        <h2 id="分区的优势"   >
          <a href="#分区的优势" class="heading-link"><i class="fas fa-link"></i></a>分区的优势</h2>
      
<p>分区的好处在于保留了分区函数返回true或false的两套流元素列表。在上一个例子中，要 得到非素食Dish的List，你可以使用两个筛选操作来访问partitionedMenu这个Map中false 键的值：一个利用谓词，一个利用该谓词的非。而且就像你在分组中看到的，partitioningBy 工厂方法有一个重载版本，可以像下面这样传递第二个收集器：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810172013.png"  alt="" />
      </p>

        <h2 id="将数字按质数和非质数分开"   >
          <a href="#将数字按质数和非质数分开" class="heading-link"><i class="fas fa-link"></i></a>将数字按质数和非质数分开</h2>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eh.eden.java8.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.partitioningBy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * todo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> David Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/08/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将前n个数分成质数和非质数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed()</span><br><span class="line">                .collect(partitioningBy(</span><br><span class="line">                        candidate -&gt; isPrime(candidate)</span><br><span class="line">                ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个数是否是是否是质数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt(candidate);</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrimeDemo primeDemo = <span class="keyword">new</span> PrimeDemo();</span><br><span class="line">        Map&lt;Boolean, List&lt;Integer&gt;&gt; map = primeDemo.partitionPrimes(<span class="number">20</span>);</span><br><span class="line">        map.forEach((k, v) -&gt; System.out.print(k + <span class="string">":"</span> + v + <span class="string">"\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>运行结果</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false:[4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20]</span><br><span class="line">true:[2, 3, 5, 7, 11, 13, 17, 19]</span><br></pre></td></tr></table></div></figure>

        <h1 id="collectors类的静态工厂方法"   >
          <a href="#collectors类的静态工厂方法" class="heading-link"><i class="fas fa-link"></i></a>Collectors类的静态工厂方法</h1>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123; <span class="comment">// 把流中所有项目收集到一个 List</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() &#123; <span class="comment">// 把流中所有项目收集到一个 Set，删除重复项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">  <span class="comment">// 把流中所有项目收集到给定的供应源创建的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; counting() &#123; <span class="comment">// 计算流中元素的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123;</span><br><span class="line">  <span class="comment">// 对流中项目的一个整数属性求和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123;</span><br><span class="line">  <span class="comment">// 计算流中项目 Integer 属性的平均值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123;</span><br><span class="line">  <span class="comment">// 收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123; <span class="comment">// 连接对流中每个项目调用 toString 方法所生成的字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">  <span class="comment">// 按照给定比较器选出的最大元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">  <span class="comment">// 按照给定比较器选出的最小元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op) &#123; <span class="comment">// 从一个作为累加器的初始值开始，利用 BinaryOperator 与流 中的元素逐个结合，从而将流归约为单个值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="title">collectingAndThen</span><span class="params">(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher)</span> </span>&#123; <span class="comment">// 包裹另一个收集器，对其结果应用转换函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                          Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">  <span class="comment">// 根据项目的一个属性的值对流中的项目作分组，并将属性值作 为结果 Map 的键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate,</span><br><span class="line">                                                    Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">  <span class="comment">// 根据对流中每个项目应用谓词的结果来对项目进行分区</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="收集器接口"   >
          <a href="#收集器接口" class="heading-link"><i class="fas fa-link"></i></a>收集器接口</h1>
      
<p>Collector接口包含了一系列方法，为实现具体的归约操作（即收集器）提供了范本。我们已经看过了Collector接口中实现的许多收集器，例如toList或groupingBy。这也意味着， 你可以为Collector接口提供自己的实现，从而自由地创建自定义归约操作。</p>
<p>要开始使用Collector接口，我们先看看本章开始时讲到的一个收集器——toList工厂方 法，它会把流中的所有元素收集成一个List。我们当时说在日常工作中经常会用到这个收集器， 而且它也是写起来比较直观的一个，至少理论上如此。通过仔细研究这个收集器是怎么实现的， 我们可以很好地了解Collector接口是怎么定义的，以及它的方法所返回的函数在内部是如何为 collect方法所用的。</p>
<p>首先让我们在下面的列表中看看Collector接口的定义，它列出了接口的签名以及声明的五 个方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>T是流中要收集的项目的泛型。</li>
<li>A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。</li>
<li>R是收集操作得到的对象（通常但并不一定是集合）的类型。</li>
</ul>
<p>例如，你可以实现一个<code>ToListCollector&lt;T&gt;</code>类，将<code>Stream&lt;T&gt;</code>中的所有元素收集到一个<code>List&lt;T&gt;</code>里，它的签名如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToListCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">List</span>&lt;<span class="title">T</span>&gt;, <span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br></pre></td></tr></table></div></figure>
<p>我们很快就会澄清，这里用于累积的对象也将是收集过程的最终结果。</p>

        <h2 id="理解collector接口声明的方法"   >
          <a href="#理解collector接口声明的方法" class="heading-link"><i class="fas fa-link"></i></a>理解Collector接口声明的方法</h2>
      
<p>现在我们可以一个个来分析Collector接口声明的五个方法了。通过分析，你会注意到，前 四个方法都会返回一个会被collect方法调用的函数，而第五个方法characteristics则提供 了一系列特征，也就是一个提示列表，告诉collect方法在执行归约操作的时候可以应用哪些优 化（比如并行化）。</p>
<ol>
<li>
<p><strong>建立新的结果容器：supplier方法</strong></p>
<p>supplier方法必须返回一个结果为空的Supplier，也就是一个无参数函数，在调用时它会 创建一个空的累加器实例，供数据收集过程使用。很明显，对于将累加器本身作为结果返回的收 集器，比如我们的ToListCollector，在对空流执行操作的时候，这个空的累加器也代表了收集过程的结果。在我们的ToListCollector中，supplier返回一个空的List，如下所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123; <span class="keyword">return</span> ArrayList::<span class="keyword">new</span>; &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><strong>将元素添加到结果容器：accumulator方法</strong></p>
<p>accumulator方法会返回执行归约操作的函数。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>当遍历到流中第n个元素时，这个函数执行 时会有两个参数：保存归约结果的累加器（已收集了流中的前 n1 个项目），还有第n个元素本身。 </span><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>该函数将返回void，因为累加器是原位更新，即函数的执行改变了它的内部状态以体现遍历的 元素的效果。</span>对于ToListCollector，这个函数仅仅会把当前项目添加至已经遍历过的项目的列表：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123; <span class="keyword">return</span> (list, item) -&gt; list.add(item); &#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123; <span class="keyword">return</span> List::add; &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><strong>对结果容器应用最终转换：finisher方法</strong></p>
<p>在遍历完流后，finisher方法必须返回在累积过程的最后要调用的一个函数，以便将累加 器对象转换为整个集合操作的最终结果。通常，就像ToListCollector的情况一样，累加器对 象恰好符合预期的最终结果，因此无需进行转换。所以finisher方法只需返回identity函数：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() &#123; <span class="keyword">return</span> Function.identity(); &#125;</span><br></pre></td></tr></table></div></figure>
<p>这三个方法已经足以对流进行顺序归约，至少从逻辑上看可以按图6-7进行。实践中的实现 细节可能还要复杂一点，一方面是因为流的延迟性质，可能在collect操作之前还需要完成其他 中间操作的流水线，另一方面则是理论上可能要进行并行归约。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810181312.png"  alt="" />
      </p>
</li>
<li>
<p><strong>合并两个结果容器：combiner方法</strong></p>
<p>四个方法中的最后一个——combiner方法会返回一个供归约操作使用的函数，它定义了对 流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。对于toList而言， 这个方法的实现非常简单，只要把从流的第二个部分收集到的项目列表加到遍历第一部分时得到 的列表后面就行了：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BinaryOperator&lt;List&lt;T&gt;&gt; combiner() &#123; <span class="keyword">return</span> </span><br><span class="line">		(list1, list2) -&gt;  &#123; list1.addAll(list2); <span class="keyword">return</span> list1; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>有了这第四个方法，就可以对流进行并行归约了。它会用到Java 7中引入的分支/合并框架和 Spliterator抽象，我们会在下一章中讲到。这个过程类似于图6-8所示，这里会详细介绍。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810181437.png"  alt="" />
      </p>
<ul>
<li>原始流会以递归方式拆分为子流，直到定义流是否需要进一步拆分的一个条件为非（如果分布式工作单位太小，并行计算往往比顺序计算要慢，而且要是生成的并行任务比处理器内核数多很多的话就毫无意义了）。</li>
<li>现在，所有的子流都可以并行处理，即对每个子流应用图6-7所示的顺序归约算法。</li>
<li>最后，使用收集器combiner方法返回的函数，将所有的部分结果两两合并。这时会把原始流每次拆分时得到的子流对应的结果合并起来。</li>
</ul>
</li>
<li>
<p><strong>characteristics方法</strong></p>
<p>characteristics会返回一个不可变的Characteristics集合，它定义 了收集器的行为——尤其是关于流是否可以并行归约， 以及可以使用哪些优化的提示。 Characteristics是一个包含三个项目的枚举。</p>
<ul>
<li>
<p><strong>UNORDERED</strong>——归约结果不受流中项目的遍历和累积顺序的影响。</p>
</li>
<li>
<p><strong>CONCURRENT</strong>——accumulator函数可以从多个线程同时调用，且该收集器可以并行归 约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约。</p>
</li>
<li>
<p><strong>IDENTITY_FINISH</strong>——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种 情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器A不加检 查地转换为结果R是安全的。</p>
</li>
</ul>
<p>我们迄今开发的 ToListCollector 是 IDENTITY_FINISH 的， 因为用来累积流中元素的List已经是我们要的最终结果，用不着进一步转换了，但它并不是UNORDERED，因为用在有序 流上的时候，我们还是希望顺序能够保留在得到的List中。最后，它是CONCURRENT的，但我们 刚才说过了，仅仅在背后的数据源无序时才会并行处理。</p>
</li>
</ol>

        <h2 id="全部融合到一起"   >
          <a href="#全部融合到一起" class="heading-link"><i class="fas fa-link"></i></a>全部融合到一起</h2>
      
<p>前一小节中谈到的五个方法足够我们开发自己的ToListCollector了。你可以把它们都融 合起来，如下面的代码清单所示。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810181844.png"  alt="" />
      </p>
<p>请注意，这个实现与Collectors.toList方法并不完全相同，但区别仅仅是一些小的优化。 这些优化的一个主要方面是Java API所提供的收集器在需要返回空列表时使用了Collections.emptyList()这个单例（singleton）。这意味着它可安全地替代原生Java，来收集菜单流中的所 有Dish的列表：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; dishes = menuStream.collect(<span class="keyword">new</span> ToListCollector&lt;Dish&gt;());</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>这个实现和标准的<code>List&lt;Dish&gt; dishes = menuStream.collect(toList());</code>构造之间的其他差异在于toList是一个工厂，而ToListCollector必须用new来实例化。</p>
</blockquote>

        <h3 id="进行自定义收集而不去实现collector"   >
          <a href="#进行自定义收集而不去实现collector" class="heading-link"><i class="fas fa-link"></i></a>进行自定义收集而不去实现Collector</h3>
      
<p>对于IDENTITY_FINISH的收集操作，还有一种方法可以得到同样的结果而无需从头实现新 的Collectors接口。Stream有一个重载的collect方法可以接受另外三个函数——supplier、 accumulator和combiner，其语义和Collector接口的相应方法返回的函数完全相同。所以比 如说，我们可以像下面这样把菜肴流中的项目收集到一个List中：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200810182110.png"  alt="" />
      </p>
<p>我们认为，这第二种形式虽然比前一个写法更为紧凑和简洁，却不那么易读。此外，以恰当 的类来实现自己的自定义收集器有助于重用并可避免代码重复。另外值得注意的是，这第二个 collect 方法不能传递任何 Characteristics ， 所以它永远都是一个 IDENTITY_FINISH 和 CONCURRENT但并非UNORDERED的收集器。</p>

        <h1 id="开发你自己的收集器以获得更好的性能"   >
          <a href="#开发你自己的收集器以获得更好的性能" class="heading-link"><i class="fas fa-link"></i></a>开发你自己的收集器以获得更好的性能</h1>
      

        <h2 id="实现"   >
          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a>实现</h2>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eh.eden.java8.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义收集器来对前n个数进行分组，分组条件是判断是否是质数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> David Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/08/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumbersCollector</span> <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>, <span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt;, <span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * supplier方法会返回一个在调用 时创建累加器的函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> HashMap&lt;Boolean, List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="keyword">true</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                put(<span class="keyword">false</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Integer&gt; accumulator() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 收集器中最重要的方法是accumulator，因 为它定义了如何收集流中元素的逻辑。</span></span><br><span class="line"><span class="comment">         * 这里它也是实现前面所讲的优化的关键。现在在任何一次迭代中，都可以访问收集过程的部分结果，也就是包含迄今找到的质数的累加器</span></span><br><span class="line"><span class="comment">         * acc.get(true)返回上一次迭代中收集到的质数</span></span><br><span class="line"><span class="comment">         * isPrime(acc.get(true), candidate) 判断当前数是否是质数</span></span><br><span class="line"><span class="comment">         * acc.get(isPrime(acc.get(true), candidate)).add(candidate); 添加对对应的List中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (acc, candidate) -&gt; acc.get(isPrime(acc.get(<span class="keyword">true</span>), candidate)).add(candidate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在并行收集时把两个部分累加器合并起来，这里，它只需要合并两个Map，</span></span><br><span class="line"><span class="comment">     * 即 将第二个Map中质数和非质数列表中的所有数字合并到第一个Map的对应列表中就行了：</span></span><br><span class="line"><span class="comment">     * 请注意，实际上这个收集器是不能并行使用的，因为该算法本身是顺序的。这意味着永远都 不会调用 combiner 方法，</span></span><br><span class="line"><span class="comment">     * 你可以把它的实现留空（更好的做法是抛出一个 Unsupported- OperationException异常）。</span></span><br><span class="line"><span class="comment">     * 为了让这个例子完整，还是决定实现它。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="keyword">return</span> (m1, m2) -&gt; &#123;</span><br><span class="line">            m1.get(<span class="keyword">true</span>).addAll(m2.get(<span class="keyword">true</span>));</span><br><span class="line">            m1.get(<span class="keyword">false</span>).addAll(m2.get(<span class="keyword">false</span>));</span><br><span class="line">            <span class="keyword">return</span> m1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="comment">// 恒等函数</span></span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	* 就characteristics方法而言，我们已经说过，它既不是CONCURRENT也不是UNORDERED， 但却是IDENTITY_FINISH的</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumSet.of(Characteristics.IDENTITY_FINISH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用质数作为除数 来判断一个数是否是质数 (非质数本身就不是质数无需判断)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> primes    在添加candidate之前的那个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(List&lt;Integer&gt; primes, <span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">        <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream()</span><br><span class="line">                .noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅仅用小于被测数平方根的质数来测试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;A&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">takeWhile</span><span class="params">(List&lt;A&gt; list, Predicate&lt;A&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (A a : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p.test(a)) &#123;</span><br><span class="line">                <span class="keyword">return</span> list.subList(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试质数收集器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        Map&lt;Boolean, List&lt;Integer&gt;&gt; res = IntStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                .boxed()</span><br><span class="line">                .collect(<span class="keyword">new</span> PrimeNumbersCollector());</span><br><span class="line">        res.forEach((k, v) -&gt; System.out.println(k + <span class="string">": "</span> + v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>运行结果</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false: [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20]</span><br><span class="line">true: [2, 3, 5, 7, 11, 13, 17, 19]</span><br></pre></td></tr></table></div></figure>

        <h2 id="改造"   >
          <a href="#改造" class="heading-link"><i class="fas fa-link"></i></a>改造</h2>
      
<p>因为finisher是恒等函数，所以我们把实现 PrimeNumbersCollector核心逻辑的三个函数传给collect方法的重载版本来获得同样的结果</p>
<p>collect:</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">                  BiConsumer&lt;R, R&gt; combiner);</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>注意这里的combiner是BiConsumer&lt;R, R&gt;变量，Collector接口里是<code>BinaryOperator&lt;A&gt; combiner()</code></p>
<p>因为这里是恒等函数，原位操作即可。</p>
</blockquote>
<p>改造后的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eh.eden.java8.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * todo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> David Li</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/08/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用质数作为除数 来判断一个数是否是质数 (非质数本身就不是质数无需判断)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> primes    在添加candidate之前的那个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(List&lt;Integer&gt; primes, <span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">        <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream()</span><br><span class="line">                .noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅仅用小于被测数平方根的质数来测试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;A&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">takeWhile</span><span class="params">(List&lt;A&gt; list, Predicate&lt;A&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (A a : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p.test(a)) &#123;</span><br><span class="line">                <span class="keyword">return</span> list.subList(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试质数收集器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        Map&lt;Boolean, List&lt;Integer&gt;&gt; res = IntStream.rangeClosed(<span class="number">2</span>, n)</span><br><span class="line">                .boxed()</span><br><span class="line">                .collect(</span><br><span class="line">                        () -&gt; <span class="keyword">new</span> HashMap&lt;Boolean, List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">                            &#123;</span><br><span class="line">                                put(<span class="keyword">true</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                                put(<span class="keyword">false</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        (acc, candidate) -&gt; acc.get(isPrime(acc.get(<span class="keyword">true</span>), candidate)).add(candidate),</span><br><span class="line">                        (m1, m2) -&gt; &#123;</span><br><span class="line">                            m1.get(<span class="keyword">true</span>).addAll(m2.get(<span class="keyword">true</span>));</span><br><span class="line">                            m1.get(<span class="keyword">false</span>).addAll(m2.get(<span class="keyword">false</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">        res.forEach((k, v) -&gt; System.out.println(k + <span class="string">": "</span> + v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="keyword">false</span>: [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">true</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></div></figure>
<p>这样就可以避免为实现Collector接口创建一个全新的类；得到的代码更紧凑，虽然 可能可读性会差一点，可重用性会差一点。</p>

        <h1 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h1>
      
<p>以下是你应从本章中学到的关键概念。</p>
<ul>
<li>collect是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式（称为收集器）。</li>
<li>预定义收集器包括将流元素归约和汇总到一个值，例如计算最小值、最大值或平均值。</li>
<li>预定义收集器可以用groupingBy对流中元素进行分组，或用partitioningBy进行分区。</li>
<li>收集器可以高效地复合起来，进行多级分组、分区和归约。</li>
<li>你可以实现Collector接口中定义的方法来开发你自己的收集器。</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/6_%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/6_%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/java8/">java8</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/7_%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">并行数据处理与性能</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/5_%E4%BD%BF%E7%94%A8%E6%B5%81/"><span class="paginator-prev__text">使用流</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#收集器简介"><span class="toc-number">1.</span> <span class="toc-text">
          收集器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#收集器用作高级归约"><span class="toc-number">1.1.</span> <span class="toc-text">
          收集器用作高级归约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预定义收集器"><span class="toc-number">1.2.</span> <span class="toc-text">
          预定义收集器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#归约和汇总"><span class="toc-number">2.</span> <span class="toc-text">
          归约和汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#查找流中的最大值和最小值"><span class="toc-number">2.1.</span> <span class="toc-text">
          查找流中的最大值和最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇总"><span class="toc-number">2.2.</span> <span class="toc-text">
          汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连接字符串"><span class="toc-number">2.3.</span> <span class="toc-text">
          连接字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#广义的归约和汇总"><span class="toc-number">2.4.</span> <span class="toc-text">
          广义的归约和汇总</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分组"><span class="toc-number">3.</span> <span class="toc-text">
          分组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多级分组"><span class="toc-number">3.1.</span> <span class="toc-text">
          多级分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按子组收集数据"><span class="toc-number">3.2.</span> <span class="toc-text">
          按子组收集数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分区"><span class="toc-number">4.</span> <span class="toc-text">
          分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分区的优势"><span class="toc-number">4.1.</span> <span class="toc-text">
          分区的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将数字按质数和非质数分开"><span class="toc-number">4.2.</span> <span class="toc-text">
          将数字按质数和非质数分开</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#collectors类的静态工厂方法"><span class="toc-number">5.</span> <span class="toc-text">
          Collectors类的静态工厂方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#收集器接口"><span class="toc-number">6.</span> <span class="toc-text">
          收集器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#理解collector接口声明的方法"><span class="toc-number">6.1.</span> <span class="toc-text">
          理解Collector接口声明的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全部融合到一起"><span class="toc-number">6.2.</span> <span class="toc-text">
          全部融合到一起</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进行自定义收集而不去实现collector"><span class="toc-number">6.2.1.</span> <span class="toc-text">
          进行自定义收集而不去实现Collector</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开发你自己的收集器以获得更好的性能"><span class="toc-number">7.</span> <span class="toc-text">
          开发你自己的收集器以获得更好的性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">7.1.</span> <span class="toc-text">
          实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改造"><span class="toc-number">7.2.</span> <span class="toc-text">
          改造</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">8.</span> <span class="toc-text">
          小结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">335</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>