<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="本章内容  Java怎么又变了 日新月异的计算应用背景：多核和处理大型数据集（大数据） 改进的压力：函数式比命令式更适应新的体系架构 Java 8的核心新特性：Lambda（匿名函数）、流、默认方法">
<meta property="og:type" content="article">
<meta property="og:title" content="为什么要关心Java8">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E5%BF%83Java8/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="本章内容  Java怎么又变了 日新月异的计算应用背景：多核和处理大型数据集（大数据） 改进的压力：函数式比命令式更适应新的体系架构 Java 8的核心新特性：Lambda（匿名函数）、流、默认方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200806164804.png">
<meta property="article:published_time" content="2020-07-01T01:04:01.000Z">
<meta property="article:modified_time" content="2020-09-16T16:26:17.028Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="java8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200806164804.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>为什么要关心Java8 | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E5%BF%83Java8/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">为什么要关心Java8</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-07-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">4.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">25分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p><strong>本章内容</strong></p>
<ul>
<li>Java怎么又变了</li>
<li>日新月异的计算应用背景：多核和处理大型数据集（大数据）</li>
<li>改进的压力：函数式比命令式更适应新的体系架构</li>
<li>Java 8的核心新特性：Lambda（匿名函数）、流、默认方法</li>
</ul>
<a id="more"></a>
<hr />
<p>在Java 8里面，你可以编写更为简洁的代码，这些代码读起来更接近问题的描述：</p>
<p><code>inventory.sort(comparing(Apple::getWeight));</code></p>
<hr />
<p>在Java 8之前，专家们可能会告诉你，必须利用线程才能使用多个内核。问题是，线程用起 来很难，也容易出现错误。从Java的演变路径来看，它一直致力于让并发编程更容易、出错更少。</p>
<p>Java 1.0里有线程和锁，甚至有一个内存模型——这是当时的最佳做法，但事实证明，不具备专 门知识的项目团队很难可靠地使用这些基本模型。Java 5添加了工业级的构建模块，如线程池和 并发集合。Java 7添加了分支/合并（fork/join）框架，使得并行变得更实用，但仍然很困难。而 Java 8对并行有了一个更简单的新思路，不过你仍要遵循一些规则，本书中会谈到。</p>
<hr />
<p>Java8中的一些想法</p>
<ul>
<li>
<p>Stream API</p>
</li>
<li>
<p>向方法传递代码的技巧</p>
</li>
<li>
<p>接口中的默认方法</p>
</li>
</ul>
<p>Java 8提供了一个新的API（称为“流”，Stream），它支持许多处理数据的并行操作，其思路 和在数据库查询语言中的思路类似——用更高级的方式表达想要的东西，而由“实现”（在这里 是Streams库）来选择最佳低级执行机制。这样就可以避免用synchronized编写代码，这一代码 不仅容易出错，而且在多核CPU上执行所需的成本也比你想象的要高。</p>
<blockquote>
<p><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;'>多核CPU的每个处理器内核都有独立的高速缓存。加锁需要这些高速缓存同步运行，然而这又需要在内核间进行 较慢的缓存一致性协议通信。</span></p>
</blockquote>
<p>从有点修正主义的角度来看，<span style='color:red;background:背景颜色;font-size:文字大小;'>在Java 8中加入Streams可以看作把另外两项扩充加入Java 8 的直接原因：把代码传递给方法的简洁方式（方法引用、Lambda）和接口中的默认方法</span>。</p>
<p>Java 8里面将代码传递给方法的功能（同时也能够返回代码并将其包含在数据结构中）还让 我们能够使用一整套新技巧，通常称为<span style='color:red;background:背景颜色;font-size:文字大小;'>函数式编程</span>。一言以蔽之，这种被函数式编程界称为函数的代码，可以被来回传递并加以组合，以产生强大的编程语汇。</p>

        <h1 id="java怎么还在变"   >
          <a href="#java怎么还在变" class="heading-link"><i class="fas fa-link"></i></a>Java怎么还在变</h1>
      

        <h2 id="java在编程语言生态系统中的位置"   >
          <a href="#java在编程语言生态系统中的位置" class="heading-link"><i class="fas fa-link"></i></a>Java在编程语言生态系统中的位置</h2>
      
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200806164804.png"  alt="" />
      </p>

        <h2 id="流处理"   >
          <a href="#流处理" class="heading-link"><i class="fas fa-link"></i></a>流处理</h2>
      
<p>第一个编程概念是流处理。介绍一下，流是一系列数据项，一次只生成一项。程序可以从输 入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。</p>

        <h2 id="用行为参数化把代码传递给方法"   >
          <a href="#用行为参数化把代码传递给方法" class="heading-link"><i class="fas fa-link"></i></a>用行为参数化把代码传递给方法</h2>
      

        <h2 id="并行与共享的可变数据"   >
          <a href="#并行与共享的可变数据" class="heading-link"><i class="fas fa-link"></i></a>并行与共享的可变数据</h2>
      
<p>你的行为必须能够同时对不同的输入安全地执行。一般情况下这就意味着，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;'>你写代码时不能访问共享的可变数据</span>。这些函数有时被称为“纯 函数”或“无副作用函数”或“无状态函数”，这一点我们会在第7章和第13章详细讨论。前面说 的并行只有在假定你的代码的多个副本可以独立工作时才能进行。但如果要写入的是一个共享变 量或对象，这就行不通了。</p>
<p>Java 8的流实现并行比Java现有的线程API更容易，因此，尽管可以使用synchronized来打 破“不能有共享的可变数据”这一规则，但这相当于是在和整个体系作对，因为它使所有围绕这一规则做出的优化都失去意义了。在多个处理器内核之间使用synchronized，其代价往往比你 预期的要大得多，因为同步迫使代码按照顺序执行，而这与并行处理的宗旨相悖。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>这两个要点（没有共享的可变数据，将方法和函数即代码传递给其他方法的能力）是我们平常所说的函数式编程范式的基石</span>，我们在第13章和第14章会详细讨论。</p>

        <h2 id="java需要演变"   >
          <a href="#java需要演变" class="heading-link"><i class="fas fa-link"></i></a>Java需要演变</h2>
      
<p><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;'>语言需要不断改进以跟进硬件的更新或满足程序员的期待</span>（如果你还不够信服，想想COBOL还一度是商业上最重要的语言之一呢）。</p>

        <h1 id="java中的函数"   >
          <a href="#java中的函数" class="heading-link"><i class="fas fa-link"></i></a>Java中的函数</h1>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>编程语言的整个目的就在于操作值</span>，要是按照历史 上编程语言的传统，这些值因此被称为一等值（或一等公民，这个术语是从20世纪60年代美国民 权运动中借用来的）。编程语言中的其他结构也许有助于我们表示值的结构，但在程序执行期间 不能传递，因而是二等公民。前面所说的值是Java中的一等公民，但其他很多Java概念（如方法 和类等）则是二等公民。用方法来定义类很不错，类还可以实例化来产生值，但方法和类本身都 不是值。这又有什么关系呢？还真有，人们发现，在运行时传递方法能将方法变成一等公民。这在编程中非常有用，因此Java 8的设计者把这个功能加入到了Java中。顺便说一下，你可能会想， 让类等其他二等公民也变成一等公民可能也是个好主意。有很多语言，如Smalltalk和JavaScript， 都探索过这条路。</p>

        <h2 id="方法和lambda作为一等公民"   >
          <a href="#方法和lambda作为一等公民" class="heading-link"><i class="fas fa-link"></i></a>方法和Lambda作为一等公民</h2>
      

        <h3 id="方法引用"   >
          <a href="#方法引用" class="heading-link"><i class="fas fa-link"></i></a>方法引用</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File[] hiddenFiles = <span class="keyword">new</span> File(<span class="string">"/Users/david"</span>).listFiles(File::isHidden);</span><br><span class="line">        Arrays.asList(hiddenFiles).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>语法： <code>对象::方法引用</code>  (即把这个方法作为值)</p>
<p>在Java 8里写下 File::isHidden的时候，你就创建了一个方法引用，你同样可以传递它。第3章会详细讨论这 一概念。只要方法中有代码（方法中的可执行部分），那么用方法引用就可以传递代码。</p>

        <h3 id="lambda匿名函数"   >
          <a href="#lambda匿名函数" class="heading-link"><i class="fas fa-link"></i></a>Lambda——匿名函数</h3>
      
<p>除了允许（命名）函数成为一等值外，Java 8还体现了更广义的将函数作为值的思想，包括 ① Lambda （或匿名函数）。比如，你现在可以写(int x) -&gt; x + 1，表示“调用时给定参数x， 就返回x + 1值的函数”。你可能会想这有什么必要呢？因为你可以在MyMathsUtils类里面定义 一个add1方法，然后写MyMathsUtils::add1嘛！确实是可以，但要是你没有方便的方法和类可用，新的Lambda语法更简洁。第3章会详细讨论Lambda。<span style='color:red;background:背景颜色;font-size:文字大小;'>我们说使用这些概念的程序为函数式编程风格，这句话的意思是“<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;'>编写把函数作为一等值来传递的程序</span>”</span>。</p>

        <h2 id="传递代码一个例子"   >
          <a href="#传递代码一个例子" class="heading-link"><i class="fas fa-link"></i></a>传递代码：一个例子</h2>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InventoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; apples = Lists.newArrayList(</span><br><span class="line">                <span class="keyword">new</span> Apple(<span class="number">10</span>, Color.RED),</span><br><span class="line">                <span class="keyword">new</span> Apple(<span class="number">18</span>, Color.RED),</span><br><span class="line">                <span class="keyword">new</span> Apple(<span class="number">10</span>, Color.GREEN)</span><br><span class="line">        );</span><br><span class="line">        List&lt;Apple&gt; rs = apples.parallelStream().filter(</span><br><span class="line">                apple -&gt; apple.getWeight() &gt; <span class="number">15</span></span><br><span class="line">                        &amp;&amp; apple.getColor() == Color.RED</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        rs.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    GREEN, RED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">int</span> weight, Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple&#123;"</span> +</span><br><span class="line">                <span class="string">"weight="</span> + weight +</span><br><span class="line">                <span class="string">", color="</span> + color +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="从传递方法到lambda"   >
          <a href="#从传递方法到lambda" class="heading-link"><i class="fas fa-link"></i></a>从传递方法到Lambda</h2>
      
<p>你甚至都不需要为只用一次的方法写定义；代码更干净、更清晰，因为你用不着去找自己到底传递了什么代码。但要是Lambda的长度多于几行（它的行为也不是一目了然）的话， 那你还是应该用方法引用来指向一个有描述性名称的方法，而不是使用匿名的Lambda。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;'>你应该以代码的清晰度为准绳</span>。</p>
<p>Java 8的设计师几乎可以就此打住了，要是没有多核CPU，可能他们真的就到此为止了。我 们迄今为止谈到的函数式编程竟然如此强大， 在后面你更会体会到这一点。 本来， Java加上 filter和几个相关的东西作为通用库方法就足以让人满意了，比如</p>
<p><code>static &lt;T&gt; Collection&lt;T&gt; filter(Collection&lt;T&gt; c, Predicate&lt;T&gt; p);</code></p>
<p>这样你甚至都不需要写filterApples了，因为比如先前的调用</p>
<p><code>filterApples(inventory, (Apple a) -&gt; a.getWeight() &gt; 150 );</code></p>
<p>就可以直接调用库方法filter：</p>
<p><code>filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150 );</code></p>
<p>但是， 为了更好地利用并行， Java的设计师没有这么做。 Java 8中有一整套新的类集合 API——Stream，它有一套函数式程序员熟悉的、类似于filter的操作，比如map、reduce，还 有我们接下来要讨论的在Collections和Streams之间做转换的方法。</p>

        <h1 id="流"   >
          <a href="#流" class="heading-link"><i class="fas fa-link"></i></a>流</h1>
      
<p>用集合的话，你得自己去做迭代的过程。你得用for-each循环一个个去迭代元素，然后再处理元素。我们把这种数据迭代的方法称为<strong>外部迭代</strong>。相反，有了Stream API，你根本用不着操心循环的事情。数据处 理完全是在库内部进行的。我们把这种思想叫作<strong>内部迭代</strong>。</p>

        <h2 id="多线程并非易事"   >
          <a href="#多线程并非易事" class="heading-link"><i class="fas fa-link"></i></a>多线程并非易事</h2>
      
<p>通过多线程代码来利用并行（使用先前Java版本中的Thread API）并非易事。你 得换一种思路：线程可能会同时访问并更新共享变量。因此，如果没有协调好 ，数据可能会被 意外改变。</p>
<blockquote>
<p>传统上是利用synchronized关键字，但是要是用错了地方，就可能出现很多难以察觉的错误。Java 8基于Stream的并行提倡很少使用synchronized的函数式编程风格，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:bold'>它关注数据分块而不是协调访问</span>。</p>
</blockquote>
<p>Java 8也用Stream API（java.util.stream）解决了这两个问题：<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>集合处理时的套路和晦涩</span>，以及<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>难以利用多核</span>。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>Collection主要是为了存储和访问数据，而Stream则主要用 于描述对数据的计算。这里的关键点在于，Stream允许并提倡并行处理一个Stream中的元素。</span></p>
<blockquote>
<p>Java中的并行与无共享可变状态</p>
<p>大家都说Java里面并行很难，而且和synchronized相关的玩意儿都容易出问题。那Java 8里面有什么“灵丹妙药”呢？事实上有两个。首先，库会负责分块，即把大的流分成几个小的流，以便并行处理。其次，流提供的这个几乎免费的并行，只有在传递给filter之类的库方法的方法不会互动（比方说有可变的共享对象）时才能工作。但是其实这个限制对于程序员来说挺自然的，举个例子，我们的Apple::isGreenApple就是这样。确实，虽然函数式编程中的函数的主要意思是“把函数作为一等值”，不过它也常常隐含着第二层意思，即“<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>执行时在元素之间无互动</span>”。</p>
</blockquote>

        <h1 id="默认方法"   >
          <a href="#默认方法" class="heading-link"><i class="fas fa-link"></i></a>默认方法</h1>
      
<p>Java 8中加入默认方法主要是为了支持库设计师，让他们能够写出更容易改进的接口。</p>
<p>接口如今可以包含实现类没有提供实现的方法签名 了！那谁来实现它呢？缺失的方法主体随接口提供了（因此就有了默认实现），而不是由实现类提供。</p>
<p>这就给接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。Java 8在接口声明 中使用新的default关键字来表示这一点。</p>
<p>eg:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果在好几个接口里有多个默认实现， 是否意味着Java中有了某种形式的多重继承？是的，在某种程度上是这样。我们在第9章中会谈 到，Java 8用一些限制来避免出现类似于C++中臭名昭著的菱形继承问题。</p>
<blockquote>
<p><strong>java 8中抽象类与接口的异同</strong></p>
<p><strong>相同点</strong></p>
<ol>
<li>都是抽象类型；</li>
<li>都可以有实现方法（以前接口不行）；</li>
<li>都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）</li>
</ol>
<p><strong>不同点</strong></p>
<ul>
<li>抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；</li>
<li>抽象类和接口所反映出的设计理念不同。其实抽象类表示的是&quot;is-a&quot;关系，接口表示的是&quot;like-a&quot;关系；</li>
<li>接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly(不加修饰符) 型，其值可以在子类中重新定义，也可以重新赋值。</li>
</ul>
</blockquote>

        <h1 id="来自函数式编程的其他好思想"   >
          <a href="#来自函数式编程的其他好思想" class="heading-link"><i class="fas fa-link"></i></a>来自函数式编程的其他好思想</h1>
      

        <h2 id="optionalt"   >
          <a href="#optionalt" class="heading-link"><i class="fas fa-link"></i></a>Optional&lt;T&gt;</h2>
      
<p>常见的函数式语言，如SML、OCaml、Haskell，还提供了进一步的结构来帮助程序员。其中 之一就是通过使用更多的描述性数据类型来避免null。确实，计算机科学巨擘之一托尼·霍尔 （Tony Hoare）在2009年伦敦QCon上的一个演讲中说道：</p>
<p>我把它叫作我的“价值亿万美金的错误”。就是在1965年发明了空引用……我无法 抗拒放进一个空引用的诱惑，仅仅是因为它实现起来非常容易。</p>
<p>在Java 8里有一个Optional<T>类，如果你能一致地使用它的话，就可以帮助你避免出现 NullPointer异常。它是一个容器对象，可以包含，也可以不包含一个值。Optional<T>中有 方法来明确处理值不存在的情况，这样就可以避免NullPointer异常了。</p>

        <h2 id="结构模式匹配"   >
          <a href="#结构模式匹配" class="heading-link"><i class="fas fa-link"></i></a>(结构)模式匹配</h2>
      
<p>这在数学中也有使用，例如：<br />
f(0) = 1<br />
f(n) = n*f(n-1) otherwise</p>
<p>在Java中，你可以在这里写一个if-then-else语句或一个switch语句。其他语言表明，对 于更复杂的数据类型，模式匹配可以比if-then-else更简明地表达编程思想。</p>
<p>，Java 8对模式匹 配的支持并不完全，虽然我们会在第14章中介绍如何对其进行表达。与此同时，我们会用一个以 Scala语言（另一个使用JVM的类Java语言，启发了Java在一些方面的发展；请参阅第15章）表达 的例子加以描述。比方说，你要写一个程序对描述算术表达式的树做基本的简化。给定一个数据 类型Expr代表这样的表达式，在Scala里你可以写以下代码，把Expr分解给它的各个部分，然后 返回另一个Expr：</p>
<figure class="highlight scala"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyExpression</span></span>(expr: <span class="type">Expr</span>): <span class="type">Expr</span> = expr <span class="keyword">match</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">BinOp</span>(<span class="string">"+"</span>, e, <span class="type">Number</span>(<span class="number">0</span>)) =&gt; e </span><br><span class="line">	<span class="keyword">case</span> <span class="type">BinOp</span>(<span class="string">"*"</span>, e, <span class="type">Number</span>(<span class="number">1</span>)) =&gt; e </span><br><span class="line">	<span class="keyword">case</span> <span class="type">BinOp</span>(<span class="string">"/"</span>, e, <span class="type">Number</span>(<span class="number">1</span>)) =&gt; e </span><br><span class="line">	<span class="keyword">case</span> _ =&gt; expr </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这里，Scala的语法expr match就对应于Java中的switch (expr)。</p>
<blockquote>
<p>模式匹配这个术语有两个意思， 这里我们指的是数学和函数式编程上所用的， 即函数是分情况定义的， 而不是使用 if-then-else。它的另一个意思类似于“在给定目录中找到所有类似于IMG*.JPG形式的文件”，和所谓的正则 表达式有关。</p>
</blockquote>

        <h1 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h1>
      
<p>以下是你应从本章中学到的关键概念。</p>
<ul>
<li>请记住语言生态系统的思想，以及语言面临的“要么改变，要么衰亡”的压力。虽然Java 可能现在非常有活力，但你可以回忆一下其他曾经也有活力但未能及时改进的语言的命 运，如COBOL。</li>
<li>Java 8中新增的核心内容提供了令人激动的新概念和功能，方便我们编写既有效又简洁的程序。</li>
<li>现有的Java编程实践并不能很好地利用多核处理器。</li>
<li>函数是一等值；记得方法如何作为函数式值来传递，还有Lambda是怎样写的。</li>
<li>Java 8中Streams的概念使得Collections的许多方面得以推广，让代码更为易读，并允许并行处理流元素。</li>
<li>你可以在接口中使用默认方法，在实现类没有实现方法时提供方法内容。</li>
<li>其他来自函数式编程的有趣思想，包括处理null和使用模式匹配。</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E5%BF%83Java8/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E5%BF%83Java8/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/java8/">java8</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/900_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java8%E5%AE%9E%E6%88%98/2_%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">通过行为参数化传递代码</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/jvm/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"><span class="paginator-prev__text">垃圾回收器</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java怎么还在变"><span class="toc-number">1.</span> <span class="toc-text">
          Java怎么还在变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java在编程语言生态系统中的位置"><span class="toc-number">1.1.</span> <span class="toc-text">
          Java在编程语言生态系统中的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流处理"><span class="toc-number">1.2.</span> <span class="toc-text">
          流处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用行为参数化把代码传递给方法"><span class="toc-number">1.3.</span> <span class="toc-text">
          用行为参数化把代码传递给方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行与共享的可变数据"><span class="toc-number">1.4.</span> <span class="toc-text">
          并行与共享的可变数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java需要演变"><span class="toc-number">1.5.</span> <span class="toc-text">
          Java需要演变</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java中的函数"><span class="toc-number">2.</span> <span class="toc-text">
          Java中的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方法和lambda作为一等公民"><span class="toc-number">2.1.</span> <span class="toc-text">
          方法和Lambda作为一等公民</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法引用"><span class="toc-number">2.1.1.</span> <span class="toc-text">
          方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda匿名函数"><span class="toc-number">2.1.2.</span> <span class="toc-text">
          Lambda——匿名函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传递代码一个例子"><span class="toc-number">2.2.</span> <span class="toc-text">
          传递代码：一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从传递方法到lambda"><span class="toc-number">2.3.</span> <span class="toc-text">
          从传递方法到Lambda</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流"><span class="toc-number">3.</span> <span class="toc-text">
          流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程并非易事"><span class="toc-number">3.1.</span> <span class="toc-text">
          多线程并非易事</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认方法"><span class="toc-number">4.</span> <span class="toc-text">
          默认方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#来自函数式编程的其他好思想"><span class="toc-number">5.</span> <span class="toc-text">
          来自函数式编程的其他好思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#optionalt"><span class="toc-number">5.1.</span> <span class="toc-text">
          Optional&lt;T&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构模式匹配"><span class="toc-number">5.2.</span> <span class="toc-text">
          (结构)模式匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">6.</span> <span class="toc-text">
          小结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">325</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>