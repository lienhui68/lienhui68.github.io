<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="转载自：深入理解Java枚举类型(enum)                     理解枚举类型        枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。下面先来看看什么是枚举？如何定义枚举？">
<meta property="og:type" content="article">
<meta property="og:title" content="枚举">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="转载自：深入理解Java枚举类型(enum)                     理解枚举类型        枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。下面先来看看什么是枚举？如何定义枚举？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102225.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102301.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102317.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102400.png">
<meta property="article:published_time" content="2020-09-16T16:22:27.661Z">
<meta property="article:modified_time" content="2020-09-16T16:48:08.580Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102225.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>枚举 | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">枚举</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">12k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">89分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p>转载自：<span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/zhanqing/p/11076646.html"  target="_blank" rel="noopener">深入理解Java枚举类型(enum)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="理解枚举类型"   >
          <a href="#理解枚举类型" class="heading-link"><i class="fas fa-link"></i></a>理解枚举类型</h1>
      
<p>枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。下面先来看看什么是枚举？如何定义枚举？</p>
<a id="more"></a>

        <h2 id="枚举的定义"   >
          <a href="#枚举的定义" class="heading-link"><i class="fas fa-link"></i></a>枚举的定义</h2>
      
<p>回忆一下下面的程序，这是在没有枚举类型时定义常量常见的方式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/7.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> * 使用普通方式定义日期常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUESDAY=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEDNESDAY=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THURSDAY=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRIDAY=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SATURDAY=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上述的常量定义常量的方式称为int枚举模式，这样的定义方式并没有什么错，但它存在许多不足，如在类型安全和使用方便性上并没有多少好处，如果存在定义int值相同的变量，混淆的几率还是很大的，编译器也不会提出任何警告，因此这种方式在枚举出现后并不提倡，现在我们利用枚举类型来重新定义上述的常量，同时也感受一把枚举定义的方式，如下定义周一到周日的常量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类型，使用关键字enum</span></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>相当简洁，在定义枚举类型时我们使用的关键字是enum，与class关键字类似，只不过前者是定义枚举类型，后者是定义类类型。枚举类型Day中分别定义了从周一到周日的值，这里要注意，值一般是大写的字母，多个值之间以逗号分隔。同时我们应该知道的是枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部，更重要的是枚举常量在类型安全性和便捷性都很有保证，如果出现类型问题编译器也会提示我们改进，但务必记住枚举表示的类型其取值是必须有限的，也就是说每个值都是可以枚举出来的，比如上述描述的一周共有七天。那么该如何使用呢？如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/7.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直接引用</span></span><br><span class="line">        Day day =Day.MONDAY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>就像上述代码那样，直接引用枚举的值即可，这便是枚举类型的最简单模型。</p>

        <h2 id="枚举实现原理"   >
          <a href="#枚举实现原理" class="heading-link"><i class="fas fa-link"></i></a>枚举实现原理</h2>
      
<p>我们大概了解了枚举类型的定义与简单使用后，现在有必要来了解一下枚举类型的基本实现原理。实际上在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。</p>
<p>下面我们编译前面定义的EnumDemo.java并查看生成的class文件来验证这个结论：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看目录下的java文件</span></span><br><span class="line">zejian<span class="meta">@zejiandeMBP</span> enumdemo$ ls</span><br><span class="line">EnumDemo.java</span><br><span class="line"><span class="comment">//利用javac命令编译EnumDemo.java</span></span><br><span class="line">zejian<span class="meta">@zejiandeMBP</span> enumdemo$ javac EnumDemo.java </span><br><span class="line"><span class="comment">//查看生成的class文件，注意有Day.class和EnumDemo.class 两个</span></span><br><span class="line">zejian<span class="meta">@zejiandeMBP</span> enumdemo$ ls</span><br><span class="line">Day<span class="class">.<span class="keyword">class</span>  <span class="title">EnumDemo</span>.<span class="title">class</span>  <span class="title">EnumDemo</span>.<span class="title">java</span></span></span><br></pre></td></tr></table></div></figure>
<p>利用javac编译前面定义的EnumDemo.java文件后分别生成了Day.class和EnumDemo.class文件，而Day.class就是枚举类型，这也就验证前面所说的使用关键字enum定义枚举类型并编译后，编译器会自动帮助我们生成一个与枚举相关的类。我们再来看看反编译Day.class文件：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译Day.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Day[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Day[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Day <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//前面定义的7种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Day[] &#123;</span><br><span class="line">            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>由此可见java 中的枚举使用了语法糖，为我们省去的大量代码。</p>
<p>从反编译的代码可以看出编译器确实帮助我们生成了一个Day类(注意该类是final类型的，将无法被继承)而且该类继承自java.lang.Enum类，该类是一个抽象类(稍后我们会分析该类中的主要方法)。</p>
<p>除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，这也充分说明了我们前面使用关键字enum定义的Day类型中的<strong>每种日期枚举常量也是实实在在的Day实例对象</strong>，只不过代表的内容不一样而已。</p>
<p>注意编译器还为我们生成了两个静态方法，分别是values()和 valueOf()，稍后会分析它们的用法。</p>
<p>到此我们也就明白了，使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应<code>public static final Day MONDAY;</code>，同时编译器会为该类创建两个方法，分别是values()和valueOf()。ok~，到此相信我们对枚举的实现原理也比较清晰，下面我们深入了解一下java.lang.Enum类以及values()和valueOf()的用途。</p>

        <h2 id="枚举的常见方法"   >
          <a href="#枚举的常见方法" class="heading-link"><i class="fas fa-link"></i></a>枚举的常见方法</h2>
      

        <h3 id="enum抽象类常见方法"   >
          <a href="#enum抽象类常见方法" class="heading-link"><i class="fas fa-link"></i></a>Enum抽象类常见方法</h3>
      
<p>Enum是所有 Java 语言枚举类型的公共基本类（注意Enum是抽象类），以下是它的常见方法：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>compareTo(E o)</code></td>
<td>比较此枚举与指定对象的顺序</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object other)</code></td>
<td>当指定对象等于此枚举常量时，返回 true。</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>getDeclaringClass()</code></td>
<td>返回与此枚举常量的枚举类型相对应的 Class 对象</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>name()</code></td>
<td>返回此枚举常量的名称，在其枚举声明中对其进行声明</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>ordinal()</code></td>
<td>返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>返回枚举常量的名称，它包含在声明中</td>
</tr>
<tr>
<td><code>static&lt;T extends Enum&lt;T&gt;&gt; T</code></td>
<td><code>static valueOf(Class&lt;T&gt; enumType, String name)</code></td>
<td><code>返回带指定名称的指定枚举类型的枚举常量。</code></td>
</tr>
</tbody>
</table></div>
<p>这里主要说明一下<code>ordinal()</code>方法，该方法获取的是枚举变量在枚举类中声明的顺序，下标从0开始，如日期中的MONDAY在第一个位置，那么MONDAY的ordinal值就是0，如果MONDAY的声明位置发生变化，那么ordinal方法获取到的值也随之变化，注意在大多数情况下我们都不应该首先使用该方法，毕竟它总是变幻莫测的。</p>
<p><code>compareTo(E o)</code>方法则是比较枚举的大小，注意其内部实现是根据每个枚举的ordinal值大小进行比较的。</p>
<p><code>name()</code>方法与<code>toString()</code>几乎是等同的，都是输出变量的字符串形式。</p>
<p>至于<code>valueOf(Class&lt;T&gt; enumType, String name)</code>方法则是根据枚举类的Class对象和枚举名称获取枚举常量，注意该方法是静态的，后面在枚举单例时，我们还会详细分析该方法，下面的代码演示了上述方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Day &#123;</span><br><span class="line">        MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">        THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建枚举数组</span></span><br><span class="line">        Day[] days = <span class="keyword">new</span> Day[]&#123;Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY,</span><br><span class="line">                Day.THURSDAY, Day.FRIDAY, Day.SATURDAY, Day.SUNDAY&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; days.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"day["</span> + i + <span class="string">"].ordinal():"</span> + days[i].ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//通过compareTo方法比较,实际上其内部是通过ordinal()值比较的</span></span><br><span class="line">        System.out.println(<span class="string">"days[0].compareTo(days[1]):"</span> + days[<span class="number">0</span>].compareTo(days[<span class="number">1</span>]));</span><br><span class="line">        System.out.println(<span class="string">"days[0].compareTo(days[1]):"</span> + days[<span class="number">0</span>].compareTo(days[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取该枚举对象的Class对象引用,当然也可以通过getClass方法</span></span><br><span class="line">        Class&lt;?&gt; clazz = days[<span class="number">0</span>].getDeclaringClass();</span><br><span class="line">        System.out.println(<span class="string">"clazz:"</span> + clazz);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//name()</span></span><br><span class="line">        System.out.println(<span class="string">"days[0].name():"</span> + days[<span class="number">0</span>].name());</span><br><span class="line">        System.out.println(<span class="string">"days[1].name():"</span> + days[<span class="number">1</span>].name());</span><br><span class="line">        System.out.println(<span class="string">"days[2].name():"</span> + days[<span class="number">2</span>].name());</span><br><span class="line">        System.out.println(<span class="string">"days[3].name():"</span> + days[<span class="number">3</span>].name());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"days[0].toString():"</span> + days[<span class="number">0</span>].toString());</span><br><span class="line">        System.out.println(<span class="string">"days[1].toString():"</span> + days[<span class="number">1</span>].toString());</span><br><span class="line">        System.out.println(<span class="string">"days[2].toString():"</span> + days[<span class="number">2</span>].toString());</span><br><span class="line">        System.out.println(<span class="string">"days[3].toString():"</span> + days[<span class="number">3</span>].toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Day d = Enum.valueOf(Day.class, days[0].name());</span><br><span class="line">        Day d2 = Day.valueOf(days[<span class="number">0</span>].name());</span><br><span class="line">        System.out.println(<span class="string">"d:"</span> + d);</span><br><span class="line">        System.out.println(<span class="string">"d2:"</span> + d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>运行结果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">day[<span class="number">0</span>].ordinal():<span class="number">0</span></span><br><span class="line">day[<span class="number">1</span>].ordinal():<span class="number">1</span></span><br><span class="line">day[<span class="number">2</span>].ordinal():<span class="number">2</span></span><br><span class="line">day[<span class="number">3</span>].ordinal():<span class="number">3</span></span><br><span class="line">day[<span class="number">4</span>].ordinal():<span class="number">4</span></span><br><span class="line">day[<span class="number">5</span>].ordinal():<span class="number">5</span></span><br><span class="line">day[<span class="number">6</span>].ordinal():<span class="number">6</span></span><br><span class="line">-------------------------------------</span><br><span class="line">days[<span class="number">0</span>].compareTo(days[<span class="number">1</span>]):-<span class="number">1</span></span><br><span class="line">days[<span class="number">0</span>].compareTo(days[<span class="number">1</span>]):-<span class="number">2</span></span><br><span class="line">clazz:<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">eh</span>.<span class="title">ftd</span>.<span class="title">enums</span>.<span class="title">EnumDemo</span>$<span class="title">Day</span></span></span><br><span class="line"><span class="class">-------------------------------------</span></span><br><span class="line">days[0].name():MONDAY</span><br><span class="line">days[<span class="number">1</span>].name():TUESDAY</span><br><span class="line">days[<span class="number">2</span>].name():WEDNESDAY</span><br><span class="line">days[<span class="number">3</span>].name():THURSDAY</span><br><span class="line">-------------------------------------</span><br><span class="line">days[<span class="number">0</span>].toString():MONDAY</span><br><span class="line">days[<span class="number">1</span>].toString():TUESDAY</span><br><span class="line">days[<span class="number">2</span>].toString():WEDNESDAY</span><br><span class="line">days[<span class="number">3</span>].toString():THURSDAY</span><br><span class="line">-------------------------------------</span><br><span class="line">d:MONDAY</span><br><span class="line">d2:MONDAY</span><br></pre></td></tr></table></div></figure>
<p>到此对于抽象类Enum类的基本内容就介绍完了，这里提醒大家一点，Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的，不妨看看Enum类的主要源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现了Comparable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">//枚举字符串名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;<span class="comment">//枚举顺序值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举的构造方法，只能由编译器调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>==other;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较的是ordinal值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span><br><span class="line">        Enum&lt;E&gt; self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; <span class="comment">// optimization</span></span><br><span class="line">            self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">        <span class="keyword">return</span> self.ordinal - other.ordinal;<span class="comment">//根据ordinal值比较大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class&lt;E&gt; <span class="title">getDeclaringClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取class对象引用，getClass()是Object的方法</span></span><br><span class="line">        Class&lt;?&gt; clazz = getClass();</span><br><span class="line">        <span class="comment">//获取父类Class对象引用</span></span><br><span class="line">        Class&lt;?&gt; zuper = clazz.getSuperclass();</span><br><span class="line">        return (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//enumType.enumConstantDirectory()获取到的是一个map集合，key值就是name值，value则是枚举变量值   </span></span><br><span class="line">        <span class="comment">//enumConstantDirectory是class对象内部的方法，根据class对象获取一个map集合的值       </span></span><br><span class="line">        T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....省略其他没用的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>通过Enum源码，可以知道，Enum实现了Comparable接口，这也是可以使用compareTo比较的原因，当然Enum构造函数也是存在的，该函数只能由编译器调用，毕竟我们只能使用enum关键字定义枚举，其他事情就放心交给编译器吧。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由编译器调用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="编译器生成的values与valueof方法"   >
          <a href="#编译器生成的values与valueof方法" class="heading-link"><i class="fas fa-link"></i></a>编译器生成的values与valueOf方法</h3>
      
<p>values()方法和valueOf(String name)方法是编译器生成的static方法，因此从前面的分析中，在Enum类中并没出现values()方法，但valueOf()方法还是有出现的，只不过编译器生成的valueOf()方法需传递一个name参数，而Enum自带的静态方法valueOf()则需要传递两个方法，从前面反编译后的代码可以看出，编译器生成的valueOf方法最终还是调用了Enum类的valueOf方法，下面通过代码来演示这两个方法的作用：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Day[] days2 = Day.values();</span><br><span class="line">System.out.println(<span class="string">"day2:"</span>+Arrays.toString(days2));</span><br><span class="line"></span><br><span class="line">Day day = Day.valueOf(<span class="string">"MONDAY"</span>);</span><br><span class="line">System.out.println(<span class="string">"day:"</span>+day);</span><br></pre></td></tr></table></div></figure>
<p>运行结果</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">day2:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</span><br><span class="line">day:MONDAY</span><br></pre></td></tr></table></div></figure>
<p>从结果可知道，values()方法的作用就是获取枚举类中的所有变量，并作为数组返回，而valueOf(String name)方法与Enum类中的valueOf方法的作用类似根据名称获取枚举变量，只不过编译器生成的valueOf方法更简洁些只需传递一个参数。这里我们还必须注意到，由于values()方法是由编译器插入到枚举类中的static方法，所以如果我们将枚举实例向上转型为Enum，那么values()方法将无法被调用，因为Enum类中并没有values()方法，valueOf()方法也是同样的道理，注意是一个参数的。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//正常使用</span></span><br><span class="line">Day[] ds=Day.values();</span><br><span class="line"><span class="comment">//向上转型Enum</span></span><br><span class="line">Enum e = Day.MONDAY;</span><br><span class="line"><span class="comment">//无法调用,没有此方法</span></span><br><span class="line"><span class="comment">//e.values();</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="枚举与class对象"   >
          <a href="#枚举与class对象" class="heading-link"><i class="fas fa-link"></i></a>枚举与Class对象</h1>
      
<p>上述我们提到当枚举实例向上转型为Enum类型后，values()方法将会失效，也就无法一次性获取所有枚举实例变量，但是由于Class对象的存在，即使不使用values()方法，还是有可能一次获取到所有枚举实例变量的，在Class对象中存在如下方法：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>返回类型</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T[]</code></td>
<td><code>getEnumConstants()</code></td>
<td>返回该枚举类型的所有元素，如果Class对象不是枚举类型，则返回null。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEnum()</code></td>
<td>当且仅当该类声明为源代码中的枚举时返回 true</td>
</tr>
</tbody>
</table></div>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T[] getEnumConstants() &#123;</span><br><span class="line">    T[] values = getEnumConstantsShared();</span><br><span class="line">    <span class="keyword">return</span> (values != <span class="keyword">null</span>) ? values.clone() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// An enum must both directly extend java.lang.Enum and have</span></span><br><span class="line">    <span class="comment">// the ENUM bit set; classes for specialized enum constants</span></span><br><span class="line">    <span class="comment">// don't do the former.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.getModifiers() &amp; ENUM) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">this</span>.getSuperclass() == java.lang.Enum<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>因此通过getEnumConstants()方法，同样可以轻而易举地获取所有枚举实例变量下面通过代码来演示这个功能：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常使用</span></span><br><span class="line">Day[] ds=Day.values();</span><br><span class="line"><span class="comment">//向上转型Enum</span></span><br><span class="line">Enum e = Day.MONDAY;</span><br><span class="line"><span class="comment">//无法调用,没有此方法</span></span><br><span class="line"><span class="comment">//e.values();</span></span><br><span class="line"><span class="comment">//获取class对象引用</span></span><br><span class="line">Class&lt;?&gt; clasz = e.getDeclaringClass();</span><br><span class="line"><span class="keyword">if</span>(clasz.isEnum()) &#123;</span><br><span class="line">    Day[] dsz = (Day[]) clasz.getEnumConstants();</span><br><span class="line">    System.out.println(<span class="string">"dsz:"</span>+Arrays.toString(dsz));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>运行结果</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsz:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</span><br></pre></td></tr></table></div></figure>
<p>正如上述代码所展示，通过Enum的class对象的getEnumConstants方法，我们仍能一次性获取所有的枚举实例常量。</p>

        <h1 id="枚举的进阶用法"   >
          <a href="#枚举的进阶用法" class="heading-link"><i class="fas fa-link"></i></a>枚举的进阶用法</h1>
      
<p>在前面的分析中，我们都是基于简单枚举类型的定义，也就是在定义枚举时只定义了枚举实例类型，并没定义方法或者成员变量，实际上使用关键字enum定义的枚举类，除了不能使用继承(因为编译器会自动为我们继承Enum抽象类而Java只支持单继承，因此枚举类是无法手动实现继承的)，可以把enum类当成常规类，也就是说我们可以向enum类中添加方法和变量，甚至是mian方法，下面就来感受一把。</p>

        <h2 id="向enum类添加方法与自定义构造函数"   >
          <a href="#向enum类添加方法与自定义构造函数" class="heading-link"><i class="fas fa-link"></i></a>向enum类添加方法与自定义构造函数</h2>
      
<p>重新定义一个日期枚举类，带有desc成员变量描述该日期的对于中文描述，同时定义一个getDesc方法，返回中文描述内容，自定义私有构造函数，在声明枚举实例时传入对应的中文描述，代码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.enumdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/8.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                    <span class="string">",desc:"</span>+day.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>运行结果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name:MONDAY,desc:星期一</span><br><span class="line">name:TUESDAY,desc:星期二</span><br><span class="line">name:WEDNESDAY,desc:星期三</span><br><span class="line">name:THURSDAY,desc:星期四</span><br><span class="line">name:FRIDAY,desc:星期五</span><br><span class="line">name:SATURDAY,desc:星期六</span><br><span class="line">name:SUNDAY,desc:星期日</span><br></pre></td></tr></table></div></figure>
<p>从上述代码可知，在enum类中确实可以像定义常规类一样声明变量或者成员方法。</p>
<p>但是我们必须注意到，如果打算在<span style='color:red;background:背景颜色;font-size:文字大小;'>enum类中定义方法，务必在声明完枚举实例后使用分号分开</span>，倘若在枚举实例前定义任何方法，编译器都将会报错，无法编译通过。</p>
<p>同时即使自定义了构造函数且enum的定义结束，我们也<span style='color:red;background:背景颜色;font-size:文字大小;'>永远无法手动调用构造函数创建枚举实例，毕竟这事只能由编译器执行。</span></p>

        <h2 id="关于覆盖父类enum方法"   >
          <a href="#关于覆盖父类enum方法" class="heading-link"><i class="fas fa-link"></i></a>关于覆盖父类Enum方法</h2>
      
<p>既然enum类跟常规类的定义没什么区别（实际上enum还是有些约束的），那么覆盖父类的方法也不会是什么难说，可惜的是父类Enum中的定义的方法只有toString方法没有使用final修饰，因此只能覆盖toString方法，如下通过覆盖toString省去了getDesc方法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.enumdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/8.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name:"</span>+day.name()+</span><br><span class="line">                    <span class="string">",desc:"</span>+day.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="enum类中定义抽象方法"   >
          <a href="#enum类中定义抽象方法" class="heading-link"><i class="fas fa-link"></i></a>enum类中定义抽象方法</h2>
      
<p>与常规抽象类一样，enum类允许我们为其定义抽象方法，然后使每个枚举实例都实现该方法，以便产生不同的行为方式。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.enumdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/9.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumDemo3 &#123;</span><br><span class="line"></span><br><span class="line">    FIRST&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"FIRST TIME"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SECOND&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"SECOND TIME"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义抽象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"F:"</span>+EnumDemo3.FIRST.getInfo());</span><br><span class="line">        System.out.println(<span class="string">"S:"</span>+EnumDemo3.SECOND.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F:FIRST TIME</span><br><span class="line">S:SECOND TIME</span><br></pre></td></tr></table></div></figure>
<p>通过这种方式就可以轻而易举地定义每个枚举实例的不同行为方式。我们可能注意到，enum类的实例似乎表现出了多态的特性，可惜的是枚举类型的实例终究不能作为类型传递使用，就像下面的使用方式，编译器是不可能答应的：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法通过编译,毕竟EnumDemo3.FIRST是个实例对象</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">text</span><span class="params">(EnumDemo3.FIRST instance)</span></span>&#123; &#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="enum类与接口"   >
          <a href="#enum类与接口" class="heading-link"><i class="fas fa-link"></i></a>enum类与接口</h2>
      
<p>由于Java单继承的原因，enum类并不能再继承其它类，但并不妨碍它实现接口，因此enum类同样是可以实现多接口的，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.enumdemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/8.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">sport</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumDemo2 implements food ,sport&#123;</span><br><span class="line">    FOOD,</span><br><span class="line">    SPORT,</span><br><span class="line">    ; <span class="comment">//分号分隔</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>有时候，我们可能需要对一组数据进行分类，比如进行食物菜单分类而且希望这些菜单都属于food类型，appetizer(开胃菜)、mainCourse(主菜)、dessert(点心)、Coffee等，每种分类下有多种具体的菜式或食品，此时可以利用接口来组织，如下(代码引用自Thinking in Java)：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> Appetizer implements Food &#123;</span><br><span class="line">    SALAD, SOUP, SPRING_ROLLS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">enum</span> MainCourse implements Food &#123;</span><br><span class="line">    LASAGNE, BURRITO, PAD_THAI,</span><br><span class="line">    LENTILS, HUMMOUS, VINDALOO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">enum</span> Dessert implements Food &#123;</span><br><span class="line">    TIRAMISU, GELATO, BLACK_FOREST_CAKE,</span><br><span class="line">    FRUIT, CREME_CARAMEL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">enum</span> Coffee implements Food &#123;</span><br><span class="line">    BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,</span><br><span class="line">    LATTE, CAPPUCCINO, TEA, HERB_TEA;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeOfFood</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Food food = Appetizer.SALAD;</span><br><span class="line">    food = MainCourse.LASAGNE;</span><br><span class="line">    food = Dessert.GELATO;</span><br><span class="line">    food = Coffee.CAPPUCCINO;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>通过这种方式可以很方便组织上述的情景，同时确保每种具体类型的食物也属于Food，现在我们利用一个枚举嵌套枚举的方式，把前面定义的菜谱存放到一个Meal菜单中，通过这种方式就可以统一管理菜单的数据了。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Menu &#123;</span><br><span class="line">    Appetizer(Food.Appetizer<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">MainCourse</span>(<span class="title">Food</span>.<span class="title">MainCourse</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">Dessert</span>(<span class="title">Food</span>.<span class="title">Dessert</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">Coffee</span>(<span class="title">Food</span>.<span class="title">Coffee</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Menu</span><span class="params">(Class&lt;? extends Food&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过class对象获取枚举实例</span></span><br><span class="line">        values = clazz.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">        <span class="keyword">enum</span> Appetizer implements Food &#123;</span><br><span class="line">            SALAD, SOUP, SPRING_ROLLS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> MainCourse implements Food &#123;</span><br><span class="line">            LASAGNE, BURRITO, PAD_THAI,</span><br><span class="line">            LENTILS, HUMMOUS, VINDALOO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> Dessert implements Food &#123;</span><br><span class="line">            TIRAMISU, GELATO, BLACK_FOREST_CAKE,</span><br><span class="line">            FRUIT, CREME_CARAMEL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> Coffee implements Food &#123;</span><br><span class="line">            BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,</span><br><span class="line">            LATTE, CAPPUCCINO, TEA, HERB_TEA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food[] foods = Menu.MainCourse.values;</span><br><span class="line">        System.out.println(Arrays.toString(foods));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="枚举与switch"   >
          <a href="#枚举与switch" class="heading-link"><i class="fas fa-link"></i></a>枚举与switch</h1>
      
<p>关于枚举与switch是个比较简单的话题，使用switch进行条件判断时，条件参数一般只能是整型，字符型。而枚举型确实也被switch所支持，在java 1.7后switch也对字符串进行了支持。这里我们简单看一下switch与枚举类型的使用：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;GREEN,RED,BLUE&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(Color color)</span></span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (color)&#123;</span><br><span class="line">          <span class="keyword">case</span> BLUE: <span class="comment">//无需使用Color进行引用</span></span><br><span class="line">              System.out.println(<span class="string">"蓝色"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RED:</span><br><span class="line">              System.out.println(<span class="string">"红色"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> GREEN:</span><br><span class="line">              System.out.println(<span class="string">"绿色"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        printName(Color.BLUE);</span><br><span class="line">        printName(Color.RED);</span><br><span class="line">        printName(Color.GREEN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//蓝色</span></span><br><span class="line">        <span class="comment">//红色</span></span><br><span class="line">        <span class="comment">//绿色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>需要注意的是使用在于switch条件进行结合使用时，无需使用Color引用。</p>

        <h1 id="枚举与单例模式"   >
          <a href="#枚举与单例模式" class="heading-link"><i class="fas fa-link"></i></a>枚举与单例模式</h1>
      
<p>请移步<a href="/2020/%E5%B7%A5%E4%BD%9C/600_%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3_%E5%88%9B%E5%BB%BA%E5%9E%8B_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式">单例模式</a></p>

        <h1 id="enummap"   >
          <a href="#enummap" class="heading-link"><i class="fas fa-link"></i></a>EnumMap</h1>
      

        <h2 id="enummap基本用法"   >
          <a href="#enummap基本用法" class="heading-link"><i class="fas fa-link"></i></a>EnumMap基本用法</h2>
      
<p>先思考这样一个问题，现在我们有一堆size大小相同而颜色不同的数据，需要统计出每种颜色的数量是多少以便将数据录入仓库，定义如下枚举用于表示颜色Color:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    GREEN,RED,BLUE,YELLOW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>我们有如下解决方案，使用Map集合来统计，key值作为颜色名称，value代表衣服数量，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.enumdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/5/10.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Clothes&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C001"</span>,Color.BLUE));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C002"</span>,Color.YELLOW));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C003"</span>,Color.RED));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C004"</span>,Color.GREEN));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C005"</span>,Color.BLUE));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C006"</span>,Color.BLUE));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C007"</span>,Color.RED));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C008"</span>,Color.YELLOW));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C009"</span>,Color.YELLOW));</span><br><span class="line">        list.add(<span class="keyword">new</span> Clothes(<span class="string">"C010"</span>,Color.GREEN));</span><br><span class="line">        <span class="comment">//方案1:使用HashMap</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Clothes clothes:list)&#123;</span><br><span class="line">           String colorName=clothes.getColor().name();</span><br><span class="line">           Integer count = map.get(colorName);</span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(colorName,count+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(colorName,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方案2:使用EnumMap</span></span><br><span class="line">        Map&lt;Color,Integer&gt; enumMap=<span class="keyword">new</span> EnumMap&lt;&gt;(Color<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Clothes clothes:list)&#123;</span><br><span class="line">            Color color=clothes.getColor();</span><br><span class="line">            Integer count = enumMap.get(color);</span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                enumMap.put(color,count+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                enumMap.put(color,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(enumMap.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     输出结果:</span></span><br><span class="line"><span class="comment">     &#123;RED=2, BLUE=3, YELLOW=3, GREEN=2&#125;</span></span><br><span class="line"><span class="comment">     ---------------</span></span><br><span class="line"><span class="comment">     &#123;GREEN=2, RED=2, BLUE=3, YELLOW=3&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>代码比较简单，我们使用两种解决方案，一种是HashMap，一种EnumMap，虽然都统计出了正确的结果，但是EnumMap作为枚举的专属的集合，我们没有理由再去使用HashMap，毕竟EnumMap要求其Key必须为Enum类型，因而使用Color枚举实例作为key是最恰当不过了，也避免了获取name的步骤，更重要的是EnumMap效率更高，因为其内部是通过数组实现的（稍后分析），注意EnumMap的key值不能为null，虽说是枚举专属集合，但其操作与一般的Map差不多，概括性来说EnumMap是专门为枚举类型量身定做的Map实现，虽然使用其它的Map（如HashMap）也能完成相同的功能，但是使用EnumMap会更加高效，它只能接收同一枚举类型的实例作为键值且不能为null，由于枚举类型实例的数量相对固定并且有限，所以EnumMap使用数组来存放与枚举类型对应的值，毕竟数组是一段连续的内存空间，根据程序局部性原理，效率会相当高。下面我们来进一步了解EnumMap的用法，先看构造函数：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个具有指定键类型的空枚举映射。</span></span><br><span class="line">EnumMap(Class&lt;K&gt; keyType) </span><br><span class="line"><span class="comment">//创建一个其键类型与指定枚举映射相同的枚举映射，最初包含相同的映射关系（如果有的话）。     </span></span><br><span class="line">EnumMap(EnumMap&lt;K,? extends V&gt; m) </span><br><span class="line"><span class="comment">//创建一个枚举映射，从指定映射对其初始化。</span></span><br><span class="line">EnumMap(Map&lt;K,? extends V&gt; m)</span><br></pre></td></tr></table></div></figure>
<p>与HashMap不同，它需要传递一个类型信息，即Class对象，通过这个参数EnumMap就可以根据类型信息初始化其内部数据结构，另外两只是初始化时传入一个Map集合，代码演示如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用第一种构造</span></span><br><span class="line">Map&lt;Color,Integer&gt; enumMap=<span class="keyword">new</span> EnumMap&lt;&gt;(Color<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//使用第二种构造</span></span><br><span class="line">Map&lt;Color,Integer&gt; enumMap2=<span class="keyword">new</span> EnumMap&lt;&gt;(enumMap);</span><br><span class="line"><span class="comment">//使用第三种构造</span></span><br><span class="line">Map&lt;Color,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(Color.GREEN, <span class="number">2</span>);</span><br><span class="line">hashMap.put(Color.BLUE, <span class="number">3</span>);</span><br><span class="line">Map&lt;Color, Integer&gt; enumMap = <span class="keyword">new</span> EnumMap&lt;&gt;(hashMap);</span><br></pre></td></tr></table></div></figure>
<p>至于EnumMap的方法，跟普通的map几乎没有区别，注意与HashMap的主要不同在于构造方法需要传递类型参数和EnumMap保证Key顺序与枚举中的顺序一致，但请记住Key不能为null。</p>

        <h2 id="enummap实现原理剖析"   >
          <a href="#enummap实现原理剖析" class="heading-link"><i class="fas fa-link"></i></a>EnumMap实现原理剖析</h2>
      
<p>EnumMap的源码有700多行，这里我们主要分析其内部存储结构，添加查找的实现，了解这几点，对应EnumMap内部实现原理也就比较清晰了，先看数据结构和构造函数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//Class对象引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;K&gt; keyType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储Key值的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> K[] keyUniverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储Value值的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] vals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map的size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Enum&lt;?&gt;[] ZERO_LENGTH_ENUM_ARRAY = <span class="keyword">new</span> Enum&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyType = keyType;</span><br><span class="line">        keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">        vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>EnumMap继承了AbstractMap类，因此EnumMap具备一般map的使用方法，keyType表示类型信息，keyUniverse表示键数组，存储的是所有可能的枚举值，vals数组表示键对应的值，size表示键值对个数。在构造函数中通过<code>keyUniverse = getKeyUniverse(keyType);</code>初始化了keyUniverse数组的值，内部存储的是所有可能的枚举值，接着初始化了存在Value值得数组vals，其大小与枚举实例的个数相同，getKeyUniverse方法实现如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回枚举数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) &#123;</span><br><span class="line">        <span class="comment">//最终调用到枚举类型的values方法，values方法返回所有可能的枚举值</span></span><br><span class="line">        <span class="keyword">return</span> SharedSecrets.getJavaLangAccess()</span><br><span class="line">                                        .getEnumConstantsShared(keyType);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>从方法的返回值来看，返回类型是枚举数组，事实也是如此，最终返回值正是枚举类型的values方法的返回值，前面我们分析过values方法返回所有可能的枚举值，因此keyUniverse数组存储就是枚举类型的所有可能的枚举值。接着看put方法的实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       typeCheck(key);<span class="comment">//检测key的类型</span></span><br><span class="line">       <span class="comment">//获取存放value值得数组下标</span></span><br><span class="line">       <span class="keyword">int</span> index = key.ordinal();</span><br><span class="line">       <span class="comment">//获取旧值</span></span><br><span class="line">       Object oldValue = vals[index];</span><br><span class="line">       <span class="comment">//设置value值</span></span><br><span class="line">       vals[index] = maskNull(value);</span><br><span class="line">       <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>)</span><br><span class="line">           size++;</span><br><span class="line">       <span class="keyword">return</span> unmaskNull(oldValue);<span class="comment">//返回旧值</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>
<p>这里通过typeCheck方法进行了key类型检测，判断是否为枚举类型，如果类型不对，会抛出异常</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeCheck</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; keyClass = key.getClass();<span class="comment">//获取类型信息</span></span><br><span class="line">   <span class="keyword">if</span> (keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(keyClass + <span class="string">" != "</span> + keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>接着通过<code>int index = key.ordinal()</code>的方式获取到该枚举实例的顺序值，利用此值作为下标，把值存储在vals数组对应下标的元素中即<code>vals[index]</code>，这也是为什么EnumMap能维持与枚举实例相同存储顺序的原因，我们发现在对vals[]中元素进行赋值和返回旧值时分别调用了maskNull方法和unmaskNull方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表NULL值得空对象实例</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object NULL = <span class="keyword">new</span> Object() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"java.util.EnumMap.NULL"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">maskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果值为空，返回NULL对象，否则返回value</span></span><br><span class="line">       <span class="keyword">return</span> (value == <span class="keyword">null</span> ? NULL : value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">unmaskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//将NULL对象转换为null值</span></span><br><span class="line">       <span class="keyword">return</span> (V)(value == NULL ? <span class="keyword">null</span> : value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>
<p>由此看来EnumMap还是允许存放null值的，但key绝对不能为null，对于null值，EnumMap进行了特殊处理,将其包装为NULL对象，毕竟vals[]存的是Object，maskNull方法和unmaskNull方法正是用于null的包装和解包装的。这就是EnumMap集合的添加过程。下面接着看获取方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (isValidKey(key) ?</span><br><span class="line">               unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对Key值的有效性和类型信息进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Cheaper than instanceof Enum followed by getDeclaringClass</span></span><br><span class="line">     Class&lt;?&gt; keyClass = key.getClass();</span><br><span class="line">     <span class="keyword">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
<p>相对应put方法，get方法显示相当简洁，key有效的话，直接通过ordinal方法取索引，然后在值数组vals里通过索引获取值返回。remove方法如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断key值是否有效</span></span><br><span class="line">       <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//直接获取索引</span></span><br><span class="line">       <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line"></span><br><span class="line">       Object oldValue = vals[index];</span><br><span class="line">       <span class="comment">//对应下标元素值设置为null</span></span><br><span class="line">       vals[index] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>)</span><br><span class="line">           size--;<span class="comment">//减size</span></span><br><span class="line">       <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>
<p>非常简单，key值有效，通过key获取下标索引值，把vals[]对应下标值设置为null，size减一。查看是否包含某个值，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">判断是否包含某value</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    value = maskNull(value);</span><br><span class="line">    <span class="comment">//遍历数组实现</span></span><br><span class="line">    <span class="keyword">for</span> (Object val : vals)</span><br><span class="line">        <span class="keyword">if</span> (value.equals(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否包含key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; vals[((Enum&lt;?&gt;)key).ordinal()] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>判断value直接通过遍历数组实现，而判断key就更简单了，判断key是否有效和对应vals[]中是否存在该值。ok~，这就是EnumMap的主要实现原理，即内部有两个数组，长度相同，一个表示所有可能的键(枚举值)，一个表示对应的值，不允许keynull，但允许value为null，键都有一个对应的索引，根据索引直接访问和操作其键数组和值数组，由于操作都是数组，因此效率很高。</p>

        <h1 id="enumset"   >
          <a href="#enumset" class="heading-link"><i class="fas fa-link"></i></a>EnumSet</h1>
      
<p>EnumSet是与枚举类型一起使用的专用 Set 集合，EnumSet 中所有元素都必须是枚举类型。与其他Set接口的实现类HashSet/TreeSet(内部都是用对应的HashMap/TreeMap实现的)不同的是，EnumSet在内部实现是位向量(稍后分析)，它是一种极为高效的位运算操作，由于直接存储和操作都是bit，因此EnumSet空间和时间性能都十分可观，足以媲美传统上基于 int 的“位标志”的运算，重要的是我们可像操作set集合一般来操作位运算，这样使用代码更简单易懂同时又具备类型安全的优势。注意EnumSet不允许使用 null 元素。试图插入 null 元素将抛出 NullPointerException，但试图测试判断是否存在null 元素或移除 null 元素则不会抛出异常，与大多数collection 实现一样，EnumSet不是线程安全的，因此在多线程环境下应该注意数据同步问题，ok~，下面先来简单看看EnumSet的使用方式。</p>

        <h2 id="enumset用法"   >
          <a href="#enumset用法" class="heading-link"><i class="fas fa-link"></i></a>EnumSet用法</h2>
      
<p>创建EnumSet并不能使用new关键字，因为它是个抽象类，而应该使用其提供的静态工厂方法，EnumSet的静态工厂方法比较多，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">创建一个具有指定元素类型的空EnumSet。</span><br><span class="line">&lt;E extends Enum&lt;E&gt;&gt;  noneOf(Class&lt;E&gt; elementType)       </span><br><span class="line"><span class="comment">//创建一个指定元素类型并包含所有枚举值的EnumSet</span></span><br><span class="line">&lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">allOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个包括枚举值中指定范围元素的EnumSet</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">range</span><span class="params">(E from, E to)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 初始集合包括指定集合的补集</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">complementOf</span><span class="params">(EnumSet&lt;E&gt; s)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个包括参数中所有元素的EnumSet</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">of</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">of</span><span class="params">(E first, E... rest)</span></span></span><br><span class="line"><span class="function"><span class="comment">//创建一个包含参数容器中的所有元素的EnumSet</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">copyOf</span><span class="params">(EnumSet&lt;E&gt; s)</span></span></span><br><span class="line"><span class="function">&lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;E&gt; c)</span></span></span><br></pre></td></tr></table></div></figure>
<p>代码演示如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zejian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wuzejian on 2017/5/12.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    GREEN , RED , BLUE , BLACK , YELLOW</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//空集合</span></span><br><span class="line">        EnumSet&lt;Color&gt; enumSet= EnumSet.noneOf(Color<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"添加前："</span>+enumSet.toString());</span><br><span class="line">        enumSet.add(Color.GREEN);</span><br><span class="line">        enumSet.add(Color.RED);</span><br><span class="line">        enumSet.add(Color.BLACK);</span><br><span class="line">        enumSet.add(Color.BLUE);</span><br><span class="line">        enumSet.add(Color.YELLOW);</span><br><span class="line">        System.out.println(<span class="string">"添加后："</span>+enumSet.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用allOf创建包含所有枚举类型的enumSet，其内部根据Class对象初始化了所有枚举实例</span></span><br><span class="line">        EnumSet&lt;Color&gt; enumSet1= EnumSet.allOf(Color<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"allOf直接填充："</span>+enumSet1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始集合包括枚举值中指定范围的元素</span></span><br><span class="line">        EnumSet&lt;Color&gt; enumSet2= EnumSet.range(Color.BLACK,Color.YELLOW);</span><br><span class="line">        System.out.println(<span class="string">"指定初始化范围："</span>+enumSet2.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定补集，也就是从全部枚举类型中去除参数集合中的元素，如下去掉上述enumSet2的元素</span></span><br><span class="line">        EnumSet&lt;Color&gt; enumSet3= EnumSet.complementOf(enumSet2);</span><br><span class="line">        System.out.println(<span class="string">"指定补集："</span>+enumSet3.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化时直接指定元素</span></span><br><span class="line">        EnumSet&lt;Color&gt; enumSet4= EnumSet.of(Color.BLACK);</span><br><span class="line">        System.out.println(<span class="string">"指定Color.BLACK元素："</span>+enumSet4.toString());</span><br><span class="line">        EnumSet&lt;Color&gt; enumSet5= EnumSet.of(Color.BLACK,Color.GREEN);</span><br><span class="line">        System.out.println(<span class="string">"指定Color.BLACK和Color.GREEN元素："</span>+enumSet5.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制enumSet5容器的数据作为初始化数据</span></span><br><span class="line">        EnumSet&lt;Color&gt; enumSet6= EnumSet.copyOf(enumSet5);</span><br><span class="line">        System.out.println(<span class="string">"enumSet6："</span>+enumSet6.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Color&gt; list = <span class="keyword">new</span> ArrayList&lt;Color&gt;();</span><br><span class="line">        list.add(Color.BLACK);</span><br><span class="line">        list.add(Color.BLACK);<span class="comment">//重复元素</span></span><br><span class="line">        list.add(Color.RED);</span><br><span class="line">        list.add(Color.BLUE);</span><br><span class="line">        System.out.println(<span class="string">"list:"</span>+list.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用copyOf(Collection&lt;E&gt; c)</span></span><br><span class="line">        EnumSet enumSet7=EnumSet.copyOf(list);</span><br><span class="line">        System.out.println(<span class="string">"enumSet7:"</span>+enumSet7.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         输出结果：</span></span><br><span class="line"><span class="comment">         添加前：[]</span></span><br><span class="line"><span class="comment">         添加后：[GREEN, RED, BLUE, BLACK, YELLOW]</span></span><br><span class="line"><span class="comment">         -----------------------------------</span></span><br><span class="line"><span class="comment">         allOf直接填充：[GREEN, RED, BLUE, BLACK, YELLOW]</span></span><br><span class="line"><span class="comment">         -----------------------------------</span></span><br><span class="line"><span class="comment">         指定初始化范围：[BLACK, YELLOW]</span></span><br><span class="line"><span class="comment">         -----------------------------------</span></span><br><span class="line"><span class="comment">         指定补集：[GREEN, RED, BLUE]</span></span><br><span class="line"><span class="comment">         -----------------------------------</span></span><br><span class="line"><span class="comment">         指定Color.BLACK元素：[BLACK]</span></span><br><span class="line"><span class="comment">         指定Color.BLACK和Color.GREEN元素：[GREEN, BLACK]</span></span><br><span class="line"><span class="comment">         -----------------------------------</span></span><br><span class="line"><span class="comment">         enumSet6：[GREEN, BLACK]</span></span><br><span class="line"><span class="comment">         -----------------------------------</span></span><br><span class="line"><span class="comment">         list:[BLACK, BLACK, RED, BLUE]</span></span><br><span class="line"><span class="comment">         enumSet7:[RED, BLUE, BLACK]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><code>noneOf(Class&lt;E&gt; elementType)</code>静态方法，主要用于创建一个空的EnumSet集合，传递参数elementType代表的是枚举类型的类型信息，即Class对象。<code>EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType)</code>静态方法则是创建一个填充了elementType类型所代表的所有枚举实例，奇怪的是EnumSet提供了多个重载形式的of方法，最后一个接受的的是可变参数，其他重载方法则是固定参数个数，EnumSet之所以这样设计是因为可变参数的运行效率低一些，所有在参数数据不多的情况下，强烈***不建议***使用传递参数为可变参数的of方法，即<code>EnumSet&lt;E&gt; of(E first, E... rest)</code>，其他方法就不分析了，看代码演示即可。至于EnumSet的操作方法，则与set集合是一样的，可以看API即可这也不过多说明。什么时候使用EnumSet比较恰当的，事实上当需要进行位域运算，就可以使用EnumSet提到位域，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义位域变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_ONE = <span class="number">1</span> &lt;&lt; <span class="number">0</span> ; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_TWO = <span class="number">1</span> &lt;&lt; <span class="number">1</span> ; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_THREE = <span class="number">1</span> &lt;&lt; <span class="number">2</span> ; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_FOUR = <span class="number">1</span> &lt;&lt; <span class="number">3</span> ; <span class="comment">//8</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//位域运算</span></span><br><span class="line">        <span class="keyword">int</span> type= TYPE_ONE | TYPE_TWO | TYPE_THREE |TYPE_FOUR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>诸如上述情况，我们都可以将上述的类型定义成枚举然后采用EnumSet来装载，进行各种操作，这样不仅不用手动编写太多冗余代码，而且使用EnumSet集合进行操作也将使代码更加简洁明了。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Type&#123;</span><br><span class="line">    TYPE_ONE,TYPE_TWO,TYPE_THREE,TYPE_FOUR </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    EnumSet set =EnumSet.of(Type.TYPE_ONE,Type.TYPE_FOUR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>其实博主认为EnumSet最有价值的是其内部实现原理，采用的是位向量，它体现出来的是一种高效的数据处理方式，这点很值得我们去学习它。</p>

        <h2 id="enumset实现原理剖析"   >
          <a href="#enumset实现原理剖析" class="heading-link"><i class="fas fa-link"></i></a>EnumSet实现原理剖析</h2>
      
<p>关于EnumSet实现原理可能会有点烧脑，内部执行几乎都是位运算，可以先移步另一篇博文<a href="/2020/%E5%B7%A5%E4%BD%9C/100_%E8%AE%A1%E7%A7%91%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA/bitmap/" title="位向量">位向量</a></p>
<p>有前面位向量的分析，对于了解EnumSet的实现原理就相对简单些了，EnumSet内部使用的位向量实现的，前面我们说过EnumSet是一个抽象类，事实上它存在两个子类，RegularEnumSet和JumboEnumSet。RegularEnumSet使用一个long类型的变量作为位向量，long类型的位长度是64，因此可以存储64个枚举实例的标志位，一般情况下是够用的了，而JumboEnumSet使用一个long类型的数组，当枚举个数超过64时，就会采用long数组的方式存储。先看看EnumSet内部的数据结构：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//表示枚举类型</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;E&gt; elementType;</span><br><span class="line">    <span class="comment">//存储该类型信息所表示的所有可能的枚举实例</span></span><br><span class="line">    <span class="keyword">final</span> Enum&lt;?&gt;[] universe;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>EnumSet中有两个变量，一个elementType用于表示枚举的类型信息，universe是数组类型，存储该类型信息所表示的所有可能的枚举实例，EnumSet是抽象类，因此具体的实现是由子类完成的，下面看看<code>noneOf(Class&lt;E&gt; elementType)</code>静态构建方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//根据EnumMap中的一样，获取所有可能的枚举实例</span></span><br><span class="line">      Enum&lt;?&gt;[] universe = getUniverse(elementType);</span><br><span class="line">      <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(elementType + <span class="string">" not an enum"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</span><br><span class="line">          <span class="comment">//枚举个数小于64，创建RegularEnumSet</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> RegularEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//否则创建JumboEnumSet</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> JumboEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>
<p>从源码可以看出如果枚举值个数小于等于64，则静态工厂方法中创建的就是RegularEnumSet，否则大于64的话就创建JumboEnumSet。无论是RegularEnumSet还是JumboEnumSet，其构造函数内部都间接调用了EnumSet的构造函数，因此最终的elementType和universe都传递给了父类EnumSet的内部变量。如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RegularEnumSet构造</span></span><br><span class="line">RegularEnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123;</span><br><span class="line">      <span class="keyword">super</span>(elementType, universe);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JumboEnumSet构造</span></span><br><span class="line">JumboEnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123;</span><br><span class="line">      <span class="keyword">super</span>(elementType, universe);</span><br><span class="line">      elements = <span class="keyword">new</span> <span class="keyword">long</span>[(universe.length + <span class="number">63</span>) &gt;&gt;&gt; <span class="number">6</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>
<p>在RegularEnumSet类和JumboEnumSet类中都存在一个elements变量，用于记录位向量的操作，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RegularEnumSet</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegularEnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3411599620347842686L</span>;</span><br><span class="line">    <span class="comment">//通过long类型的elements记录位向量的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> elements = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于JumboEnumSet则是：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JumboEnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">334349849919042784L</span>;</span><br><span class="line">    <span class="comment">//通过long数组类型的elements记录位向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> elements[];</span><br><span class="line">     <span class="comment">//表示集合大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.............</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>在RegularEnumSet中elements是一个long类型的变量，共有64个bit位，因此可以记录64个枚举常量，当枚举常量的数量超过64个时，将使用JumboEnumSet，elements在该类中是一个long型的数组，每个数组元素都可以存储64个枚举常量，这个过程其实与前面位向量的分析是同样的道理，只不过前面使用的是32位的int类型，这里使用的是64位的long类型罢了。接着我们看看EnumSet是如何添加数据的，RegularEnumSet中的add实现如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测是否为枚举类型</span></span><br><span class="line">    typeCheck(e);</span><br><span class="line">    <span class="comment">//记录旧elements</span></span><br><span class="line">    <span class="keyword">long</span> oldElements = elements;</span><br><span class="line">    <span class="comment">//执行位向量操作，是不是很熟悉？</span></span><br><span class="line">    <span class="comment">//数组版：a[i &gt;&gt; SHIFT ] |= (1 &lt;&lt; (i &amp; MASK))</span></span><br><span class="line">    elements |= (<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>关于<code>elements |= (1L &lt;&lt; ((Enum)e).ordinal());</code>这句跟我们前面分析位向量操作是相同的原理，只不过前面分析的是数组类型实现，这里用的long类型单一变量实现，<code>((Enum)e).ordinal()</code>通过该语句获取要添加的枚举实例的序号，然后通过1左移再与 long类型的elements进行或操作，就可以把对应位置上的bit设置为1了，也就代表该枚举实例存在。图示演示过程如下，注意universe数组在EnumSet创建时就初始化并填充了所有可能的枚举实例，而elements值的第n个bit位1时代表枚举存在，而获取的则是从universe数组中的第n个元素值。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102225.png"  alt="" />
      </p>
<p>这就是枚举实例的添加过程和获取原理。而对于JumboEnumSet的add实现则是如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    typeCheck(e);</span><br><span class="line">    <span class="comment">//计算ordinal值</span></span><br><span class="line">    <span class="keyword">int</span> eOrdinal = e.ordinal();</span><br><span class="line">    <span class="keyword">int</span> eWordNum = eOrdinal &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldElements = elements[eWordNum];</span><br><span class="line">    <span class="comment">//与前面分析的位向量相同：a[i &gt;&gt; SHIFT ] |= (1 &lt;&lt; (i &amp; MASK))</span></span><br><span class="line">    elements[eWordNum] |= (<span class="number">1L</span> &lt;&lt; eOrdinal);</span><br><span class="line">    <span class="keyword">boolean</span> result = (elements[eWordNum] != oldElements);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>关于JumboEnumSet的add实现与RegularEnumSet区别是一个是long数组类型，一个long变量，运算原理相同，数组的位向量运算与前面分析的是相同的，这里不再分析。接着看看如何删除元素</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RegularEnumSet类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Class eClass = e.getClass();</span><br><span class="line">    <span class="keyword">if</span> (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldElements = elements;</span><br><span class="line">    <span class="comment">//将int型变量j的第k个比特位设置为0，即j= j&amp;~(1&lt;&lt;k)</span></span><br><span class="line">    <span class="comment">//数组类型：a[i&gt;&gt;SHIFT] &amp;= ~(1&lt;&lt;(i &amp;MASK));</span></span><br><span class="line"></span><br><span class="line">    elements &amp;= ~(<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal());<span class="comment">//long遍历类型操作</span></span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JumboEnumSet类的remove实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Class&lt;?&gt; eClass = e.getClass();</span><br><span class="line">        <span class="keyword">if</span> (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> eOrdinal = ((Enum&lt;?&gt;)e).ordinal();</span><br><span class="line">        <span class="keyword">int</span> eWordNum = eOrdinal &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> oldElements = elements[eWordNum];</span><br><span class="line">        <span class="comment">//与a[i&gt;&gt;SHIFT] &amp;= ~(1&lt;&lt;(i &amp;MASK));相同</span></span><br><span class="line">        elements[eWordNum] &amp;= ~(<span class="number">1L</span> &lt;&lt; eOrdinal);</span><br><span class="line">        <span class="keyword">boolean</span> result = (elements[eWordNum] != oldElements);</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>删除remove的实现，跟位向量的清空操作是同样的实现原理，如下：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102301.png"  alt="" />
      </p>
<p>至于JumboEnumSet的实现原理也是类似的，这里不再重复。下面为了简洁起见，我们以RegularEnumSet类的实现作为源码分析，毕竟JumboEnumSet的内部实现原理可以说跟前面分析过的位向量几乎一样。o~，看看如何判断是否包含某个元素</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Class eClass = e.getClass();</span><br><span class="line">    <span class="keyword">if</span> (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//先左移再按&amp;操作</span></span><br><span class="line">    <span class="keyword">return</span> (elements &amp; (<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal())) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c <span class="keyword">instanceof</span> RegularEnumSet))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(c);</span><br><span class="line"></span><br><span class="line">    RegularEnumSet&lt;?&gt; es = (RegularEnumSet&lt;?&gt;)c;</span><br><span class="line">    <span class="keyword">if</span> (es.elementType != elementType)</span><br><span class="line">        <span class="keyword">return</span> es.isEmpty();</span><br><span class="line">    <span class="comment">//~elements取反相当于elements补集，再与es.elements进行&amp;操作，如果为0，</span></span><br><span class="line">    <span class="comment">//就说明elements补集与es.elements没有交集，也就是es.elements是elements的子集</span></span><br><span class="line">    <span class="keyword">return</span> (es.elements &amp; ~elements) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>对于contains(Object e) 方法，先左移再按位与操作，不为0，则表示包含该元素，跟位向量的get操作实现原理类似，这个比较简单。对于<code>containsAll(Collection&lt;?&gt; c)</code>则可能比较难懂，这里分析一下，elements变量(long类型)标记EnumSet集合中已存在元素的bit位，如果bit位为1则说明存在枚举实例，为0则不存在，现在执行<code>~elements</code> 操作后 则说明<code>~elements</code>是elements的补集，那么只要传递进来的es.elements与补集<code>~elements</code> 执行&amp;操作为0，那么就可以证明es.elements与补集<code>~elements</code> 没有交集的可能，也就是说es.elements只能是elements的子集，这样也就可以判断出当前EnumSet集合中包含传递进来的集合c了，借着下图协助理解：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102317.png"  alt="" />
      </p>
<p>图中，elements代表A，<code>es.elements</code>代表S，<code>~elements</code>就是求A的补集，<code>(es.elements &amp; ~elements) == 0</code>就是在验证A’∩B是不是空集，即S是否为A的子集。接着看retainAll方法，求两个集合交集</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(c <span class="keyword">instanceof</span> RegularEnumSet))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.retainAll(c);</span><br><span class="line"></span><br><span class="line">        RegularEnumSet&lt;?&gt; es = (RegularEnumSet&lt;?&gt;)c;</span><br><span class="line">        <span class="keyword">if</span> (es.elementType != elementType) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> changed = (elements != <span class="number">0</span>);</span><br><span class="line">            elements = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> changed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> oldElements = elements;</span><br><span class="line">        <span class="comment">//执行与操作，求交集，比较简单</span></span><br><span class="line">        elements &amp;= es.elements;</span><br><span class="line">        <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>最后来看看迭代器是如何取值的</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> EnumSetIterator&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetIterator</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">//记录elements</span></span><br><span class="line">       <span class="keyword">long</span> unseen;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//记录最后一个返回值</span></span><br><span class="line">       <span class="keyword">long</span> lastReturned = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       EnumSetIterator() &#123;</span><br><span class="line">           unseen = elements;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> unseen != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (unseen == <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           <span class="comment">//取值过程，先与本身负执行&amp;操作得出的就是二进制低位开始的第一个1的数值大小</span></span><br><span class="line">           lastReturned = unseen &amp; -unseen;</span><br><span class="line">           <span class="comment">//取值后减去已取得lastReturned</span></span><br><span class="line">           unseen -= lastReturned;</span><br><span class="line">           <span class="comment">//返回在指定 long 值的二进制补码表示形式中最低位（最右边）的 1 位之后的零位的数量</span></span><br><span class="line">           <span class="keyword">return</span> (E) universe[Long.numberOfTrailingZeros(lastReturned)];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (lastReturned == <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">           elements &amp;= ~lastReturned;</span><br><span class="line">           lastReturned = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>
<p>比较晦涩的应该是</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取值过程，先与本身负执行&amp;操作得出的就是二进制低位开始的第一个1的数值大小</span></span><br><span class="line">lastReturned = unseen &amp; -unseen; </span><br><span class="line"><span class="comment">//取值后减去已取得lastReturned</span></span><br><span class="line">unseen -= lastReturned;</span><br><span class="line"><span class="keyword">return</span> (E) universe[Long.numberOfTrailingZeros(lastReturned)];</span><br></pre></td></tr></table></div></figure>
<p>我们通过原理图来协助理解，现在假设集合中已保存所有可能的枚举实例变量，我们需要把它们遍历展示出来，下面的第一个枚举元素的获取过程，显然通过<code>unseen &amp; -unseen;</code>操作，我们可以获取到二进制低位开始的第一个1的数值，该计算的结果是要么全部都是0，要么就只有一个1，然后赋值给lastReturned，通过<code>Long.numberOfTrailingZeros(lastReturned)</code>获取到该bit为1在64位的long类型中的位置，即从低位算起的第几个bit，如图，该bit的位置恰好是低位的第1个bit位置，也就指明了universe数组的第一个元素就是要获取的枚举变量。执行<code>unseen -= lastReturned;</code>后继续进行第2个元素的遍历，依次类推遍历出所有值，这就是EnumSet的取值过程，真正存储枚举变量的是universe数组，而通过long类型变量的bit位的0或1表示存储该枚举变量在universe数组的那个位置，这样做的好处是任何操作都是执行long类型变量的bit位操作，这样执行效率将特别高，毕竟是二进制直接执行，只有最终获取值时才会操作到数组universe。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200805102400.png"  alt="" />
      </p>
<p>ok<sub>，到这关于EnumSet的实现原理主要部分我们就分析完了，其内部使用位向量，存储结构很简洁，节省空间，大部分操作都是按位运算，直接操作二进制数据，因此效率极高。当然通过前面的分析，我们也掌握位向量的运算原理。好</sub>，关于java枚举，我们暂时聊到这。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h1>
      
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E5%80%BC%E4%BC%A0%E9%80%92or%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">值传递or引用传递</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/IO%E6%A1%86%E6%9E%B6/"><span class="paginator-prev__text">IO框架</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#理解枚举类型"><span class="toc-number">1.</span> <span class="toc-text">
          理解枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举的定义"><span class="toc-number">1.1.</span> <span class="toc-text">
          枚举的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举实现原理"><span class="toc-number">1.2.</span> <span class="toc-text">
          枚举实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举的常见方法"><span class="toc-number">1.3.</span> <span class="toc-text">
          枚举的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#enum抽象类常见方法"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          Enum抽象类常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译器生成的values与valueof方法"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          编译器生成的values与valueOf方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举与class对象"><span class="toc-number">2.</span> <span class="toc-text">
          枚举与Class对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举的进阶用法"><span class="toc-number">3.</span> <span class="toc-text">
          枚举的进阶用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#向enum类添加方法与自定义构造函数"><span class="toc-number">3.1.</span> <span class="toc-text">
          向enum类添加方法与自定义构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于覆盖父类enum方法"><span class="toc-number">3.2.</span> <span class="toc-text">
          关于覆盖父类Enum方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum类中定义抽象方法"><span class="toc-number">3.3.</span> <span class="toc-text">
          enum类中定义抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum类与接口"><span class="toc-number">3.4.</span> <span class="toc-text">
          enum类与接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举与switch"><span class="toc-number">4.</span> <span class="toc-text">
          枚举与switch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举与单例模式"><span class="toc-number">5.</span> <span class="toc-text">
          枚举与单例模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#enummap"><span class="toc-number">6.</span> <span class="toc-text">
          EnumMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#enummap基本用法"><span class="toc-number">6.1.</span> <span class="toc-text">
          EnumMap基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enummap实现原理剖析"><span class="toc-number">6.2.</span> <span class="toc-text">
          EnumMap实现原理剖析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#enumset"><span class="toc-number">7.</span> <span class="toc-text">
          EnumSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#enumset用法"><span class="toc-number">7.1.</span> <span class="toc-text">
          EnumSet用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enumset实现原理剖析"><span class="toc-number">7.2.</span> <span class="toc-text">
          EnumSet实现原理剖析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">8.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">314</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>