<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="泛型定义        泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;调用时传入具体的类型（类型实参）。">
<meta property="og:type" content="article">
<meta property="og:title" content="泛型">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="泛型定义        泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;调用时传入具体的类型（类型实参）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200818180721.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200818180721.png">
<meta property="article:published_time" content="2020-09-16T16:22:27.591Z">
<meta property="article:modified_time" content="2020-09-16T16:22:27.607Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200818180721.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>泛型 | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><div class="sticky-top" data-popover="置顶文章" data-popover-pos="up"><span class="sticky-top__icon"><i class="fas fa-thumbtack"></i></span></div><h1 class="post-title">泛型</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">10.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">75分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200818180721.png"  style="zoom:150%;" />
      

        <h1 id="泛型定义"   >
          <a href="#泛型定义" class="heading-link"><i class="fas fa-link"></i></a>泛型定义</h1>
      
<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<a id="more"></a>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<p>eg: <code>Generic&lt;T&gt;{}</code></p>
<blockquote>
<p>一些常用的泛型类型变量：<br />
E：元素（Element），多用于java集合框架<br />
K：关键字（Key）<br />
N：数字（Number）<br />
T：类型（Type）<br />
V：值（Value）</p>
</blockquote>

        <h1 id="为什么有泛型"   >
          <a href="#为什么有泛型" class="heading-link"><i class="fas fa-link"></i></a>为什么有泛型</h1>
      
<ol>
<li>auto cast<br />
适用于多种数据类型执行相同的代码（代码复用）</li>
<li>type checking at compile time<br />
泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li>
</ol>

        <h1 id="类型擦除type-erasure"   >
          <a href="#类型擦除type-erasure" class="heading-link"><i class="fas fa-link"></i></a>类型擦除(type erasure)</h1>
      
<p>使用泛型加上的类型参数在编译阶段会去掉，这个过程就成为类型擦除。也就是说泛型只在编译阶段有效，在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段，生成的字节码文件是不包括泛型信息的。总结成一句话，泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<blockquote>
<p>Java 5中初次引入泛型时，需要它们尽量保持与现存JVM的后向兼容性。为了达到这一目的， <code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 的运行时表示是相同的。这被称作泛型多态 （generic polymorphism）的消除模式（erasure model）。</p>
</blockquote>
<p>实际举个例子看下字节码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E extends java.lang.Object&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(E, E)</span></span>;</span><br><span class="line">   descriptor: (Ljava/lang/Object;Ljava/lang/Object;)V</span><br><span class="line">   flags: ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">0</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>    e1   Ljava/lang/Object;</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>    e2   Ljava/lang/Object;</span><br><span class="line">     LocalVariableTypeTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>    e1   TE;</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>    e2   TE;</span><br><span class="line">   Signature: #19                          // &lt;E:Ljava/lang/Object;&gt;(TE;TE;)V</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> &lt;E extends java.lang.Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(E, E)</span></span>;</span><br><span class="line">   descriptor: (Ljava/lang/Comparable;Ljava/lang/Comparable;)V</span><br><span class="line">   flags: ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">0</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>    e1   Ljava/lang/Comparable;</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>    e2   Ljava/lang/Comparable;</span><br><span class="line">     LocalVariableTypeTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>    e1   TE;</span><br><span class="line">           <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>    e2   TE;</span><br><span class="line">   Signature: #22                          // &lt;E::Ljava/lang/Comparable&lt;TE;&gt;;&gt;(TE;TE;)V</span><br></pre></td></tr></table></div></figure>
<p>可以看方法的描述符，已经转成具体的类型了。</p>

        <h1 id="泛型的使用"   >
          <a href="#泛型的使用" class="heading-link"><i class="fas fa-link"></i></a>泛型的使用</h1>
      
<p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>

        <h2 id="泛型类"   >
          <a href="#泛型类" class="heading-link"><i class="fas fa-link"></i></a>泛型类</h2>
      
<p>泛型用于类的定义中，被称为泛型类。通过泛型可以完成一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。<br />
泛型类示例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//重点：在实例化泛型类时，必须指定T的具体类型，此处T相当于形参，实际使用的时候会传入实参，可以理解成泛型类的声明，泛型类中的T可以当实际类型使用。</span></span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<p>看一个例子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());</span><br></pre></td></tr></table></div></figure>
<p><strong>注意：</strong></p>
<ol>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
<li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译器会报错：“Unknown class”<br />
<code>if(ex_num instanceof Generic&lt;Number&gt;){ }</code></li>
</ol>

        <h2 id="泛型接口"   >
          <a href="#泛型接口" class="heading-link"><i class="fas fa-link"></i></a>泛型接口</h2>
      
<p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol>
<li>当实现泛型接口的类，未传入泛型实参时</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>当实现泛型接口的类，传入泛型实参时：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个类实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="泛型方法"   >
          <a href="#泛型方法" class="heading-link"><i class="fas fa-link"></i></a>泛型方法</h2>
      
<p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></div></figure>

        <h3 id="泛型方法的基本用法"   >
          <a href="#泛型方法的基本用法" class="heading-link"><i class="fas fa-link"></i></a>泛型方法的基本用法</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="泛型类中的泛型方法"   >
          <a href="#泛型类中的泛型方法" class="heading-link"><i class="fas fa-link"></i></a>泛型类中的泛型方法</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">    <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="泛型方法与可变参数"   >
          <a href="#泛型方法与可变参数" class="heading-link"><i class="fas fa-link"></i></a>泛型方法与可变参数</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></div></figure>

        <h3 id="静态方法与泛型"   >
          <a href="#静态方法与泛型" class="heading-link"><i class="fas fa-link"></i></a>静态方法与泛型</h3>
      
<p>静态方法有一种情况需要注意一下，那就是在泛型类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上</strong>。<br />
即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="泛型方法使用原则"   >
          <a href="#泛型方法使用原则" class="heading-link"><i class="fas fa-link"></i></a>泛型方法使用原则</h3>
      
<p>泛型方法能使方法独立于类而产生变化，以下两点需要注意：</p>
<ol>
<li>如果使用泛型方法能将整个类泛型化那么就应该使用泛型方法。</li>
<li>static方法无法访问泛型类的泛型参数，如果要使用泛型能力，就必须使其成为泛型方法。</li>
</ol>

        <h1 id="协变与逆变"   >
          <a href="#协变与逆变" class="heading-link"><i class="fas fa-link"></i></a>协变与逆变</h1>
      

        <h2 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a>定义</h2>
      
<p><strong>逆变与协变用来描述类型转换（type transformation）后的继承关系</strong>，其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系（比如，A≤B表示A是由B派生出来的子类，A≥B表示A是B的父类）</p>
<ul>
<li>
<p>f(⋅)是 <strong>协变(covariant)</strong> 的，当A≤B时有f(A)≤f(B)成立；</p>
<blockquote>
<p>比如类型转换关系是数组，当Apple ≤ Fruit，Apple[] ≤ Fruit</p>
<p>比如类型转换关系是泛型的上边界，当Apple ≤ Fruit，<code>List&lt;? extends Apple&gt; ≤ List&lt;? extends Fruit&gt;</code></p>
</blockquote>
</li>
<li>
<p>f(⋅)是 <strong>逆变(contravariant)</strong> 的，当A≤B时有f(A) ≥ f(B)成立；</p>
<blockquote>
<p>比如类型转换关系是泛型的上边界，当Apple ≤ Fruit，<code>List&lt;? super Apple&gt; ≥ List&lt;? extends Fruit&gt;</code></p>
</blockquote>
</li>
<li>
<p>f(⋅)是 <strong>不变(invariant)</strong> 的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。</p>
<blockquote>
<p>比如类型转换关系是普通泛型，当Apple ≤ Fruit，<code>List&lt;Apple&gt;</code> 和 <code>List&lt;Fruit&gt;</code> 这两个泛型类没有继承关系</p>
</blockquote>
</li>
</ul>
<p>数组的类型信息是会一直存在的，在编译期和运行时都可以做检查。但是在使用泛型时，类型信息在编译期被擦除了，运行时也就无从检查。因此，泛型将这种错误检测放在编译期。</p>

        <h2 id="类型通配符"   >
          <a href="#类型通配符" class="heading-link"><i class="fas fa-link"></i></a>类型通配符</h2>
      
<p>由于泛型不是协变的，所以<code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。<strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是没有继承关系的。</strong><br />
编译器的逻辑其实是这样的，Integer is a Number， <code>Generic&lt;Integer&gt; is not a Generic&lt;Number&gt;</code>。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参</span>。再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。可以解决当具体类型不确定的时候，使用通配符? 代替。当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p>
<p>注意 ? 和 Object 的区别</p>
<ul>
<li>？表示某一种类型实参，比如<code>List&lt;?&gt; list</code>， 集合里只能存放某一种类型的元素，<code>List&lt;Object&gt;</code> list， 则可以存放多种类型的元素，既可以存放Integer，也可以存放String。</li>
<li>对于<code>List&lt;?&gt;</code>就不能向其内部添加元素。除了添加null之外，因为null是所有类类型的默认初始值，所有类类型都可以识别null。</li>
<li><code>List&lt;?&gt;</code>不允许添加，但是允许读取元素，使用Object来接收<br />
Object o = list.get(0);</li>
</ul>
<p><code>?</code> 的用法如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// 1. 作为方法参数使用， List&lt;?&gt; 是所有List&lt;Class类型&gt;的父类，可以用来接收像List&lt;String&gt;、List&lt;Integer&gt;的对象。</span></span><br><span class="line">        print(list1);</span><br><span class="line">        print(list2);</span><br><span class="line">        <span class="comment">// 2. 方法体内声明一个变量，用来接收List&lt;?&gt;的子类 也就是List&lt;Integer&gt;、List&lt;String&gt;等对象。</span></span><br><span class="line">        List&lt;?&gt; list = list1;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        list = list2;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>使用通配符可以实现泛型类的协变和逆变，请看下面两节。</p>

        <h2 id="协变"   >
          <a href="#协变" class="heading-link"><i class="fas fa-link"></i></a>协变</h2>
      
<p><code>&lt;? extends A&gt;</code></p>
<ul>
<li>
<p>从类型实参的角度，类型实参 <code>?</code> 要么是A要么A的子类，所以又叫做<strong>子类通配符</strong></p>
</li>
<li>
<p>从泛型类的角度，A 继承 B， 泛型类 List&lt;? extends A&gt; 也继承 List&lt;? extends B&gt;; <code>List&lt;A&gt;</code> 可以 赋值给 泛型类List&lt;? extends B&gt; 的引用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Apple&gt; extendsApples = Lists.newArrayList(<span class="keyword">new</span> Apple());</span><br><span class="line">        List&lt;Apple&gt; apples = Lists.newArrayList(<span class="keyword">new</span> Apple());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型类 List&lt;? extends Apple&gt; 继承自 List&lt;? extends Fruit&gt;</span></span><br><span class="line">        List&lt;? extends Fruit&gt; extendsFruits = extendsApples;</span><br><span class="line">        <span class="comment">// List&lt;Apple&gt; 可以赋值给泛型类List&lt;? extends Fruit&gt; 的引用</span></span><br><span class="line">        extendsFruits = apples;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ul>
<p>像上面这样使用子类通配符就完成了协变，看一个例子</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; extendsFruits = Lists.newArrayList(<span class="keyword">new</span> Apple());</span><br><span class="line">        <span class="comment">// 添加</span></span><br><span class="line">        extendsFruits.add(<span class="keyword">new</span> Apple()); <span class="comment">// 编译错误 ？extends Fruit can not be applied to Apple</span></span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        Fruit fruit = extendsFruits.get(<span class="number">0</span>); <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><code>List&lt;? extends Fruit&gt; flist</code>可以指向<code>List&lt;Apple&gt;</code>，也可以指向<code>List&lt;Orange&gt;</code>，java中的泛型不是具化泛型，编译期会将泛型信息擦除，运行时无从检查安全性，所以会在编译期进行类型检查。由于协变过程丢掉了类型信息(? 可以表示Fruit或者任何Fruit的子类，当<code>flist = new ArrayList&lt;Apple&gt;()</code> ？就是Apple，当<code>flist = new ArrayList&lt;Orange&gt;()</code> 就是Orange)，编译器拒绝所有不安全的操作。</p>
<blockquote>
<p>报错信息已经很明白了，？不能应用于Apple，谁知道它后面还会不会编程Orange呢</p>
</blockquote>

        <h2 id="逆变"   >
          <a href="#逆变" class="heading-link"><i class="fas fa-link"></i></a>逆变</h2>
      
<p><code>&lt;? super A&gt;</code></p>
<ul>
<li>
<p>从类型实参的角度，类型实参 <code>?</code> 要么是A要么A的父类，所以又叫做<strong>超类通配符</strong></p>
</li>
<li>
<p>从泛型类的角度，A 继承 B， 泛型类 <code>List&lt;? super A&gt;</code> 是 <code>List&lt;? super B&gt;</code>的父类; <code>List&lt;B&gt;</code> 可以赋值给泛型类List&lt;? super A&gt; 的引用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? <span class="keyword">super</span> Fruit&gt; superFruits = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Fruit&gt; fruits = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型类 List&lt;? super Apple&gt; 是 List&lt;? super Fruit&gt;的父类</span></span><br><span class="line">        List&lt;? <span class="keyword">super</span> Apple&gt; superApples = superFruits;</span><br><span class="line">        <span class="comment">// List&lt;Fruit&gt; 可以赋值给泛型类List&lt;? super Apple&gt; 的引用</span></span><br><span class="line">        superApples = fruits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ul>
<p>像上面这样使用子类通配符就完成了逆变，看一个例子</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? <span class="keyword">super</span> Apple&gt; superApples = Lists.newArrayList(<span class="keyword">new</span> Apple(), <span class="keyword">new</span> Fruit());</span><br><span class="line">        <span class="comment">// 添加</span></span><br><span class="line">        superApples.add(<span class="keyword">new</span> Apple()); <span class="comment">// ok</span></span><br><span class="line">        superApples.add(<span class="keyword">new</span> Fruit()); <span class="comment">// 编译错误 ? extends Apple can not be applied to Fruit</span></span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        Fruit fruit = superApples.get(<span class="number">0</span>); <span class="comment">// 编译错误 required:Fruit,Found:? super Apple</span></span><br><span class="line">        Object object = superApples.get(<span class="number">0</span>); <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>? 代表Apple或者Apple的超类，编译器知道向其中添加Apple或Apple的子类型（例如Jonathan）是安全的了。但是，既然Apple是下界，那么向这样的List中添加Fruit是不安全的。同理也读取不了其中的值，因为？表示Apple或者Apple的父类，除非用Object接受。</p>

        <h2 id="pecs"   >
          <a href="#pecs" class="heading-link"><i class="fas fa-link"></i></a>PECS</h2>
      
<p>什么时候使用extends，什么时候使用super。《Effective Java》给出精炼的描述：<strong>producer-extends, consumer-super（PECS）</strong>。</p>
<blockquote>
<p>想在网上找张现成的图都找不到，太tm懒了</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200818180721.png"  alt="" />
      </p>
<p>producer和consumer直译不太好理解，大家理解成仓库就行了，实际上也确实是存储地的意思。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>生产者的仓库只能读不能写，消费者的仓库只能写度不能读，结合图片很好理解。</span></p>
<p>框架和库代码中到处都是PECS，让我们来看一个实际的例子，<strong>java.util.Collections的copy方法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? extends T&gt; src， List&lt;? <span class="keyword">super</span> T&gt; dest)</span> </span>&#123;</span><br></pre></td></tr></table></div></figure>
<p>src：来源，对应生产者仓库需要从中读取数据，所以使用子类通配符</p>
<p>dest：出口，对应消费者仓库需要往里面存储数据，所以使用超类通配符</p>

        <h1 id="自限定泛型与协变"   >
          <a href="#自限定泛型与协变" class="heading-link"><i class="fas fa-link"></i></a>自限定泛型与协变</h1>
      

        <h2 id="自限定泛型"   >
          <a href="#自限定泛型" class="heading-link"><i class="fas fa-link"></i></a>自限定泛型</h2>
      
<p>前面几个小结阐述了限定类型泛型的作用，即限制类型参数的范围，同时可以使用限定的界限包含的方法。</p>
<p>什么样的是自限定类型呢？即，限定范围就是自身。比如一个实现了Comparable接口的的User类，希望只能和User类的实例进行比较，那么我们需要这样写：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>
<p>这样就利用了限定类型的两个用处：1.限定范围；2.可以使用限定类的方法。另外一个点，就是限定了只能是同类型的进行比较。</p>
<p>我们再来看一个更复杂的，jdk里的Enum类定义：</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; extends Object implements Comparable&lt;E&gt;, Serializable {}</code></span></p>
<p>这是一个更复杂的限定类型，为什么要这么复杂呢？如果我们写成简单的样子行不行？像这样：</p>
<p><code>public abstract class Enum implements Comparable&lt;Enum&gt;, Serializable {}</code></p>
<p>这和Enum类的作用有关系，Enum这个抽象类是用来被继承的，所以我们总是在定义和使用Enum的子类，而且我们希望enum Day和enum Month只能自己的枚举值之间进行比较，而不能互相比较。比如Monday和January就不能比较，因为比较是没有意义的。</p>
<p>看明白了这里，我们再来看一下，简化了的Enum能不能达到上述的限制目的？</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Month</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> satic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">     Day monday = <span class="keyword">new</span> Day(<span class="string">"monday"</span>);</span><br><span class="line">         Month january = <span class="keyword">new</span> Month(<span class="string">"january"</span>);</span><br><span class="line">     monday.compareTo(january);<span class="comment">// 1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>Java字节码格式并不禁止继承java.lang.Enum，但是javac编译器硬性不让你继承java.lang.Enum。改用Scala编译器轻松继承Enum。</p>
</blockquote>
<p>上述1位置的compareTo方法，在简化的Enum情况下是可以的，但是在jdk中复杂的Enum下是不可以的。这也就是为什么jdk里的Enum要定义的这么复杂，目的就是为了限制Enum的子类只能和自己同类的实例进行比较。</p>
<p>再来看《Java编程思想》给出的一个例子</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">// compile error:Type parameter 'B' is not within its bound; should extend 'SelfBounded&lt;B&gt;'</span></span><br><span class="line"><span class="comment">// 编译器已经说得很明显了，因为  class B extends SelfBounded&lt;A&gt;  不满足条件:T extends SelfBounded&lt;T&gt; ,</span></span><br><span class="line"><span class="comment">// 如何才能满足条件呢?将类B的定义改为class B extends SelfBounded&lt;B&gt;，</span></span><br><span class="line"><span class="comment">// 上面的 class A  和  class B 都是满足条件的，因为 class A extends SelfBounded&lt;A&gt;</span></span><br><span class="line"><span class="comment">//class D extends SelfBounded&lt;B&gt; &#123;&#125;</span></span><br></pre></td></tr></table></div></figure>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>SelfBounded类接受泛型参数T,而T由一个边界限定,这个边界就是拥有T作为其参数的SelfBounded</span></p>

        <h2 id="自限定类型的作用产生参数协变"   >
          <a href="#自限定类型的作用产生参数协变" class="heading-link"><i class="fas fa-link"></i></a>自限定类型的作用：产生参数协变</h2>
      
<p>前文我们讲了数组协变，泛型类的协变，参数协变又是什么呢？</p>
<p>先看一个协变返回类型的例子</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DerivedGetter.get()覆盖了OrdinaryGetter.get()</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span> </span>&#123;</span><br><span class="line">        Derived result1 = d.get(); <span class="comment">// 调用的DerivedGetter.get()</span></span><br><span class="line">        Base result2 = d.get(); <span class="comment">// 也调用的DerivedGetter.get()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>自限定泛型将子类作为其返回值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span> </span>&#123;</span><br><span class="line">        Getter result1 = g.get();</span><br><span class="line">        GenericGetter result2 = g.get(); <span class="comment">// Also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>参数协变：类型实参随着子类类型变化而变化</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class&lt;E&gt; <span class="title">getDeclaringClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = getClass();</span><br><span class="line">        Class&lt;?&gt; zuper = clazz.getSuperclass();</span><br><span class="line">        return (zuper == Enum.class) ? (Class&lt;E&gt;) clazz : (Class&lt;E&gt;) zuper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">        Father&lt;?&gt; other = o;</span><br><span class="line">        Father&lt;E&gt; self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; <span class="comment">// optimization</span></span><br><span class="line">                self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">        <span class="keyword">return</span> self.ordinal - other.ordinal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Child1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child1</span><span class="params">(<span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Child2</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Child2</span><span class="params">(<span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child1 c11 = <span class="keyword">new</span> Child1(<span class="number">11</span>);</span><br><span class="line">        Child1 c12 = <span class="keyword">new</span> Child1(<span class="number">12</span>);</span><br><span class="line">        Child2 c21 = <span class="keyword">new</span> Child2(<span class="number">21</span>);</span><br><span class="line">        c11.compareTo(c12);</span><br><span class="line">        c11.compareTo(c21); <span class="comment">// 编译错误 Child1 can not be applied to Child2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>自限定类型的本质就是：<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'><strong>基类使用子类类型作为其参数类型</strong>。当子类继承父类时，使用自己的类型作为参数类型就能实现特定的意义(比如上面代码中自己和自己比较)。这意味着泛型基类变成了一种所有子类的<strong>公共功能模版</strong>，注意公共模板这个用词，一般不适用模板来做什么，只会使用子类，比如jdk中的枚举Enum也是模板类，jdk更彻底让编译器直接禁用了。</span></p>

        <h2 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      
<p><strong>自限定类型的用法</strong></p>
<p><code>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {}</code></p>
<p><strong>自限定类型的作用</strong></p>
<p>自限定类型的作用在于产生参数协变</p>

        <h1 id="泛型嵌套"   >
          <a href="#泛型嵌套" class="heading-link"><i class="fas fa-link"></i></a>泛型嵌套</h1>
      
<p>这个很简单，提一下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = Maps.newHashMap();</span><br><span class="line">        List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">        list.add(<span class="string">"hello"</span>);</span><br><span class="line">        list.add(<span class="string">"world"</span>);</span><br><span class="line">        map.put(<span class="string">"a"</span>, list);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt; set = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt; iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, List&lt;String&gt;&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">","</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>运行结果：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,[hello, world]</span><br></pre></td></tr></table></div></figure>

        <h1 id="泛型数组"   >
          <a href="#泛型数组" class="heading-link"><i class="fas fa-link"></i></a>泛型数组</h1>
      
<p><strong>在java中定义数组类型变量时，实际类型不能是泛型数组，静态类型可以是泛型数组</strong></p>
<p>因为这样做会破坏类型安全。核心的问题在于Java范型和C#范型存在根本区别：Java的范型停留在编译这一层，到了运行时，这些范型的信息其实是被抹掉的；而C#的范型做到了MSIL这一层。Java的做法不必修改JVM，减少了潜在的大幅改动和随之而来的风险，也许同时也反映出Java Bytecode规范在设计之初的先天不足；C#则大刀阔斧，连CLR一起改以支持更彻底的范型，换句话说，在范型这一点上，感觉C#更C++一点。</p>
<p>在Java中，Object[]数组可以是任何数组的父类(数组协变)，或者说，任何一个数组都可以向上转型成它在定义时指定元素类型的父类的数组，这个时候如果我们往里面放不同于原始数据类型 但是满足后来使用的父类类型的话，编译不会有问题，但是在运行时会检查加入数组的对象的类型，于是会抛<em>ArrayStoreException</em>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] ducks = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">ducks[<span class="number">0</span>] = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(ducks[<span class="number">0</span>]); <span class="comment">// 运行时error, java.lang.ArrayStoreException: java.lang.String</span></span><br></pre></td></tr></table></div></figure>
<p>因为Java的范型会在编译后将类型信息抹掉，这样如果Java允许我们使用类似</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt;[] mapArray = <span class="keyword">new</span> Map&lt;Integer, String&gt;[<span class="number">20</span>];</span><br></pre></td></tr></table></div></figure>
<p>这样的语句的话，我们在随后的代码中可以把它转型为Object[]然后往里面放Map&lt;Double, String&gt;实例。这样做不但编译器不能发现类型错误，就连运行时的数组存储检查对它也无能为力，它能看到的是我们往里面放Map的对象，我们定义的&lt;Integer, String&gt;在这个时候已经被抹掉了，于是而对它而言，只要是Map，都是合法的。想想看，我们本来定义的是装Map&lt;Integer, String&gt;的数组，结果我们却可以往里面放任何Map，接下来如果有代码试图按原有的定义去取值，后果是什么不言自明。</p>
<p>一句话总结就是：<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>数组是协变的，泛型是不变的，类型信息会在编译期擦除，如果可以使用泛型数组，将数组向上转型后，不管是在编译时还是在运行时，编译器和虚拟机都检查不了数组存放的类型到底对不对了。</span></p>
<p>再来举两个小例子</p>
<p>下面这样是不可以的，因为数组的实际类型不能绑定泛型信息</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></div></figure>
<p>下面这样是可以的，数组的静态类型可以泛型数组，可以在编译期做一些检查</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">ls[<span class="number">0</span>] = Lists.newArrayList(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// ls[1] = Lists.newArrayList(1);// 编译期 error， 提示不匹配的类型</span></span><br><span class="line">Object[] os = ls;</span><br><span class="line">os[<span class="number">1</span>] = Lists.newArrayList(<span class="number">2</span>);</span><br><span class="line">System.out.println(os[<span class="number">0</span>]);</span><br><span class="line">System.out.println(os[<span class="number">1</span>]);</span><br></pre></td></tr></table></div></figure>
<p>所以使用声明类型是泛型数组这样的方法来对编译期做类型检查也是不错的。</p>

        <h1 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a>注意事项</h1>
      

        <h2 id="extends-a-和-t-extends-a"   >
          <a href="#extends-a-和-t-extends-a" class="heading-link"><i class="fas fa-link"></i></a>&lt;? extends A&gt;  和 &lt;T extends A&gt;</h2>
      
<ul>
<li>？ 表示类型实参，T表示类型形参</li>
<li>要使用T必须先声明，参照泛型类、泛型接口、泛型方法，声明后才可以使用，？表示类型实参，直接可以使用</li>
</ul>

        <h2 id="t-extends-comparable-super-t"   >
          <a href="#t-extends-comparable-super-t" class="heading-link"><i class="fas fa-link"></i></a>&lt;T extends Comparable&lt;? super T&gt;&gt;</h2>
      
<blockquote>
<p>一定要理解前文提到的逆变，这个问题就很容易解释了。</p>
<p>java.util.Collections</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">     list.sort(<span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">         list.sort(c);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</blockquote>
<ol>
<li>
<p>语法分析<br />
1.1. extends对泛型上限进行了限制即T必须是Comparable的子类或者实现类<br />
1.2. <code>&lt;? super T&gt;</code>表示<code>Comparable&lt;&gt;</code>中的泛型类型下限为T！</p>
<blockquote>
<p>分成两部分理解</p>
<p>T(泛型声明尖括号<code>&lt;&gt;</code>中第一个T)：相当于泛型的声明(泛型接口、泛型类、泛型方法)，编译时会将类型实参替换调这个类型形参。声明完后可以将T当做类型实参使用，比如在T的作用域类使用<code>T t; if(t instanceof String){}</code>这种形式。</p>
<p><code>？ super T</code>：泛型类逆变，A继承B， 类型转换后，List&lt;? super A&gt;  是 List&lt;? super B&gt;的父类，所以List&lt;? super A&gt;既可以表示<code>List&lt;A&gt;</code>也可以表示<code>List&lt;B&gt;</code></p>
</blockquote>
</li>
</ol>
<p>为什么会有这种写法<code>&lt;T extends Comparable&lt;? super T&gt;</code>,看一个例子</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Father</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Father o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort1</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        list.sort(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        list.sort(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Father&gt; fs = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Son&gt; ss = <span class="keyword">null</span>;</span><br><span class="line">        sort1(fs); <span class="comment">// ok</span></span><br><span class="line">        sort1(ss); <span class="comment">// error List&lt;T&gt; can not be applied to List&lt;Son&gt; 理由：不匹配的等价约束，Father and Son</span></span><br><span class="line">        sort2(fs); <span class="comment">// ok</span></span><br><span class="line">        sort2(ss); <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>编译器提示的已经很明确了，因为Father 实现的<code>Comparable&lt;Father&gt;</code>， 子类继承Father，实现的也是<code>Comparable&lt;Father&gt;</code>，sort1方法只允许<code>T extends Comparable&lt;T&gt;</code>这样的<code>List&lt;T&gt;</code>类实参，为了能比较子类，需要对泛型类<code>List&lt;T&gt;</code>做逆变，也就是<code>List&lt;? super T&gt;</code>，现在如果A继承B， 类型转换(List)后，List&lt;? super A&gt;  是 List&lt;? super B&gt;的父类，所以List&lt;? super A&gt;既可以表示<code>List&lt;A&gt;</code>也可以表示<code>List&lt;B&gt;</code>。</p>
<p>下面不用看了，只是用来纪念一段曲折的学习史。</p>
<hr />
<p>让我们从头开始捋</p>
<hr />
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; 和 List&lt;ClassA&gt;、List&lt;ClassB&gt;</span><br><span class="line"></span><br><span class="line">? 是类型实参，表示所有的Class实例，也即可以表示ClassA、ClassB等。</span><br><span class="line"></span><br><span class="line">List&lt;?&gt; 相当于 List&lt;ClassA&gt; 和List&lt;ClassB&gt; 等 的父类， 父类可以用来接收子类， of course，List&lt;?&gt; 也可以用来接收List&lt;ClassA&gt; 和List&lt;ClassB&gt; 等</span><br><span class="line"></span><br><span class="line">为什么会有List&lt;?&gt;这种写法</span><br><span class="line">用前面打印列表举例</span><br><span class="line">print(List&lt;Number&gt; list);</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">null</span>;</span><br><span class="line">print(list); <span class="comment">// 出错，编译器认为Integer是Number的子类，但是List&lt;Integer&gt;不是List&lt;Number&gt;的子类，也就是泛型不具有协变。</span></span><br><span class="line">要定义打印列表方法还得重载print，可不可以有个泛型类既是List&lt;Number&gt;的父类也是List&lt;Integer&gt;的父类</span><br><span class="line">List&lt;?&gt;就表示List&lt;具体类型&gt;的父类。</span><br><span class="line">但是 ？ 表示的范围太大了，这里只想表示Number及Number子类的泛型 父类，这就引出了泛型边界。</span><br></pre></td></tr></table></div></figure>
<hr />
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;和List&lt;? extends ClassA&gt;、List&lt;? <span class="keyword">super</span> ClassA&gt;</span><br><span class="line">可以使用类比的手段表示上面三者的区别</span><br><span class="line">？ 表示所有具体类型，像是String、Integer等等，可以想象成(负无穷, 正无穷)</span><br><span class="line">？extends ClassA 表示对？加以限制，现在？只能表示ClassA或者ClassA的子类 (负无穷, ClassA]</span><br><span class="line">注意：如果A是接口&lt;? extends A&gt; ?表示A的所有实现类；</span><br><span class="line">			如果A是子类&lt;? extends A&gt; ？ 表示A或者A的所有子类</span><br><span class="line">？extends ClassA 表示对？加以限制，现在？只能表示ClassA或者ClassA的父类 [ClassA, 正无穷)</span><br><span class="line">上一个例子中？表示的范围太大了，可以使用List&lt;? extends Number&gt; </span><br><span class="line">? 可以表示Number或者Number的子类</span><br><span class="line">List&lt;? extends Number&gt;  表示 List&lt;Number&gt;或者List&lt;Integer&gt;等的父类</span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; 表示 List&lt;Integer&gt; 或者 List&lt;Number&gt;的父类。</span><br></pre></td></tr></table></div></figure>
<hr />
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;</span><br><span class="line">由于Comparable是接口，T表示Comparable的一个实现类</span><br><span class="line"><span class="comment">// 1. &lt;T  extends Comparable&gt;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;T extends Comparable&gt; T是Comparable&lt;Object&gt;的实现类, 上面A符合要求</span><br><span class="line">符合要求是指在类似下面这种写法时，可以用来表示A，也就是参数化类型T可以接受实参A</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. &lt;T extends Comparable&lt;T&gt;&gt;</span></span><br><span class="line">先来看&lt;T1 extends Comparable&lt;T2&gt;&gt; 表示T1是Comparable&lt;T2&gt;的实现类。</span><br><span class="line">同理 &lt;T extends Comparable&lt;T&gt;&gt; 表示T 是Comparable&lt;T&gt;的实现类。</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(A o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;T extends Comparable&lt;T&gt;&gt; A是Comparable&lt;A&gt;的实现类, 上面A符合要求</span><br><span class="line">符合要求是指在类似下面这种写法时，可以用来表示A，也就是参数化类型T可以接受实参A</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. &lt;T extends Comparable&lt;? super T&gt;&gt;</span></span><br><span class="line">假设A有子类AA</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test&lt;A&gt; test1 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">        <span class="comment">// 下面这行报错，提示类型越界</span></span><br><span class="line">        <span class="comment">// Type parameter 'AA' is not within its bound; should implement 'java.lang.Comparable&lt;AA&gt;'</span></span><br><span class="line"><span class="comment">//        Test&lt;AA&gt; test2 = new Test&lt;&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(A o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面例子表明A 符合 要求，因为A 实现了 Comparable&lt;A&gt;，A 是 Comparable&lt;A&gt;的实现类</span><br><span class="line">但是A的子类AA不符合要求， 因为AA继承A，但是实现的是Comparable&lt;A&gt; 也就是</span><br><span class="line">AA是Comparable&lt;A&gt;的实现类， AA 不是Comparable&lt;AA&gt;的实现类 <span class="comment">// 很重要</span></span><br><span class="line">从语义上也好理解，T可以和T进行比较，T不能和T的父类比较，但我们都知道比较的字段肯定是放在父类上的，子类肯定可以和父类进行比较。</span><br><span class="line">剧透一下？ <span class="keyword">super</span> T， ？表示T的父类，这下子类就可以和父类进行比较了。我们看下具体的分析流程。</span><br><span class="line"></span><br><span class="line">聚焦一下问题， Test&lt;T extends Comparable&lt;T&gt;&gt;只接受A,不接受AA</span><br><span class="line">如何改造Test&lt;T extends Comparable&lt;T&gt;&gt;，使得T既接受A也接受AA</span><br><span class="line">这个问题就回到了第二块的内容List&lt;?&gt; 和 List&lt;? extends Number&gt;、List&lt;? <span class="keyword">super</span> Integer&gt; 这里的AA相当于Integer。</span><br><span class="line">我们可以使用Test&lt;T extends Comparable&lt;?&gt;&gt;这种写法，现在既能接受A也接受AA</span><br><span class="line">A 是 Comparable&lt;A&gt;的实现类</span><br><span class="line">AA 是 Comparable&lt;A&gt; 的实现类</span><br><span class="line">但是存在像List&lt;?&gt;一样的问题，没有限制</span><br><span class="line">对问题建模，Test&lt;T extends Comparable&lt;?&gt;&gt;，如何让？既表示T又表示T的父类， 显然用<span class="keyword">super</span>即可解决</span><br><span class="line">Test&lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;</span><br><span class="line">现在<span class="keyword">new</span> Test&lt;A&gt;和<span class="keyword">new</span> Test&lt;AA&gt;都是合法的了。</span><br><span class="line">因为T extends Comparable&lt;? <span class="keyword">super</span> T&gt; 现在可以表示 AA是 Comparable&lt;A&gt;的实现类了。 也即 ? spuer AA 可以表示A</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小结</span></span><br><span class="line">还是那句话，T是类型形参，要被类型实参所取代，使用边界限制也就是对类型实参做筛选，上例中的AA是实参，</span><br><span class="line">T extends Comparable 和 Comparable&lt;? <span class="keyword">super</span> T&gt; 都是边界限制</span><br><span class="line">判断AA满足不满足要求， 因为AA extends A，A 是Comparable&lt;A&gt;的实现类，所以AA也是Comparable&lt;A&gt;的实现类。</span><br><span class="line">？ <span class="keyword">super</span> AA 可以表示A</span><br><span class="line">所以AA 满足要求。</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>来看一段代码辅助理解<code>&lt;T extends Comparable&lt;T&gt;&gt;</code>和<code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code></li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Father</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Father o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e1.compareTo(e2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare2</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e1.compareTo(e2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A&lt;Father&gt; a1 = <span class="keyword">new</span> A&lt;&gt;(); <span class="comment">// 1</span></span><br><span class="line">A&lt;Son&gt; a2 = <span class="keyword">new</span> A&lt;&gt;(); <span class="comment">// 2</span></span><br></pre></td></tr></table></div></figure>
<p>上面第二行编译报错，提示 <code>Type parameter 'com.eh.ftd.dsa.ds.impl.Generic.Son' is not within its bound; should implement 'java.lang.Comparable&lt;com.eh.ftd.dsa.ds.impl.Generic.Son&gt;'</code><br />
出错信息表明类型参数Son越界，应该实现<code>Comparable&lt;Son&gt;</code>。由此我们可以推断<code>Father implements Comparable&lt;Father&gt;</code>，子类继承父类，样式为<code>Son implements Comparable&lt;Father&gt;</code>。编译器认为这个不在限制范围<code>&lt;E extends Comparable&lt;E&gt;&gt;</code>内所以会报错。</p>
<p>使用<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>这种写法的作用是，父类实现了<code>Comparable&lt;父类&gt;</code>，子类没有实现<code>Comparable&lt;子类&gt;</code> 但是子类实现了<code>Comparable&lt;父类&gt;</code>，<code>&lt;? super E&gt;</code>中的？既可以表可以父类，也可以表示子类。所以现在可以使用<code>B&lt;Son&gt; b = new B&lt;&gt;();</code>这种写法。</p>
<p><strong>注意</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son s1 = <span class="keyword">new</span> Son(<span class="number">1</span>);</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son(<span class="number">2</span>);</span><br><span class="line">        System.out.println(compare(s1, s2));</span><br></pre></td></tr></table></div></figure>
<p>上述代码运行正确，如上所述参数Son应该也越界才是，<strong>说明编译器检测时对泛型方法自动做了一层转换</strong>。<strong>泛型方法<code>&lt;E extends Comparable&lt;E&gt;&gt; int compare(E e1, E e2)</code>和<code>&lt;E extends Comparable&lt;? super E&gt;&gt; int compare</code>是完全等价的</strong>， 编译器会报错<code>compare(E,E) clashes with compare(E,E); both methods have same erasure</code>，也就是两个方法由于有相同的泛型类型(类型擦除)而产生了冲突。<br />
建议泛型方法和泛型类保持一致，都采用<code>E extends Comparable&lt;? super E&gt;&gt;</code>这种写法。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h1>
      
<p><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/986f732ed2f1"  target="_blank" rel="noopener">Java泛型详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
<span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/s10461/article/details/53941091"  target="_blank" rel="noopener">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
<span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/chenxibobo/p/9655236.html"  target="_blank" rel="noopener">Java中&lt;? extends T&gt;和&lt;? super T&gt;的理解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/allmignt/p/12353745.html"  target="_blank" rel="noopener">Java泛型 自限定类型(Self-Bound Types)详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://www.zhihu.com/question/20928981/answer/117521433"  target="_blank" rel="noopener">java为什么不支持泛型数组？ - 胖君的回答 - 知乎</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82String.intern()/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">彻底搞懂String.intern()</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"><span class="paginator-prev__text">访问控制</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型定义"><span class="toc-number">1.</span> <span class="toc-text">
          泛型定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么有泛型"><span class="toc-number">2.</span> <span class="toc-text">
          为什么有泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型擦除type-erasure"><span class="toc-number">3.</span> <span class="toc-text">
          类型擦除(type erasure)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型的使用"><span class="toc-number">4.</span> <span class="toc-text">
          泛型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型类"><span class="toc-number">4.1.</span> <span class="toc-text">
          泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型接口"><span class="toc-number">4.2.</span> <span class="toc-text">
          泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型方法"><span class="toc-number">4.3.</span> <span class="toc-text">
          泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型方法的基本用法"><span class="toc-number">4.3.1.</span> <span class="toc-text">
          泛型方法的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型类中的泛型方法"><span class="toc-number">4.3.2.</span> <span class="toc-text">
          泛型类中的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型方法与可变参数"><span class="toc-number">4.3.3.</span> <span class="toc-text">
          泛型方法与可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法与泛型"><span class="toc-number">4.3.4.</span> <span class="toc-text">
          静态方法与泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型方法使用原则"><span class="toc-number">4.3.5.</span> <span class="toc-text">
          泛型方法使用原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#协变与逆变"><span class="toc-number">5.</span> <span class="toc-text">
          协变与逆变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">5.1.</span> <span class="toc-text">
          定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型通配符"><span class="toc-number">5.2.</span> <span class="toc-text">
          类型通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协变"><span class="toc-number">5.3.</span> <span class="toc-text">
          协变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逆变"><span class="toc-number">5.4.</span> <span class="toc-text">
          逆变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pecs"><span class="toc-number">5.5.</span> <span class="toc-text">
          PECS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自限定泛型与协变"><span class="toc-number">6.</span> <span class="toc-text">
          自限定泛型与协变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#自限定泛型"><span class="toc-number">6.1.</span> <span class="toc-text">
          自限定泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自限定类型的作用产生参数协变"><span class="toc-number">6.2.</span> <span class="toc-text">
          自限定类型的作用：产生参数协变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">6.3.</span> <span class="toc-text">
          小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型嵌套"><span class="toc-number">7.</span> <span class="toc-text">
          泛型嵌套</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型数组"><span class="toc-number">8.</span> <span class="toc-text">
          泛型数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注意事项"><span class="toc-number">9.</span> <span class="toc-text">
          注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#extends-a-和-t-extends-a"><span class="toc-number">9.1.</span> <span class="toc-text">
          &lt;? extends A&gt;  和 &lt;T extends A&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#t-extends-comparable-super-t"><span class="toc-number">9.2.</span> <span class="toc-text">
          &lt;T extends Comparable&lt;? super T&gt;&gt;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">10.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">314</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>