<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="概述                            什么是序列化和反序列化        序列化：把对象转换为字节序列的过程称为对象的序列化。 反序列化：把字节序列恢复为对象的过程称为对象的反序列化。">
<meta property="og:type" content="article">
<meta property="og:title" content="序列化和反序列化">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="概述                            什么是序列化和反序列化        序列化：把对象转换为字节序列的过程称为对象的序列化。 反序列化：把字节序列恢复为对象的过程称为对象的反序列化。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-16T16:22:27.610Z">
<meta property="article:modified_time" content="2020-09-16T16:22:27.625Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>序列化和反序列化 | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">序列化和反序列化</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">9.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">74分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h1>
      

        <h2 id="什么是序列化和反序列化"   >
          <a href="#什么是序列化和反序列化" class="heading-link"><i class="fas fa-link"></i></a>什么是序列化和反序列化</h2>
      
<p><strong>序列化</strong>：把对象转换为字节序列的过程称为对象的序列化。<br />
<strong>反序列化</strong>：把字节序列恢复为对象的过程称为对象的反序列化。</p>
<a id="more"></a>

        <h2 id="序列化和反序列化的方式"   >
          <a href="#序列化和反序列化的方式" class="heading-link"><i class="fas fa-link"></i></a>序列化和反序列化的方式</h2>
      
<p>序列化和反序列化有很多种方式，如JDK类库中提供的序列化API、常用的json工具类等。</p>
<p>常用的Netty消息序列化有三种方式</p>
<ol>
<li>
<p>java原生序列化</p>
</li>
<li>
<p>Kryo序列化</p>
<p>出于应对高并发场景下，频繁地创建、销毁序列化对象，会非常消耗JVM的内存资源、以及时间。Kryo的这个发行版本中，集成引入了序列化对象池功能模块</p>
</li>
<li>
<p>Hessian序列化</p>
<p>它比Java原生的序列化、反序列化速度更快、序列化出来的数据也更小。</p>
</li>
</ol>
<p><strong>本篇博客使用JDK提供的序列化API进行演示</strong>。</p>

        <h2 id="使用场景"   >
          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a>使用场景</h2>
      
<ol>
<li>对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li>
<li>在网络上传送对象的字节序列。(套接字、RMI)</li>
</ol>
<p>在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p>

        <h1 id="demo"   >
          <a href="#demo" class="heading-link"><i class="fas fa-link"></i></a>Demo</h1>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>Java的序列化与反序列化主要靠ObjectOutputStream类和ObjectInputStream类完成</span>，具体使用看代码：</p>
<p>假设现在有一个Student类，我们要对Student类进行序列化操作</p>
<ol>
<li>
<p>该类必须实现Serializable接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private static final long serialVersionUID = -1878312494322761806L;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">  <span class="comment">// 留作测试用</span></span><br><span class="line"><span class="comment">//    private int number;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public int getNumber() &#123;</span></span><br><span class="line"><span class="comment">//        return number;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public void setNumber(int number) &#123;</span></span><br><span class="line"><span class="comment">//        this.number = number;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>在main方法中执行序列化和反序列化操作</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STUDENT_PATH = <span class="string">"/tmp/com.eh/student.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"张三"</span>);</span><br><span class="line">        student.setSex(<span class="string">"男"</span>);</span><br><span class="line">        serialize(student, STUDENT_PATH);</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        Student student1 = deserialize(STUDENT_PATH);</span><br><span class="line">        System.out.println(student1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object o, String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(path)));</span><br><span class="line">        oos.writeObject(o);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path)));</span><br><span class="line">        T result = (T) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>运行结果</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;张三&#39;, sex&#x3D;&#39;男&#39;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="serialversionuid"   >
          <a href="#serialversionuid" class="heading-link"><i class="fas fa-link"></i></a>serialVersionUID</h1>
      
<p>serialVersionUID: 字面意思上是序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量。</p>

        <h2 id="为什么要serialversionuid"   >
          <a href="#为什么要serialversionuid" class="heading-link"><i class="fas fa-link"></i></a>为什么要serialVersionUID</h2>
      

        <h3 id="测试没有serialversionuid"   >
          <a href="#测试没有serialversionuid" class="heading-link"><i class="fas fa-link"></i></a>测试没有serialVersionUID</h3>
      
<ol>
<li>去掉serialVersionUID</li>
<li>执行main方法完成序列化</li>
<li>Student类添加number字段</li>
<li>只执行反序列化方法</li>
</ol>
<p>运行结果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.io.InvalidClassException: com.eh.ftd.serilizable.Student; local class incompatible: stream classdesc serialVersionUID = 3185747638984008850, local class serialVersionUID = 860752566878207064</span><br><span class="line">	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">616</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1630</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1521</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">1781</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1353</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">373</span>)</span><br><span class="line">	at com.eh.ftd.serilizable.SerializableDemo.deserialize(SerializableDemo.java:<span class="number">33</span>)</span><br><span class="line">	at com.eh.ftd.serilizable.SerializableDemo.main(SerializableDemo.java:<span class="number">21</span>)</span><br></pre></td></tr></table></div></figure>
<p>意思是原来序列化的时候（没有指定serialVersionUID）硬盘存的class的 serialVersionUID = 3185747638984008850，而当前class的serialVersionUID = 860752566878207064。 二者不一样，无法反序列化。</p>

        <h3 id="原因分析"   >
          <a href="#原因分析" class="heading-link"><i class="fas fa-link"></i></a>原因分析</h3>
      
<p>serialVersionUID没有指定时，java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件 多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个number字段后，由于没有显指定 serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。</p>

        <h3 id="指定serialversionuid测试"   >
          <a href="#指定serialversionuid测试" class="heading-link"><i class="fas fa-link"></i></a>指定serialVersionUID测试</h3>
      
<p>如果为Student类显示的指定**serialVersionUID，**那么在序列化和反序列化的时候，即使修改了Student类中的部分内容，也能序列化成功。</p>

        <h2 id="serialversionuid的取值"   >
          <a href="#serialversionuid的取值" class="heading-link"><i class="fas fa-link"></i></a>serialVersionUID的取值</h2>
      
<p>serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。</p>
<p>类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。<span style='color:red;background:背景颜色;font-size:文字大小;'><strong>为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值</strong></span>。</p>
<p>显式地定义serialVersionUID有两种用途：</p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li>
<li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li>
</ol>

        <h2 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a>注意事项</h2>
      
<ol>
<li>
<p>有两个接口可以用来实现序列化，分别是Serializable和它的子接口Externalizable，后面会详细介绍</p>
</li>
<li>
<p>序列化的对象其属性必须也可以被序列化，即也实现序列化接口，<span style='color:red;background:背景颜色;font-size:文字大小;'>static变量和transient关键字修饰的变量不会被序列化(前提是使用默认的序列化机制)</span>，因此如果不想让某些变量序列化可以这么做，基本类型默认可以序列化。</p>
<p>这里有一个误区：如果声明的类没有实现序列化接口，但是给它赋值的对象实现了也是可以的,主要还是看具体的对象，像这样</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectOutputStream oops = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        oops.writeObject(<span class="keyword">new</span> Test(<span class="keyword">new</span> B()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>要序列化的对象的父类如果实现序列化接口，那么也会同时序列化其父类，反序列化时不会调用构造函数；没有实现的话就不会序列化父类，但是在反序列化的时候会<strong>调用父类中满足条件的无参构造方法进行创建对象</strong>，因为要实例化子类必须先实例化其父类；</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的有参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(i);</span><br><span class="line">        System.out.println(<span class="string">"子类的有参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectOutputStream oops = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        oops.writeObject(<span class="keyword">new</span> Test(<span class="number">1</span>));</span><br><span class="line">        ObjectInputStream oips = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        Object object = oips.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">父类的有参构造</span><br><span class="line">子类的有参构造</span><br><span class="line">父类的无参构造</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>反序列化时读取的顺序要和序列化时保存的顺序一致。</p>
</li>
</ol>

        <h1 id="源码解析"   >
          <a href="#源码解析" class="heading-link"><i class="fas fa-link"></i></a>源码解析</h1>
      

        <h2 id="序列化"   >
          <a href="#序列化" class="heading-link"><i class="fas fa-link"></i></a>序列化</h2>
      
<p>ObjectStreamClass类<br />
官方文档对这个类的介绍如下</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serialization’s descriptor for classes. It contains the name and serialVersionUID of the class. The ObjectStreamClass for a specific class loaded in this Java VM can be found&#x2F;created using the lookup method.</span><br></pre></td></tr></table></div></figure>
<p>可以看到ObjectStreamClass这个是类的序列化描述符，这个类可以描述需要被序列化的类的元数据，包括被序列化的类的名字以及序列号。可以通过lookup()方法来查找/创建在这个JVM中加载的特定的ObjectStreamClass对象。</p>
<p>序列化:writeObject()</p>
<p>在调用writeObject()进行序列化之前会先调用ObjectOutputStream的构造函数生成一个ObjectOutputStream对象，构造函数如下:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        verifySubclass();</span><br><span class="line">        <span class="comment">// bout表示底层的字节数据容器</span></span><br><span class="line">        bout = <span class="keyword">new</span> BlockDataOutputStream(out);</span><br><span class="line">        handles = <span class="keyword">new</span> HandleTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">        subs = <span class="keyword">new</span> ReplaceTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">        enableOverride = <span class="keyword">false</span>;</span><br><span class="line">        writeStreamHeader();<span class="comment">// 写入文件头</span></span><br><span class="line">        bout.setBlockDataMode(<span class="keyword">true</span>);<span class="comment">// flush数据</span></span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack = <span class="keyword">new</span> DebugTraceInfoStack();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugInfoStack = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>构造函数中首先会把bout绑定到底层的字节数据容器，接着会调用writeStreamHeader()方法,</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bout.writeShort(STREAM_MAGIC);</span><br><span class="line">    bout.writeShort(STREAM_VERSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在writeStreamHeader()方法中首先会往底层字节容器中写入表示序列化的Magic Number以及版本号，接下来会调用writeObject()方法进行序列化,</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 开始序列化</span></span><br><span class="line">        writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>一般会调用writeObject0()进行序列化操作,</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        Object orig = obj;</span><br><span class="line">        <span class="comment">// 获取要序列化的对象的Class对象</span></span><br><span class="line">        Class cl = obj.getClass();</span><br><span class="line">        ObjectStreamClass desc;</span><br><span class="line">        <span class="comment">//这是一个循环，目的是判断writeReplace()返回的对象中是否还有这个方法，一直到最后需要序列化的那个对象，并返回这个对象。</span></span><br><span class="line">    	<span class="comment">//这就是我们可以自定义具体序列化哪个对象！！！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Class repCl;</span><br><span class="line">            <span class="comment">// 创建描述cl的ObjectStreamClass对象！这也是重点下面分析</span></span><br><span class="line">            desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//如果有writeReplace()就通过反射执行,方法会返回一个Object对象，如果返回的这个对象的类和本类相同，就不重复执行writeReplace()</span></span><br><span class="line">            <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                    (repCl = obj.getClass()) == cl)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果是字符串、数组、枚举、实现了Serializable接口的对象可以序列化，其余的不可以！！！</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            writeEnum((Enum) obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            <span class="comment">// 被序列化对象实现了Serializable接口</span></span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>这里解释了为什么序列化的对象只要实现Serializbale接口就能够进行序列化。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br></pre></td></tr></table></div></figure>
<p><strong>lookup()主要为了创建一个描述对象，看看它的构造方法</strong>：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;<span class="comment">//cl为需要序列化对象的类对象</span></span><br><span class="line">        <span class="keyword">this</span>.cl = cl;</span><br><span class="line">        name = cl.getName();</span><br><span class="line">        isProxy = Proxy.isProxyClass(cl);</span><br><span class="line">        isEnum = Enum<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>)</span>;</span><br><span class="line">        serializable = Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>)</span>;</span><br><span class="line">        externalizable = Externalizable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; superCl = cl.getSuperclass();</span><br><span class="line">        superDesc = (superCl != <span class="keyword">null</span>) ? lookup(superCl, <span class="keyword">false</span>) : <span class="keyword">null</span>;</span><br><span class="line">        localDesc = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">                        suid = Long.valueOf(<span class="number">0</span>);</span><br><span class="line">                        fields = NO_FIELDS;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                        fields = NO_FIELDS;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    suid = getDeclaredSUID(cl); <span class="comment">// 1. 获取serialVersionUID</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">//获取实现Serializable接口对象的字段，实现Externalizable的为空字段</span></span><br><span class="line">                    	<span class="comment">//没有声明序列化字段的，则获取默认的序列化字段！！！就是除了static和transient修饰的其他字段</span></span><br><span class="line">                        fields = getSerialFields(cl); <span class="comment">// 2</span></span><br><span class="line">                        computeFieldOffsets();<span class="comment">//Calculates and sets serializable field offsets</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InvalidClassException e) &#123;</span><br><span class="line">                        serializeEx = deserializeEx =</span><br><span class="line">                            <span class="keyword">new</span> ExceptionInfo(e.classname, e.getMessage());</span><br><span class="line">                        fields = NO_FIELDS;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">                    	<span class="comment">//！！！！看它源码</span></span><br><span class="line">                        cons = getExternalizableConstructor(cl);<span class="comment">// 3</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    	<span class="comment">//！！！！看它源码</span></span><br><span class="line">                        cons = getSerializableConstructor(cl);<span class="comment">// 4</span></span><br><span class="line">                        <span class="comment">//定义了writeObject、readObject、readObjectNoData</span></span><br><span class="line">                        writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                            <span class="title">Void</span>.<span class="title">TYPE</span>)</span>; <span class="comment">// 5</span></span><br><span class="line">                        readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                            <span class="title">Void</span>.<span class="title">TYPE</span>)</span>;</span><br><span class="line">                        readObjectNoDataMethod = getPrivateMethod(</span><br><span class="line">                            cl, <span class="string">"readObjectNoData"</span>, <span class="keyword">null</span>, Void.TYPE);</span><br><span class="line">                        hasWriteObjectData = (writeObjectMethod != <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//定义writeReplace、readResolve</span></span><br><span class="line">                    writeReplaceMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"writeReplace"</span>, <span class="keyword">null</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 6</span></span><br><span class="line">                    readResolveMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"readResolve"</span>, <span class="keyword">null</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            suid = Long.valueOf(<span class="number">0</span>);</span><br><span class="line">            fields = NO_FIELDS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fieldRefl = getReflector(fields, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidClassException ex) &#123;</span><br><span class="line">            <span class="comment">// field mismatches impossible when matching local fields vs. self</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deserializeEx == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">                deserializeEx = <span class="keyword">new</span> ExceptionInfo(name, <span class="string">"enum type"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cons == <span class="keyword">null</span>) &#123;</span><br><span class="line">                deserializeEx = <span class="keyword">new</span> ExceptionInfo(name, <span class="string">"no valid constructor"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fields[i].getField() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultSerializeEx = <span class="keyword">new</span> ExceptionInfo(</span><br><span class="line">                    name, <span class="string">"unmatched serializable field(s) declared"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>
<p>//1<br />
getDeclaredSUID()方法，通过反射拿到声明的serialVersionUID字段的值，并且这个字段必须是static final修饰的：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Long <span class="title">getDeclaredSUID</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = cl.getDeclaredField(<span class="string">"serialVersionUID"</span>);</span><br><span class="line">            <span class="keyword">int</span> mask = Modifier.STATIC | Modifier.FINAL; <span class="comment">//int mask = 8 | 16</span></span><br><span class="line">            <span class="keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;</span><br><span class="line">                f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> Long.valueOf(f.getLong(<span class="keyword">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>如果未声明serialVersionUID又对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。</p>
<p>类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。</p>
<p>显式地定义serialVersionUID有两种用途：</p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li>
<li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li>
</ol>
</li>
<li>
<p>//2</p>
<p>getSerialFields</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)</span><br><span class="line">        <span class="keyword">throws</span> InvalidClassException</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectStreamField[] fields;</span><br><span class="line">        <span class="keyword">if</span> (Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">            !<span class="title">Externalizable</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">            !<span class="title">Proxy</span>.<span class="title">isProxyClass</span>(<span class="title">cl</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">            !<span class="title">cl</span>.<span class="title">isInterface</span>())</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">          <span class="comment">// 先获取声明的private static final ObjectStreamField[] serialPersistentFields = …;如果未声明就去获取默认的序列化字段。换句话说如果声明了这个字段，就不会去序列化类中的属性字段。</span></span><br><span class="line">            <span class="keyword">if</span> ((fields = getDeclaredSerialFields(cl)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fields = getDefaultSerialFields(cl);</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.sort(fields);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fields = NO_FIELDS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>getDeclaredSerialFields</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl)</span><br><span class="line">        <span class="keyword">throws</span> InvalidClassException</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectStreamField[] serialPersistentFields = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = cl.getDeclaredField(<span class="string">"serialPersistentFields"</span>);</span><br><span class="line">            <span class="keyword">int</span> mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;</span><br><span class="line">            <span class="keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;</span><br><span class="line">                f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                serialPersistentFields = (ObjectStreamField[]) f.get(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serialPersistentFields == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serialPersistentFields.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_FIELDS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamField[] boundFields =</span><br><span class="line">            <span class="keyword">new</span> ObjectStreamField[serialPersistentFields.length];</span><br><span class="line">        Set&lt;String&gt; fieldNames = <span class="keyword">new</span> HashSet&lt;&gt;(serialPersistentFields.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; serialPersistentFields.length; i++) &#123;</span><br><span class="line">            ObjectStreamField spf = serialPersistentFields[i];</span><br><span class="line"></span><br><span class="line">            String fname = spf.getName();</span><br><span class="line">            <span class="comment">//不能重复定义相同的字段</span></span><br><span class="line">            <span class="keyword">if</span> (fieldNames.contains(fname)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                    <span class="string">"multiple serializable fields named "</span> + fname);</span><br><span class="line">            &#125;</span><br><span class="line">            fieldNames.add(fname);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Field f = cl.getDeclaredField(fname);</span><br><span class="line">                <span class="keyword">if</span> ((f.getType() == spf.getType()) &amp;&amp;</span><br><span class="line">                    ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>))<span class="comment">//声明指定要序列化的字段必须类型和名字要和实际的对应，且不能是static字段</span></span><br><span class="line">                &#123;</span><br><span class="line">                    boundFields[i] =</span><br><span class="line">                        <span class="keyword">new</span> ObjectStreamField(f, spf.isUnshared(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果声明的字段不存在，或与实际字段类型不符，或为static字段，</span></span><br><span class="line">            <span class="keyword">if</span> (boundFields[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                boundFields[i] = <span class="keyword">new</span> ObjectStreamField(</span><br><span class="line">                    fname, spf.getType(), spf.isUnshared());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> boundFields;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>static和transient字段不能被序列化。序列化的时候所有的数据都是来自于ObjectStreamClass对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;</span><br><span class="line">    Field[] clFields = cl.getDeclaredFields();</span><br><span class="line">    ArrayList&lt;ObjectStreamField&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> mask = Modifier.STATIC | Modifier.TRANSIENT;<span class="comment">//int mask = 8|128;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clFields.length; i++) &#123;</span><br><span class="line">    	<span class="comment">// 说明字段既不是static也不是transient的才会被加入到需要被序列化字段列表中去</span></span><br><span class="line">        <span class="keyword">if</span> ((clFields[i].getModifiers() &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ObjectStreamField(clFields[i], <span class="keyword">false</span>, <span class="keyword">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? NO_FIELDS :</span><br><span class="line">        list.toArray(<span class="keyword">new</span> ObjectStreamField[size]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>从上面的代码中可以很明显的看到，在计算需要被序列化的字段的时候会把被static和transient修饰的字段给过滤掉。</p>
</li>
<li>
<p>//3</p>
<p>如果实现的是Externalizable接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Constructor <span class="title">getExternalizableConstructor</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor cons = cl.getDeclaredConstructor((Class&lt;?&gt;[]) <span class="keyword">null</span>); <span class="comment">//3.1</span></span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> ((cons.getModifiers() &amp; Modifier.PUBLIC) != <span class="number">0</span>) ? </span><br><span class="line">                cons : <span class="keyword">null</span>;<span class="comment">//3.2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>Modifier.PUBLIC = 1,从//3.1和//3.2可以知道<strong>一个实现Externalizable接口的类要有一个公有的无参构造函数</strong>，主要在反序列化的时候需要。</p>
</li>
<li>
<p>//4</p>
<p>一个类实现了Serializable但未实现Externalizable时，获取第一个未实现序列化接口的类的无参构造函数，修饰符满足下面条件，一定需要一个非私有的无参构造函数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Constructor <span class="title">getSerializableConstructor</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; initCl = cl;</span><br><span class="line">        <span class="comment">//找到其父类中第一个未实现Serializable接口的类（Object类的父类为空）</span></span><br><span class="line">        <span class="keyword">while</span> (Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">initCl</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((initCl = initCl.getSuperclass()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor cons = initCl.getDeclaredConstructor((Class&lt;?&gt;[]) <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> mods = cons.getModifiers();</span><br><span class="line">  <span class="comment">//父类的无参构造函数不能是private的，可以是public和protected的，如果是默认的访问修饰符，那么一定需要和当前序列化对象在同一个包下</span></span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) != <span class="number">0</span> ||</span><br><span class="line">                ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                <span class="comment">//返回ture，如果这个父类和当前对象在同一个包下，否则返回false</span></span><br><span class="line">                 !packageEquals(cl, initCl)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cons = reflFactory.newConstructorForSerialization(cl, cons);</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> cons;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>//5</p>
<p>获取操作对象的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">getPrivateMethod</span><span class="params">(Class&lt;?&gt; cl, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Class&lt;?&gt;[] argTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Class&lt;?&gt; returnType)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method meth = cl.getDeclaredMethod(name, argTypes);</span><br><span class="line">            meth.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">int</span> mods = meth.getModifiers();</span><br><span class="line">            <span class="keyword">return</span> ((meth.getReturnType() == returnType) &amp;&amp;</span><br><span class="line">                    ((mods &amp; Modifier.STATIC) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                    ((mods &amp; Modifier.PRIVATE) != <span class="number">0</span>)) ? meth : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>方法是private的，返回类型为returnType，且是非static。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span></span></span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>//6</p>
<p>获取方法 writeReplace/readResolve</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">getInheritableMethod</span><span class="params">(Class&lt;?&gt; cl, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Class&lt;?&gt;[] argTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               Class&lt;?&gt; returnType)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Method meth = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; defCl = cl;</span><br><span class="line">        <span class="comment">//从本类开始向上一直找这个方法</span></span><br><span class="line">        <span class="keyword">while</span> (defCl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                meth = defCl.getDeclaredMethod(name, argTypes);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">                defCl = defCl.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((meth == <span class="keyword">null</span>) || (meth.getReturnType() != returnType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        meth.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> mods = meth.getModifiers();</span><br><span class="line">        <span class="comment">//方法不能是static和abstract的</span></span><br><span class="line">        <span class="keyword">if</span> ((mods &amp; (Modifier.STATIC | Modifier.ABSTRACT)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//可以是public和protected修饰的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> meth;</span><br><span class="line">        <span class="comment">//如果修饰符是private的，那这个方法必须在序列化对象的当前类中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (cl == defCl) ? meth : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果采用默认修饰符，那么这个方法所在的类必须和序列化对象的当前类在同一个包下</span></span><br><span class="line">            <span class="keyword">return</span> packageEquals(cl, defCl) ? meth : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>两种事例：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">writeReplace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Obejct <span class="title">readResolve</span><span class="params">()</span></span></span><br></pre></td></tr></table></div></figure>
</li>
</ul>
<p>序列化过程接下来会执行到writeOrdinaryObject()这个方法中，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line"> </span><br><span class="line">        bout.writeByte(TC_OBJECT); <span class="comment">// 写入Object标志位</span></span><br><span class="line">        writeClassDesc(desc, <span class="keyword">false</span>); <span class="comment">// 写入类元数据</span></span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);<span class="comment">//写入实现Externalizable接口的对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeSerialData(obj, desc); <span class="comment">// 写入被序列化的对象的实例数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在这个方法中首先会往底层字节容器中写入TC_OBJECT，表示这是一个新的Object</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_OBJECT =       (<span class="keyword">byte</span>)<span class="number">0x73</span>;</span><br></pre></td></tr></table></div></figure>
<p>接下来会调用writeClassDesc()方法写入被序列化对象的类的类元数据，writeClassDesc()方法实现如下:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> handle;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果desc为null</span></span><br><span class="line">        writeNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123;</span><br><span class="line">        writeProxyDesc(desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeNonProxyDesc(desc, unshared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在这个方法中会先判断传入的desc是否为null，如果为null则调用writeNull()方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// TC_NULL =         (byte)0x70;</span></span><br><span class="line">    <span class="comment">// 表示对一个Object引用的描述的结束</span></span><br><span class="line">    bout.writeByte(TC_NULL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></div></figure>
<p>如果不为null，则一般情况下接下来会调用writeNonProxyDesc()方法，该方法实现如下:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TC_CLASSDESC =    (byte)0x72;</span></span><br><span class="line">    <span class="comment">// 表示一个新的Class描述符</span></span><br><span class="line">    bout.writeByte(TC_CLASSDESC);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : desc);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        <span class="comment">// do not invoke class descriptor write hook with old protocol</span></span><br><span class="line">        desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeClassDescriptor(desc);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Class cl = desc.forClass();</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line">    annotateClass(cl);</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line"> 	<span class="comment">//如果有父类会再去写入父类的描述信息</span></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在这个方法中首先会写入一个字节的TC_CLASSDESC，这个字节表示接下来的数据是一个新的Class描述符，接着会调用writeNonProxy()方法写入实际的类元信息，writeNonProxy()实现如下:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeUTF(name); <span class="comment">// 写入类的名字</span></span><br><span class="line">    out.writeLong(getSerialVersionUID()); <span class="comment">// 写入类的序列号，当没有声明序列号的时候才会自动生成</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">byte</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取类的标识</span></span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;</span><br><span class="line">        <span class="keyword">int</span> protocol = out.getProtocolVersion();</span><br><span class="line">        <span class="keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            flags |= ObjectStreamConstants.SC_BLOCK_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasWriteObjectData) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_WRITE_METHOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeByte(flags); <span class="comment">// 写入类的flag</span></span><br><span class="line"> </span><br><span class="line">    out.writeShort(fields.length); <span class="comment">// 写入对象的字段的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        ObjectStreamField f = fields[i];</span><br><span class="line">        out.writeByte(f.getTypeCode());<span class="comment">//写入字段的类型</span></span><br><span class="line">        out.writeUTF(f.getName());<span class="comment">//写入字段的名字（先写名字所占的utf编码的长度，再写名字）</span></span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            <span class="comment">// 如果不是基本类型，即是class、Interface、array</span></span><br><span class="line">            <span class="comment">// 则会写入表示对象或者类的类型字符串</span></span><br><span class="line">            out.writeTypeString(f.getTypeString());</span><br><span class="line">            <span class="comment">//f.getTypeString()返回jvm类型标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果被写入的字段不是基本类型，则会接着调用writeTypeString()方法写入代表对象或者类的类型字符串，该方法需要一个参数，表示对应的类或者接口的字符串，最终调用的还是writeString()方法，实现如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : str);</span><br><span class="line">    <span class="keyword">long</span> utflen = bout.getUTFLength(str);</span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">        <span class="comment">// final static byte TC_STRING = (byte)0x74;</span></span><br><span class="line">        <span class="comment">// 表示接下来的字节表示一个字符串</span></span><br><span class="line">        bout.writeByte(TC_STRING);</span><br><span class="line">        bout.writeUTF(str, utflen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bout.writeByte(TC_LONGSTRING);</span><br><span class="line">        bout.writeLongUTF(str, utflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在这个方法中会先写入一个标志位TC_STRING表示接下来的数据是一个字符串，接着会调用writeUTF()写入字符串。</p>
<p>执行完上面的过程之后，程序流程重新回到writeNonProxyDesc()方法中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// TC_ENDBLOCKDATA = (byte)0x78;</span></span><br><span class="line">    <span class="comment">// 表示对一个object的描述块的结束</span></span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line"> </span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="keyword">false</span>); <span class="comment">// 递归调用，写入父类的类元数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>需要注意的是writeClassDesc()这个方法是个递归调用，调用结束返回的条件是没有父类，即传入的ObjectStreamClass对象为null，这个时候会写入一个字节的标识位TC_NULL，可以看ObjectStreamClass的构造方法。</p>
<p>在递归调用完成写入类的类元数据之后，程序执行流程回到wriyeOrdinaryObject()方法中，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line">        <span class="comment">// 其他省略代码</span></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeSerialData(obj, desc); <span class="comment">// 写入被序列化的对象的实例数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>从上面的分析中我们可以知道，当写入类的元数据的时候，是先写子类的类元数据，然后递归调用的写入父类的类元数据。<br />
接下来会调用writeSerialData()方法写入被序列化的对象的字段的数据，方法实现如下:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取表示被序列化对象的数据的布局的ClassDataSlot数组，父类在前</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">           <span class="comment">// 如果被序列化对象自己实现了writeObject()方法，则执行if块里的代码</span></span><br><span class="line"> </span><br><span class="line">           <span class="comment">// 一些省略代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用默认的方法写入实例数据</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在这个方法中首先会调用getClassDataLayout()方法获取被序列化对象的数据的布局，关于这个方法官方文档中说明如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns array of ClassDataSlot instances representing the data layout</span></span><br><span class="line"><span class="comment"> * (including superclass data) for serialized objects described by this</span></span><br><span class="line"><span class="comment"> * class descriptor.  ClassDataSlots are ordered by inheritance with those</span></span><br><span class="line"><span class="comment"> * containing "higher" superclasses appearing first.  The final</span></span><br><span class="line"><span class="comment"> * ClassDataSlot contains a reference to this descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> ClassDataSlot[] getClassDataLayout() <span class="keyword">throws</span> InvalidClassException;</span><br></pre></td></tr></table></div></figure>
<p>需要注意的是这个方法会把从父类继承的数据一并返回，并且表示从父类继承的数据的ClassDataSlot对象在数组的最前面。</p>
<p>对于没有自定义writeObject()方法的对象来说，接下来会调用defaultWriteFields()方法写入数据，该方法实现如下:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其他一些省略代码</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取对应类中的基本数据类型的数据并保存在primVals字节数组中(底层通过Unsafe的原子操作完成)</span></span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    <span class="comment">// 把基本数据类型的数据写入底层字节容器中</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取对应类的所有的字段对象</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    <span class="comment">// 把对应类的Object类型(非基本类型)的对象值保存到objVals数组中</span></span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 一些省略的代码</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对所有Object类型的字段递归调用writeObject0()方法写入对应的数据</span></span><br><span class="line">            writeObject0(objVals[i],</span><br><span class="line">                         fields[numPrimFields + i].isUnshared());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到，在这个方法中会做下面几件事情:</p>
<ol>
<li>获取对应类的基本类型的字段的数据，并写入到底层的字节容器中。</li>
<li>获取对应类的Object类型(非基本类型)的字段成员，递归调用writeObject0()方法写入相应的数据，因此也需要实现序列化接口。</li>
</ol>
<p>从上面对写入数据的分析可以知道，<strong>写入数据是按照先父类后子类的顺序</strong>来写的。</p>

        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h3>
      
<p><strong>序列化过程</strong>：</p>
<ol>
<li>写入文件头（往底层字节容器中写入表示序列化的Magic Number以及版本号）；</li>
<li>获取要序列化的对象的Class对象，并创建对应描述的ObjectStreamClass对象；</li>
<li>如果这个class的对应描述对象中有writeReplace()方法就执行并返回替换后需要序列化的对象，再继续序列化返回的对象。。。。。。；</li>
<li>如果是对象（除了String、Array、Enum）都要实现序列化接口才可以序列化；</li>
<li>往底层字节容器中写入TC_OBJECT，表示这是一个新的Object；</li>
<li>写入类元数据：<br />
（<strong>当写入类的元数据的时候，是先写子类的类元数据，然后递归调用的写入父类的类元数据（只有实现序列化接口的才会有类元数据）</strong>）<br />
6.1. 如果类元数据为空，就写入TC_NULL，表示引用的描述结束；<br />
6.2. 写入TC_CLASSDESC，表示一个新的Class描述符；<br />
6.3. 写入实际的类元信息：写入类的名字，写入类的序列号，当没有声明序列号的时候才会自动生成，获取类的标识并写 入，写入对象的字段的个数，如果有字段的话，写入字段的类型，写入字段的名字（先写名字所占的utf编码的长度，再写名字），如果不是基本类型，即是class、Interface、array则会写入表示对象或者类的类型字符串；<br />
6.4. 写入TC_ENDBLOCKDATA，表示对一个object的描述块的结束；<br />
6.5. 递归调用，写入父类的类元数据。</li>
<li>看序列化对象实现的是哪个接口：1）如果实现Externalizable就直接执行它的writeExternal()方法；2）<strong>如果实现Serializable，先写父类的数据，再一层层下来</strong>；写的时候如果序列化对象实现了writeObject()方法（要实现序列化的类中有才有效果）就执行这个方法，如果没有实现，就执行默认的序列化方法。默认的序列化方法：获取对应类中的基本数据类型的数据并保存在primVals字节数组中(底层通过Unsafe的原子操作完成)，把基本数据类型的数据写入底层字节容器中，把对应类的Object类型(非基本类型)的对象值保存到objVals数组中，对所有Object类型的字段递归调用writeObject0()方法（序列化对象方法）写入对应的数据。</li>
</ol>
<p><strong>ObjectStreamClass构造函数</strong>：<br />
包含属性：类对象、类名、（代理、枚举、serializable、externalizable、父类的描述对象、当前类的描述对象）、<br />
没有实现序列化接口：序列号为0，序列化字段为空；<br />
实现序列化接口：<br />
1.枚举的序列号为0和字段为空；<br />
2.数组的字段为空；<br />
3.通过反射拿到声明为static final修饰的serialVersionUID字段的值；<br />
4.获取实现Serializable接口的对象的字段，（实现Externalizable的为空字段），先获取声明的private static final ObjectStreamField[] serialPersistentFields，它的规则是“声明指定要序列化的字段必须类型和名字要和实际的对应，且不能是static字段”，如果未声明就去获取默认的序列化字段（就是除了static和transient修饰的其他字段）。换句话说如果声明了这个字段，就不会去序列化类中的属性字段；<br />
5.计算并设置序列化字段偏移量；<br />
6.一个实现Externalizable接口的类要有一个公有的无参构造函数，主要在反序列化的时候需要；<br />
7.一个类实现了Serializable但未实现Externalizable时，找到其父类中第一个未实现Serializable接口的类（Object类的父类为空）的无参构造方法，其规则是“无参构造函数不能是private的，可以是public和protected的，如果是默认的访问修饰符，那么一定需要和当前序列化对象在同一个包下”，因为反序列化时实例化子类必须先实例化其父类；<br />
8.规定了3个方法的格式，方法是private的，返回类型为returnType，且是非static，<br />
private void writeObject(ObjectOutputStream out)<br />
private void readObject(ObjectInputStream in)<br />
private void readObjectNoData()；<br />
9.规定writeReplace、readResolve方法的格式，从当前类开始一直递归查找父类中是否声明了这个方法（只包括方法名、方法参数类型、返回对象类型），直到查询到第一个为止，方法不能是static和abstract的，可以是public和protected修饰的，如果修饰符是private的，那这个方法必须在序列化对象的当前类中，如果采用默认修饰符，那么这个方法所在的类必须和序列化对象的当前类在同一个包下。</p>

        <h2 id="反序列化"   >
          <a href="#反序列化" class="heading-link"><i class="fas fa-link"></i></a>反序列化</h2>
      
<p>反序列化对象时需要调用ObjectInputStream的readObject()方法，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>主要调用readObject0()方法，源码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//根据序列化时写入的标记头，选择对应的反序列化方式</span></span><br><span class="line">            <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">                    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bin.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>主要分析TC_OBJECT的情况，其余的也差不多，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//重复检查标记是否为Object</span></span><br><span class="line">        <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//下面重点讲解</span></span><br><span class="line">        ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">        desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取描述对应的类</span></span><br><span class="line">        Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">        <span class="comment">//排除String、Class、ObjectStreamClass这三个类，序列化时就做了特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span> || <span class="title">cl</span> </span>== Class<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                || <span class="title">cl</span> </span>== ObjectStreamClass<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object obj;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//根据描述数据中的构造函数，利用反射创建对象，构造函数的规则在序列化时已经说明</span></span><br><span class="line">            obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                desc.forClass().getName(),</span><br><span class="line">                <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//两种接口的不同实现</span></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">            readExternalData((Externalizable) obj, desc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//实现Serializable接口的调用</span></span><br><span class="line">            readSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">		<span class="comment">//判断是否存在readResolve()方法</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            desc.hasReadResolveMethod())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//执行并返回替换的对象</span></span><br><span class="line">            Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">            <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">                rep = cloneArray(rep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">                handles.setObject(passHandle, obj = rep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>下面看看readClassDesc()的源码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readClassDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> tc = bin.peekByte();</span><br><span class="line">        <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="keyword">return</span> (ObjectStreamClass) readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">                <span class="keyword">return</span> (ObjectStreamClass) readHandle(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">                <span class="keyword">return</span> readProxyDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">                <span class="keyword">return</span> readNonProxyDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                    String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>对应序列化时，null,reference,proxy和nonProxy的情况，这里主要分析非代理对象的反序列化。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readNonProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//检查写入的是否为非代理对象</span></span><br><span class="line">        <span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">        ...</span><br><span class="line">        ObjectStreamClass readDesc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//获取序列化时保存的描述类元信息,按照序列化时的顺序读取</span></span><br><span class="line">            readDesc = readClassDescriptor();</span><br><span class="line">       	...</span><br><span class="line"></span><br><span class="line">        Class cl = <span class="keyword">null</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checksRequired = isCustomSubclass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//初始化加载描述类代表的序列化类</span></span><br><span class="line">            <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="keyword">null</span>) </span><br><span class="line">            ...</span><br><span class="line">        skipCustomData();</span><br><span class="line">		<span class="comment">//初始化描述类元信息，注意这里又递归调用readClassDesc。我们序列化的时候是先写入子类的类元信息，再写入父类的；反序列化时，也需要先读入子类再父类，因此readClassDesc返回的是父类的类元描述信息，但是具体的初始化类元信息顺序还是先初始化父类再子类。</span></span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>));</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>回到readNonProxyDesc()方法，看看ObjectStreamClass的initNonProxy()方法，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initNonProxy</span><span class="params">(ObjectStreamClass model,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Class&lt;?&gt; cl,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ClassNotFoundException resolveEx,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ObjectStreamClass superDesc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InvalidClassException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//类元数据的各个字段赋值</span></span><br><span class="line">     	...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//当前程序中对应类的类元信息</span></span><br><span class="line">            localDesc = lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//各种字段验证</span></span><br><span class="line">            ...</span><br><span class="line">           </span><br><span class="line">			<span class="comment">//如果当前程序中的序列号和反序列化出来的不相等就报异常</span></span><br><span class="line">            <span class="keyword">if</span> (serializable == localDesc.serializable &amp;&amp;</span><br><span class="line">                !cl.isArray() &amp;&amp;</span><br><span class="line">                suid.longValue() != localDesc.getSerialVersionUID())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(localDesc.name,</span><br><span class="line">                    <span class="string">"local class incompatible: "</span> +</span><br><span class="line">                    <span class="string">"stream classdesc serialVersionUID = "</span> + suid +</span><br><span class="line">                    <span class="string">", local class serialVersionUID = "</span> +</span><br><span class="line">                    localDesc.getSerialVersionUID());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">			<span class="comment">//本地程序中描述的各个方法</span></span><br><span class="line">            cons = localDesc.cons;</span><br><span class="line">            writeObjectMethod = localDesc.writeObjectMethod;</span><br><span class="line">            readObjectMethod = localDesc.readObjectMethod;</span><br><span class="line">            readObjectNoDataMethod = localDesc.readObjectNoDataMethod;</span><br><span class="line">            writeReplaceMethod = localDesc.writeReplaceMethod;</span><br><span class="line">            readResolveMethod = localDesc.readResolveMethod;</span><br><span class="line">            <span class="keyword">if</span> (deserializeEx == <span class="keyword">null</span>) &#123;</span><br><span class="line">                deserializeEx = localDesc.deserializeEx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fieldRefl = getReflector(fields, localDesc);</span><br><span class="line">        <span class="comment">// reassign to matched fields so as to reflect local unshared settings</span></span><br><span class="line">        fields = fieldRefl.getFields();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>回到主方法readOrdinaryObject(),当反序列化实现Serializable接口的对象时</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//从父类开始</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">                	<span class="comment">//如果有readObject()执行</span></span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//如果没有的话就执行默认的反序列化，与序列化类似</span></span><br><span class="line">                defaultReadFields(obj, slotDesc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectData()) &#123;</span><br><span class="line">                skipCustomData();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slotDesc.invokeReadObjectNoData(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="自定义序列化与反序列化"   >
          <a href="#自定义序列化与反序列化" class="heading-link"><i class="fas fa-link"></i></a>自定义序列化与反序列化</h2>
      
<p>序列化的情况太多了，无法一一列举出来，但可以从源码中找到实现的规则，这里给出两个序列化的例子。<br />
实现Serializable：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不写的话会自动生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//声明要序列化的字段，不写才会去序列化默认的字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="keyword">new</span> ObjectStreamField[]&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PersonSingleton</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> PersonSingleton person = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PersonSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (PersonSingleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(person == <span class="keyword">null</span>) </span><br><span class="line">                    <span class="keyword">return</span> person = <span class="keyword">new</span> PersonSingleton(<span class="string">"ljh"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 write replace start"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//可修改为其他对象,序列化这个对象,所以这个对象必须实现序列化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2 write object start"</span>);</span><br><span class="line"><span class="comment">//        out.defaultWriteObject();</span></span><br><span class="line">        <span class="comment">//out.writeInt(1);</span></span><br><span class="line">        out.writeObject(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"3 read object start"</span>);</span><br><span class="line"><span class="comment">//        in.defaultReadObject();</span></span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最主要应用场合就是单例、枚举类型的保护性恢复！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"4 read resolve start"</span>);</span><br><span class="line">        <span class="keyword">return</span> PersonSingleton.getInstance();<span class="comment">//不管序列化的操作是什么，返回的都是本地的单例对象,结果作为readObject()的返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        ObjectOutputStream op = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        op.writeObject(PersonSingleton.getInstance());</span><br><span class="line">        op.close();</span><br><span class="line"></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">        Object person = oi.readObject();</span><br><span class="line">        in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        oi = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">        PersonSingleton person1 = (PersonSingleton) oi.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"sington person hashcode:"</span> + person.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sington person1 hashcode:"</span> + person1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"singleton getInstance hashcode:"</span> + PersonSingleton.getInstance().hashCode());</span><br><span class="line">        System.out.println(<span class="string">"singleton person equals:"</span> + (person == PersonSingleton.getInstance()));</span><br><span class="line">        System.out.println(<span class="string">"person equals1:"</span> + (person1 == person));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>实现Externalizable:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">External</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//没有声明序列化的serialPersistentFields属性，因为被设成了NO_FIELDS</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">External</span><span class="params">(String name, Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//一定要显示的声明一个公有的无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">External</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这两个方法是只要实现了序列化接口都可以声明并执行，但是注意，当源码中判断desc中是否有这个方法的时候，desc代表的这个类一定需要实现序列化接口，但是这个方法却可以声明在未实现序列化接口的父类中，不过要注意访问修饰符，意思就是desc代表的这个类能够调用到</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 write replace start"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//可修改为其他对象,序列化这个对象,所以这个对象必须实现序列化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"4 read resolve start"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        External external = <span class="keyword">new</span> External(<span class="string">"ljh"</span>, <span class="number">24</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        ObjectOutputStream op = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        op.writeObject(external);</span><br><span class="line">        op.close();</span><br><span class="line"></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"G:/serializable.txt"</span>));</span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">        External ex = (External) oi.readObject();</span><br><span class="line">        System.out.println(ex.name + <span class="string">" "</span> + ex.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="拓展"   >
          <a href="#拓展" class="heading-link"><i class="fas fa-link"></i></a>拓展</h2>
      
<p>阅读完源码后可能会有个疑惑，就是反序列化中实例化对象的时候明明拿到的是父类中第一个non_serializable的类的无参构造函数，它是怎么拿到这个实例化对象的呢？</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"child"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ReflectionFactory reflFactory =</span><br><span class="line">                AccessController.doPrivileged(</span><br><span class="line">                        <span class="keyword">new</span> ReflectionFactory.GetReflectionFactoryAction());</span><br><span class="line">        Constructor sup = Super<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">        sup = reflFactory.newConstructorForSerialization(Child<span class="class">.<span class="keyword">class</span>, <span class="title">sup</span>)</span>;</span><br><span class="line">        Child child = (Child) sup.newInstance();</span><br><span class="line">        Method m = Super.class.getDeclaredMethod("s");</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(child);</span><br><span class="line">        Method m2 = Super.class.getDeclaredMethod("ss");</span><br><span class="line">        m2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m2.invoke(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Super</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"super"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被子类重写了，反射调用到的是子类实现的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ss</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="keyword">super</span></span><br><span class="line">s</span><br><span class="line">cc</span><br></pre></td></tr></table></div></figure>
<p>调用反射工厂的方法并没有执行子类的构造函数，但的的确确生成了子类对象。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h1>
      
<p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/qq_36744284/article/details/89604011"  target="_blank" rel="noopener">java中的序列化与反序列化及其源码分析（特别详细）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">深浅拷贝</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/200_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/java%E5%9F%BA%E7%A1%80/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82String.intern()/"><span class="paginator-prev__text">彻底搞懂String.intern()</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">
          概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是序列化和反序列化"><span class="toc-number">1.1.</span> <span class="toc-text">
          什么是序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化和反序列化的方式"><span class="toc-number">1.2.</span> <span class="toc-text">
          序列化和反序列化的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用场景"><span class="toc-number">1.3.</span> <span class="toc-text">
          使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#demo"><span class="toc-number">2.</span> <span class="toc-text">
          Demo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#serialversionuid"><span class="toc-number">3.</span> <span class="toc-text">
          serialVersionUID</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要serialversionuid"><span class="toc-number">3.1.</span> <span class="toc-text">
          为什么要serialVersionUID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试没有serialversionuid"><span class="toc-number">3.1.1.</span> <span class="toc-text">
          测试没有serialVersionUID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原因分析"><span class="toc-number">3.1.2.</span> <span class="toc-text">
          原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定serialversionuid测试"><span class="toc-number">3.1.3.</span> <span class="toc-text">
          指定serialVersionUID测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#serialversionuid的取值"><span class="toc-number">3.2.</span> <span class="toc-text">
          serialVersionUID的取值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意事项"><span class="toc-number">3.3.</span> <span class="toc-text">
          注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码解析"><span class="toc-number">4.</span> <span class="toc-text">
          源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化"><span class="toc-number">4.1.</span> <span class="toc-text">
          序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">4.1.1.</span> <span class="toc-text">
          小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反序列化"><span class="toc-number">4.2.</span> <span class="toc-text">
          反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义序列化与反序列化"><span class="toc-number">4.3.</span> <span class="toc-text">
          自定义序列化与反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拓展"><span class="toc-number">4.4.</span> <span class="toc-text">
          拓展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">335</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>