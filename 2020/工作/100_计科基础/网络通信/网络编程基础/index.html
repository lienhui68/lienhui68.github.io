<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/assets/1.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="原文：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;swordfall&#x2F;p&#x2F;10781281.html                      概述        计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来的，实现资源共享和数据传输的系统。网络编程就是编写程序使互联网的两个或多个设备（如计算机）之间进行数据传输。Java语言对网络编程提供了良好的支">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程基础">
<meta property="og:url" content="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/100_%E8%AE%A1%E7%A7%91%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="lienhui68の博客">
<meta property="og:description" content="原文：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;swordfall&#x2F;p&#x2F;10781281.html                      概述        计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来的，实现资源共享和数据传输的系统。网络编程就是编写程序使互联网的两个或多个设备（如计算机）之间进行数据传输。Java语言对网络编程提供了良好的支">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827212503.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827212826.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827213629.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827214121.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827214242.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827214927.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827215746.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827220215.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827221148.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827221815.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827221938.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222001.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222019.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222045.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222118.png">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/aHR0cDovL3d3dy41MmltLm5ldC9kYXRhL2F0dGFjaG1lbnQvZm9ydW0vMjAxODA3LzA1LzExMzYwN2RiN2IzaDZoNzcyYndod2suZ2lm.gif">
<meta property="og:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/aHR0cDovL3d3dy41MmltLm5ldC9kYXRhL2F0dGFjaG1lbnQvZm9ydW0vMjAxODA3LzA1LzExMzcwMm5qZ2Z3MmZremoza2tqamYuZ2lm.gif">
<meta property="article:published_time" content="2020-09-16T16:21:55.293Z">
<meta property="article:modified_time" content="2020-09-16T16:21:55.300Z">
<meta property="article:author" content="lienhui68">
<meta property="article:tag" content="网络通信">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lienhui68/picStore/raw/master/null/20200827212503.png"><meta name="keywords" content="lienhui68, lienhui68の博客"><meta name="description" content=""><title>网络编程基础 | lienhui68の博客</title><link ref="canonical" href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/100_%E8%AE%A1%E7%A7%91%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: undefined,
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-flask"></i></span><span class="header-nav-menu-item__text">实验室</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/photo/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/music/"><span class="header-nav-submenu-item__icon"><i class="fas fa-music"></i></span><span class="header-nav-submenu-item__text">音乐</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">网络编程基础</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">9.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">54分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><blockquote>
<p>原文：<span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/swordfall/p/10781281.html"  target="_blank" rel="noopener">https://www.cnblogs.com/swordfall/p/10781281.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h1>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来的，实现资源共享和数据传输的系统。</span><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>网络编程就是编写程序使互联网的两个或多个设备（如计算机）之间进行数据传输。</span>Java语言对网络编程提供了良好的支持。通过其提供的接口我们可以很方便地进行网络编程。</p>
<p>计算机网络20世纪60年代出现，经历了20世纪70年代、80年代和90年代的发展，进入21世纪后，计算机网络已经成为信息社会的基础设施，深入到人类社会的方方面面，与人们的工作、学习和生活息息相关。计算机网络分为网络协议和网络体系结构。</p>
<a id="more"></a>

        <h1 id="网络体系结构"   >
          <a href="#网络体系结构" class="heading-link"><i class="fas fa-link"></i></a>网络体系结构</h1>
      
<p>通过网络发送数据是一项复杂的操作，必须仔细地<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>协调网络的物理特性以及所发送数据的逻辑特征</span>。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>通过网络将数据从一台主机发送到另外的主机，这个过程计算机网络通信。</span></p>
<p>网络通信的不同方面被分解为<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>多个层</span>，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>层与层之间用接口连接</span>。通信的双方具有相同的层次，层次实现的功能由<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>协议数据单元（PDU）</span>来描述。不同系统中的同一层构成对等层，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>对等层之间通过对等层协议进行通信</span>，理解层次定义好的规则和约定。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:bold'>每一层表示为物理硬件（即线缆和电流）与所传输信息之间的不同抽象层次</span>。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>在理论上，每一层只与紧挨其上和其下的层对话</span>。将网络分层，这样就可以修改甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响到其他层。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>计算机网络体系结构是计算机网络层次和协议的集合</span>，网络体系结构对计算机网络实现的功能，以及网络协议、层次、接口和服务进行了描述，但并不涉及具体的实现。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>接口是同一节点内相邻层之间交换信息的连接处，也叫服务访问点（SAP）。</span></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827212503.png"  alt="" />
      </p>
<p>世界上第一个网络体系结构由IBM公司提出（1974年，SNA），以后其他公司也相继提出自己的网络体系结构。为了促进计算机网络的发展，国际标准化组织ISO在现有网络的基础上，提出了不基于具体机型、操作系统或公司的网络体系结构，称为<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>开放系统互连参考模型</span>，即<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>OSI/RM（Open System Interconnection Reference Model）</span>。</p>
<p>ISO制定的OSI参考模型过于庞大、复杂招致了许多批评。与此相对，美国国防部提出了<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:bold'>TCP/IP协议栈</span>参考模型，简化了OSI参考模型，由于TCP/IP协议栈的简单，获得了广泛的应用，并成为后续因特网使用的参考模型。</p>

        <h2 id="osi参考模型"   >
          <a href="#osi参考模型" class="heading-link"><i class="fas fa-link"></i></a>OSI参考模型</h2>
      
<p>这里首先介绍OSI参考模型。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827212826.png"  alt="" />
      </p>
<ul>
<li>
<p>物理层</p>
<p>物理层处于OSI的最底层，是整个开放系统的基础。物理层涉及<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>通信信道上传输的原始比特流（bits）</span>，它的功能主要是为数据端设备<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>提供传送数据的通路以及传输数据</span>。</p>
</li>
<li>
<p>数据链路层</p>
<p>数据链路层的主要任务是实现计算机网络中相邻节点之间的可靠传输，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>把原始的、有差错的物理传输线加上数据链路协议以后，构成逻辑上可靠的数据链路</span>。需要完成的功能有链路管理、成帧、差错控制以及流量控制等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。</p>
</li>
<li>
<p>网络层</p>
<p>网络层涉及<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>源主机节点到目的主机节点之间可靠的网络传输</span>，它需要完成的功能主要包括路由选择、网络寻址、流量控制、拥塞控制、网络互连等。</p>
</li>
<li>
<p>传输层</p>
<p>传输层起着承上启下的作用，涉及<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>源端节点到目的端节点之间可靠的信息传输</span>。传输层需要解决跨越网络连接的建立和释放，对底层不可靠的网络，建立连接时需要<strong>三次握手</strong>，释放连接时需要<strong>四次挥手</strong>。</p>
</li>
<li>
<p>会话层</p>
<p>会话层的主要功能是负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>单工、半双工和全双工3种不同的通信方式</span>，使系统和服务之间有序地进行通信。</p>
</li>
<li>
<p>表示层</p>
<p>表示层关心所传输数据信息的格式定义，其主要功能是<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>把应用层提供的信息变换为能够共同理解的形式</span>，提供字符代码、数据格式、控制信息格式、加密等的统一表示。</p>
</li>
<li>
<p>应用层</p>
<p>应用层为OSI的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>业务处理</span>所需的服务。</p>
</li>
</ul>

        <h2 id="tcpip参考模型"   >
          <a href="#tcpip参考模型" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP参考模型</h2>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>TCP/IP</span>，即<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>Transmission Control Protocol/Internet Protocol</span>的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议，Internet国际互联网络的基础。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>TCP/IP协议是一个开放的网络协议簇，它的名字主要取自最重要的网络层IP协议和传输层TCP协议。</span>TCP/IP协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。TCP/IP参考模型采用4层的层级结构，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>每一层都呼叫它的下一层所提供的协议来完成自己的需求</span>，这4个层次分别是：网络接口层、网络层（IP层）、传输层（TCP层）、应用层。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827213629.png"  alt="" />
      </p>
<ul>
<li>
<p>网络接口层</p>
<p>TCP/IP协议对网络接口层没有给出具体的描述，网络接口层对应着OSI参考模型的物理层和数据链路层</p>
</li>
<li>
<p>网络层</p>
<p>网络层是整个TCP/IP协议栈的核心。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>它的功能是把分组发往目标网络或主机</span>。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>网络层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络层还需要完成拥塞控制的功能。</span></p>
</li>
<li>
<p>传输层</p>
<p>TCP层负责在应用进程之间建立端到端的连接和可靠通信，它只存在与端节点中。TCP层涉及两个协议，TCP和UDP。其中，TCP协议提供<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>面向连接</span>的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP协议提供无连接的服务，用于<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>不需要或无法实现面向连接</span>的网络应用中。</p>
</li>
<li>
<p>应用层</p>
<p>应用层为Internet中的各种网络应用提供服务。</p>
</li>
</ul>

        <h1 id="网络协议"   >
          <a href="#网络协议" class="heading-link"><i class="fas fa-link"></i></a>网络协议</h1>
      
<p>如同人与人之间相互交流是需要遵循一定的规则（如语言）一样，计算机之间能够进行相互通信是因为它们都共同遵守一定的规则，即网络协议。</p>
<p>OSI参考模型和TCP/IP模型在不同的层次中有许多不同的网络协议，如图所示：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827214121.png"  alt="" />
      </p>
<p>网络协议之间的层次关系图如下：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827214242.png"  alt="" />
      </p>

        <h2 id="ip协议internet-protocol"   >
          <a href="#ip协议internet-protocol" class="heading-link"><i class="fas fa-link"></i></a>IP协议（Internet protocol）</h2>
      
<p>IP协议的作用在于把各种数据包准备无误的传递给对方，其中两个重要的条件是IP地址和MAC地址。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的。</span>举例，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人。IP地址采用的IPv4格式，目前正在向IPv6过渡。</p>

        <h2 id="tcp协议transmission-control-protocol"   >
          <a href="#tcp协议transmission-control-protocol" class="heading-link"><i class="fas fa-link"></i></a>TCP协议（Transmission Control Protocol）</h2>
      
<p>TCP（传输控制协议）是面向连接的传输层协议。TCP层是位于IP层之上，应用层之下的中间层。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。TCP协议采用字节流传输数据。</span></p>

        <h3 id="tcp的报文格式"   >
          <a href="#tcp的报文格式" class="heading-link"><i class="fas fa-link"></i></a>TCP的报文格式</h3>
      
<p>TCP报文段包括协议首部和数据两部分，协议首部的固定部分是20个字节，首部的固定部分后面是选项部分。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827214927.png"  alt="" />
      </p>
<p>下面是报文段首部各个字段的含义：</p>
<ol>
<li>
<p>源端口号以及目的端口号</p>
<p>各占2个字节，端口是传输层和应用层的<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>服务访问接口(上文提到的SAP)</span>，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>用于寻找发送端和接收端的进程</span>，一般来讲，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>通过端口号和IP地址，可以唯一确定一个TCP连接</span>，在网络编程中，通常被称为一个socket接口。</p>
</li>
<li>
<p>序号</p>
<p>Seq序号，占4个字节、32位。用来标识从TCP发送端向TCP接收端发送的<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>数据字节流</span>。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>发起方发送数据时对此进行标记</span>。</p>
</li>
<li>
<p>确认序号</p>
<p>Ack序号，占4个字节、32位。包含发送确认的一端所期望收到的下一个序号。只有ACK标记位为1时，确认序号字段才有效，因此，确认序号应该是上次已经成功收到数据字节序号加1，即Ack=Seq + 1。</p>
</li>
<li>
<p>数据偏移</p>
<p>占4个字节，用于指出TCP首部长度，若不存在选项，则这个值为20字节，数据偏移的最大值为60字节。</p>
</li>
<li>
<p>保留字段</p>
<p>占6位，暂时可忽略，值全为0。</p>
</li>
<li>
<p>标志位 6个</p>
<ol>
<li>
<p>URG(紧急)</p>
<p>为1时表明紧急指针字段有效</p>
</li>
<li>
<p>ACK(确认)</p>
<p>为1时表明确认号字段有效</p>
</li>
<li>
<p>PSH(推送)</p>
<p>为1时接收方应尽快将这个报文段交给应用层</p>
</li>
<li>
<p>RST(复位)</p>
<p>为1时表明TCP连接出现故障必须重建连接</p>
</li>
<li>
<p>SYN(同步)</p>
<p>在连接建立时用来同步序号</p>
</li>
<li>
<p>FIN(终止)</p>
<p>为1时表明发送端数据发送完毕要求释放连接</p>
</li>
</ol>
</li>
<li>
<p>接受窗口</p>
<p>占2个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。</span>TCP连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。</p>
</li>
<li>
<p>校验和</p>
<p>占2个字节，校验范围包括首部和数据两部分。</p>
</li>
<li>
<p>选项</p>
<p>是可选的，默认情况是不选</p>
</li>
</ol>

        <h3 id="三次握手与四次挥手"   >
          <a href="#三次握手与四次挥手" class="heading-link"><i class="fas fa-link"></i></a>三次握手与四次挥手</h3>
      
<p>TCP是面向连接的协议，因此每个<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>TCP连接</span>都有3个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为“三次握手”。</p>
<p><strong>TCP三次握手过程</strong>如下：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827215746.png"  alt="" />
      </p>
<ol>
<li>
<p>第一次握手</p>
<p>客户机发送连接请求报文段到服务器，并进入SYN_SENT状态，等待服务器确认。发送连接请求报文段内容：SYN=1，seq=x；SYN=1意思是一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口；seq=x表示客户端初始序号x，保存在包头的序列号（Sequence Number）字段里。</p>
</li>
<li>
<p>第二次握手</p>
<p>务器收到客户端连接请求报文，如果同意建立连接，向客户机发回确认报文段（ACK）应答，并<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>为该TCP连接分配TCP缓存和变量</span>。服务器发回确认报文段内容：SYN=1，ACK=1，seq=y，ack=x+1；SYN标志位和ACK标志位均为1，同时将确认序号（Acknowledgement Number）设置为客户的ISN加1，即x+1；seq=y为服务端初始序号y。</p>
</li>
<li>
<p>第三次握手</p>
<p>客户机收到服务器的确认报文段后，向服务器给出确认报文段（ACK），并且<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>也要给该连接分配缓存和变量</span>。此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。客户端发回确认报文段内容：ACK=1，seq=x+1，ack=y+1；ACK=1为确认报文段；seq=x+1为客户端序号加1；ack=y+1,为服务器发来的ACK的初始序号字段+1。</p>
</li>
</ol>
<blockquote>
<p><span style='color:red;background:yellow;font-size:文字大小;font-weight:'>注意</span>：握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>
</blockquote>
<p><strong>TCP四次挥手过程</strong>如下：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827220215.png"  alt="" />
      </p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。</span><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。</span><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</span></p>
<ol>
<li>
<p>第一次挥手</p>
<p>TCP客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。发送报文段内容：FIN=1，seq=u；FIN=1表示请求切断连接；seq=u为客户端请求初始序号。</p>
</li>
<li>
<p>第二次挥手</p>
<p>服务端收到这个FIN，它发回一个ACK给客户端，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号；服务端进入CLOSE_WAIT状态。发送报文段内容：ACK=1，seq=v，ack=u+1；ACK=1为确认报文；seq=v为服务器确认初始序号；ack=u+1为客户端初始序号加1。</p>
</li>
<li>
<p>第三次挥手</p>
<p>服务器关闭客户端的连接后，发送一个FIN给客户端，服务端进入LAST_ACK状态。发送报文段内容：FIN=1，ACK=1，seq=w，ack=u+1；FIN=1为请求切断连接，ACK=1为确认报文，seq=w为服务端请求切断初始序号。</p>
</li>
<li>
<p>第四次挥手</p>
<p>客户端收到FIN后，客户端进入TIME_WAIT状态，接着发回一个ACK报文给服务端确认，并将确认序号设置为收到序号加1，服务端进入CLOSED状态，完成四次挥手。发送报文内容：ACK=1，seq=u+1，ack=w+1；ACK=1为确认报文，seq=u+1为客户端初始序号加1，ack=w+1为服务器初始序号加1。</p>
</li>
</ol>
<blockquote>
<p><span style='color:red;background:yellow;font-size:文字大小;font-weight:'>注意</span>：为什么连接的时候是三次握手，关闭的时候却是四次挥手？</p>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭socket，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文，我收到了”。只有等到服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步挥手。</p>
</blockquote>

        <h2 id="udp协议"   >
          <a href="#udp协议" class="heading-link"><i class="fas fa-link"></i></a>UDP协议</h2>
      
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>UDP，用户数据报协议，它是TCP/IP协议簇中无连接的运输层协议。</span></p>
<ol>
<li><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。</span><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；</span><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</span></li>
<li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务器可同时向多个客户端传输相同的消息。</li>
<li>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</li>
<li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</li>
<li><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>UDP使用尽量最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。</span></li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</li>
</ol>

        <h3 id="udp协议格式"   >
          <a href="#udp协议格式" class="heading-link"><i class="fas fa-link"></i></a>UDP协议格式</h3>
      
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827221148.png"  alt="" />
      </p>
<p>UDP协议由两部分组成：首部和数据。其中，首部仅有8个字节，包括源端口和目的端口、长度（UDP用于数据报的长度）、校验和。</p>

        <h3 id="tcp与udp的区别"   >
          <a href="#tcp与udp的区别" class="heading-link"><i class="fas fa-link"></i></a>TCP与UDP的区别</h3>
      
<ol>
<li>TCP基于连接，UDP是无连接的；</li>
<li>对系统资源的要求，TCP较多，UDP较少；</li>
<li>UDP程序结构较简单；</li>
<li>TCP是流模式，而UDP是数据报模式；</li>
<li>TCP保证数据正确性，而UDP可能丢包；TCP保证数据顺序，而UDP不保证；</li>
</ol>

        <h2 id="http协议"   >
          <a href="#http协议" class="heading-link"><i class="fas fa-link"></i></a>HTTP协议</h2>
      
<p><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>HTTP，超文本传输协议，它是互联网上应用最为广泛的一种网络协议。HTTP是一种应用层协议，它是基于TCP协议之上的请求/响应式的协议。HTTP协议是Web浏览器和Web服务器之间通信的标准协议。</span><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>HTTP指定客户端与服务器如何建立连接、客户端如何从服务器请求数据，服务器如何响应请求，以及最后如何关闭连接。HTTP连接使用TCP/IP来传输数据。</span></p>
<p>对于从客户端到服务器的每一个请求，都有4个步骤：</p>
<ol>
<li><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>默认情况下，客户端在端口80打开与服务器的一个TCP连接，URL中还可以指定其他端口。</span></li>
<li>客户端向服务器发送消息，请求指定路径上的资源。这个资源包括一个首部，可选地（取决于请求的性质）还可以有一个空行，后面是这个请求的数据。</li>
<li>服务器向客户端发送响应。响应以响应码开头，后面是包含数据的首部、一个空行以及所请求的文档或错误消息。</li>
<li>服务器关闭连接。</li>
</ol>
<p>现在使用的HTTP协议是HTTP/1.1版本，1997年之前采用的是HTTP1.0版本。HTTP连接在1.0版本中采用非持续连接工作方式，1.1版本采用的是持续连接工作方式，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>持续连接是指服务器在发送响应后仍然在一段时间内保持这条由TCP传输层协议建立起来的连接，使客户端和服务器可以继续在这条连接上传输HTTP报文</span>。</p>
<p>是否采用持续连接工作方式，1.0中默认是关闭的，需要在HTTP头加入“Connection:Keep-Alive”，才能启用Keep-Alive。HTTP1.1中默认启用Keep-Alive，如果加入“Connection:close”，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。</p>

        <h3 id="http报文"   >
          <a href="#http报文" class="heading-link"><i class="fas fa-link"></i></a>Http报文</h3>
      
<p>HTTP协议是基于TCP协议之上的请求/响应式协议，下面主要介绍HTTP报文的格式，HTTP报文主要有请求报文和响应报文两种。</p>
<p><strong>HTTP请求报文的格式</strong>：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827221815.png"  alt="" />
      </p>
<p>HTTP请求报文由<strong>请求行、首部行和实体主体</strong>组成，由浏览器发送给服务器。上面这张图中SP表示空格，cr lf表示回车和换行。下图是谷歌浏览器内访问服务器查看的HTTP请求例子：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827221938.png"  alt="" />
      </p>
<p><strong>HTTP响应报文格式</strong>：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222001.png"  alt="" />
      </p>
<p>上面这张图是HTTP响应报文，它由<strong>状态行、首部行和实体主体</strong>组成。下图为HTTP响应报文例子：</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222019.png"  alt="" />
      </p>

        <h3 id="http请求方法和响应状态码"   >
          <a href="#http请求方法和响应状态码" class="heading-link"><i class="fas fa-link"></i></a>Http请求方法和响应状态码</h3>
      
<p>在上面的HTTP请求报文例子中，我们可以看到请求方法是GET，这表示请求读取由URL所标志的信息，除了GET，还有其他几种常用的方法。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222045.png"  alt="" />
      </p>
<p>在HTTP响应报文的例子中，我们可以看到状态码是200，表示响应成功。下表是其他状态码，总共5大类，33种。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/20200827222118.png"  alt="" />
      </p>

        <h3 id="http和https的区别"   >
          <a href="#http和https的区别" class="heading-link"><i class="fas fa-link"></i></a>Http和Https的区别</h3>
      
<p><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer）</span>，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>是以安全为目标的HTTP通道，简单来说就是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</span>它是一个URL scheme（抽象标识符体系），句法类同http:体系，用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:bold'>HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）</span>。</p>
<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用开号、密码等。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>安全套接字层超文本传输协议HTTPS</span>。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</span></p>
<p>HTTPS和HTTP的区别主要为以下四点：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书很少，需要缴费。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；https协议是有ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>

        <h3 id="http和tcpip协议的关系"   >
          <a href="#http和tcpip协议的关系" class="heading-link"><i class="fas fa-link"></i></a>Http和TCP/IP协议的关系</h3>
      
<p>网络中有一段比较容易理解的介绍：</p>
<p>“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如 果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>应用层协议有很多，比如HTTP、FTP、TELNET等，也 可以自己定义应用层协议</span>。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”</p>

        <h1 id="java-socket网络编程"   >
          <a href="#java-socket网络编程" class="heading-link"><i class="fas fa-link"></i></a>Java Socket网络编程</h1>
      

        <h2 id="socket概述"   >
          <a href="#socket概述" class="heading-link"><i class="fas fa-link"></i></a>Socket概述</h2>
      
<p>Java的网络编程主要涉及到的内容是Socket编程。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>Socket，套接字，就是两台主机之间逻辑连接的端点。</span>TCP/IP协议是传输层协议，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>主要解决数据如何在网络中传输</span>，而HTTP是应用层协议，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>主要解决如何包装数据</span>。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>Socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示</span>，包含进行网络通信必须的五种信息：连接使用的协议、本地主机的IP地址、本地进程的协议端口、远程主机的IP地址、远程进程的协议端口。</p>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据</span>。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字（Socket）接口。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</span></p>
<p><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>Socket，实际上是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</span>实际上，Socket跟TCP/IP协议没有必然的关系，Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>Socket的出现，只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象</span>，从而形成了我们知道的一些最基本的函数接口，比如create、listen、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：</p>
<p>“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口</span>。”</p>
<p>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:bold'>socket是对端口通信开发的工具</span>,它要更底层一些。</p>

        <h2 id="socket整体流程"   >
          <a href="#socket整体流程" class="heading-link"><i class="fas fa-link"></i></a>Socket整体流程</h2>
      
<p>Socket编程主要涉及到客户端和服务端两个方面，首先是在服务器端创建一个服务器套接字（ServerSocket），并把它附加到一个端口上，服务器从这个端口监听连接。端口号的范围是0到65536，但是0到1024是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>客户端请求与服务器进行连接的时候，根据服务器的域名或者IP地址，加上端口号，打开一个套接字</span>。<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。</span></p>

        <h3 id="socket读写数据流程"   >
          <a href="#socket读写数据流程" class="heading-link"><i class="fas fa-link"></i></a>Socket读写数据流程</h3>
      
<p>当客户端和服务器使用TCP协议进行通信时，客户端封装一个请求对象req，将请求对象req序列化成字节数组，然后通过套接字socket将字节数组发送到服务器，服务器通过套接字socket读取到字节数组，再反序列化成请求对象req，进行处理，处理完毕后，生成一个响应对应res，将响应对象res序列化成字节数组，然后通过套接字将字节数组发送给客户端，客户端通过套接字socket读取到字节数组，再反序列化成响应对象。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/aHR0cDovL3d3dy41MmltLm5ldC9kYXRhL2F0dGFjaG1lbnQvZm9ydW0vMjAxODA3LzA1LzExMzYwN2RiN2IzaDZoNzcyYndod2suZ2lm.gif"  alt="" />
      </p>
<p>通信框架往往可以将序列化的过程隐藏起来，我们所看到的现象就是上图所示，请求对象req和响应对象res在客户端和服务器之间跑来跑去。</p>
<p>也许你觉得这个过程还是挺简单的，很好理解，但是实际上背后发生的一系列事件超出了你们中大多数人的想象。通信的真实过程要比上面的这张图复杂太多。你也许会问，我们需要了解的那么深入么，直接拿来用不就可以了么？</p>
<p>在互联网工作服务行业工作多年的经验告诉我，如果你对底层机制不了解，你就会不明白为什么对套接字socket的读写会出现各种奇奇乖乖的问题，为什么有时会阻塞，有时又不阻塞，有时候还报错，为什么会有粘包半包问题，NIO具体又是什么，它是什么特别新鲜的工作么？对于这些问题的理解都需要你了解底层机制。</p>

        <h3 id="socket读写的细节过程分析"   >
          <a href="#socket读写的细节过程分析" class="heading-link"><i class="fas fa-link"></i></a>Socket读写的细节过程分析</h3>
      
<p>为了方便大家对通信底层的理解，我花了些时间做了下面这个动画，它并不能完全覆盖底层细节的全貌，但是对于理解套接字的工作机制已经足够了。请读者仔细观察这个动画，后面的讲解将围绕着这个动画展开。</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://gitee.com/lienhui68/picStore/raw/master/null/aHR0cDovL3d3dy41MmltLm5ldC9kYXRhL2F0dGFjaG1lbnQvZm9ydW0vMjAxODA3LzA1LzExMzcwMm5qZ2Z3MmZremoza2tqamYuZ2lm.gif"  alt="" />
      </p>
<p>我们平时用到的套接字其实只是一个引用(一个对象ID)，这个套接字对象实际上是放在操作系统内核中。这个套接字对象内部有两个重要的缓冲结构，一个是读缓冲(read buffer)，一个是写缓冲(write buffer)，它们都是有限大小的数组结构。</p>
<p>当我们对客户端的socket写入字节数组时(序列化后的请求消息对象req)，是将字节数组拷贝到内核区套接字对象的write buffer中，内核网络模块会有单独的线程负责不停地将write buffer的数据拷贝到网卡硬件，网卡硬件再将数据送到网线，经过一些列路由器交换机，最终送达服务器的网卡硬件中。</p>
<p>同样，服务器内核的网络模块也会有单独的线程不停地将收到的数据拷贝到套接字的read buffer中等待用户层来读取。最终服务器的用户进程通过socket引用的read方法将read buffer中的数据拷贝到用户程序内存中进行反序列化成请求对象进行处理。然后服务器将处理后的响应对象走一个相反的流程发送给客户端，这里就不再具体描述。</p>

        <h3 id="细节过程"   >
          <a href="#细节过程" class="heading-link"><i class="fas fa-link"></i></a>细节过程</h3>
      
<p><strong>阻塞</strong></p>
<p>我们注意到write buffer空间都是有限的，所以如果应用程序往套接字里写的太快，这个空间是会满的。一旦满了，写操作就会阻塞，直到这个空间有足够的位置腾出来。不过有了NIO(非阻塞IO)，写操作也可以不阻塞，能写多少是多少，通过返回值来确定到底写进去多少，那些没有写进去的内容用户程序会缓存起来，后续会继续重试写入。</p>
<p>同样我们也注意到read buffer的内容可能会是空的。这样套接字的读操作(一般是读一个定长的字节数组)也会阻塞，直到read buffer中有了足够的内容(填充满字节数组)才会返回。有了NIO，就可以有多少读多少，无须阻塞了。读不够的，后续会继续尝试读取。</p>
<p><strong>ack</strong></p>
<p>那上面这张图就展现了套接字的全部过程么？显然不是，数据的确认过程(ack)就完全没有展现。比如当写缓冲的内容拷贝到网卡后，是不会立即从写缓冲中将这些拷贝的内容移除的，而要等待对方的ack过来之后才会移除。如果网络状况不好，ack迟迟不过来，写缓冲很快就会满的。</p>
<p><strong>包头</strong></p>
<p>细心的同学可能注意到图中的消息req被拷贝到网卡的时候变成了大写的REQ，这是为什么呢？因为这两个东西已经不是完全一样的了。内核的网络模块会将缓冲区的消息进行分块传输，如果缓冲区的内容太大，是会被拆分成多个独立的小消息包的。并且还要在每个消息包上附加上一些额外的头信息，比如源网卡地址和目标网卡地址、消息的序号等信息，到了接收端需要对这些消息包进行重新排序组装去头后才会扔进读缓冲中。这些复杂的细节过程就非常难以在动画上予以呈现了。</p>
<p><strong>速率</strong></p>
<p>还有个问题那就是如果读缓冲满了怎么办，网卡收到了对方的消息要怎么处理？一般的做法就是丢弃掉不给对方ack，对方如果发现ack迟迟没有来，就会重发消息。那缓冲为什么会满？是因为消息接收方处理的慢而发送方生产的消息太快了，这时候tcp协议就会有个动态窗口调整算法来限制发送方的发送速率，使得收发效率趋于匹配。如果是udp协议的话，消息一丢那就彻底丢了。</p>
<p>网络协议内部实现还有更多复杂的细节有待继续挖掘，留着以后继续分析吧。</p>

        <h3 id="代码示例"   >
          <a href="#代码示例" class="heading-link"><i class="fas fa-link"></i></a>代码示例</h3>
      
<p>下面是一个客户端和服务器端进行数据交互的简单例子，客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端，通过这个例子可以初步对Socket编程有个把握。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eh.eden.pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7000</span>;</span><br><span class="line">        <span class="comment">// 在端口上创建一个服务器套接字</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// 监听来自客户端的连接</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket获取输入流</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket获取输出流</span></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> length = dis.readDouble(); <span class="comment">// 接受客户端的输入</span></span><br><span class="line">            System.out.println(<span class="string">"服务器端收到的边长数据为："</span> + length);</span><br><span class="line">            <span class="keyword">double</span> result = length * length;</span><br><span class="line">            dos.writeDouble(result); <span class="comment">// 发送结果到客户端</span></span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125; <span class="keyword">while</span> (dis.readInt() != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7000</span>;</span><br><span class="line">        String host = <span class="string">"localhost"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个套接字并将其连接到服务器端指定端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket获取输入流</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从socket获取输出流</span></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入正方形的边长:"</span>);</span><br><span class="line">            <span class="keyword">double</span> length = sc.nextDouble();</span><br><span class="line"></span><br><span class="line">            dos.writeDouble(length);</span><br><span class="line">            dos.flush();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> area = dis.readDouble();</span><br><span class="line">            System.out.println(<span class="string">"服务器返回的计算面积为:"</span> + area);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"继续计算？(Y/N)"</span>);</span><br><span class="line">                String str = sc.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(<span class="string">"N"</span>)) &#123;</span><br><span class="line">                    dos.writeInt(<span class="number">0</span>);</span><br><span class="line">                    dos.flush();</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equalsIgnoreCase(<span class="string">"Y"</span>)) &#123;</span><br><span class="line">                    dos.writeInt(<span class="number">1</span>);</span><br><span class="line">                    dos.flush();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可以看到上面的服务器端程序和客户端程序是一对一的关系，为了能让一个服务器端程序能同时为多个客户提供服务，可以使用多线程机制，每个客户端的请求都由一个独立的线程进行处理。下面是改写后的服务器端程序。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eh.eden.pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServerM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7000</span>;</span><br><span class="line">        <span class="keyword">int</span> clientNo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                exec.execute(<span class="keyword">new</span> SingleServer(socket, clientNo));</span><br><span class="line">                clientNo++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> clientNo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleServer</span><span class="params">(Socket socket, <span class="keyword">int</span> clientNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.clientNo = clientNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line">            DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> length = dis.readDouble();</span><br><span class="line">                System.out.println(<span class="string">"从客户端"</span> + clientNo + <span class="string">"接收到的边长数据为："</span> + length);</span><br><span class="line">                <span class="keyword">double</span> result = length * length;</span><br><span class="line">                dos.writeDouble(result);</span><br><span class="line">                dos.flush();</span><br><span class="line">            &#125; <span class="keyword">while</span> (dis.readInt() != <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"与客户端"</span> + clientNo + <span class="string">"通信结束"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面改进后的服务器端代码可以支持不断地并发响应网络中的客户请求。关键的地方在于多线程机制的运用，同时利用线程池可以改善服务器程序的性能。</p>
<blockquote>
<p>第一个while循环：接受客户端的连接是阻塞的，完成一个连接起一个线程</p>
<p>第二个while循环：连接完成后读取数据也是阻塞的</p>
</blockquote>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h1>
      
<ul>
<li>端口是传输层和应用层的<span style='color:red;background:背景颜色;font-size:文字大小;font-weight:'>服务接口(上文提到的SAP)</span>，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>用于寻找发送端和接收端的进程</span>，一般来讲，<span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>通过端口号和IP地址，可以唯一确定一个TCP连接</span>，在网络编程中，通常被称为一个socket接口。</li>
<li><span style='color:LimeGreen;background:背景颜色;font-size:文字大小;font-weight:'>Socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示</span></li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://lienhui68.gitee.io">lienhui68</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/100_%E8%AE%A1%E7%A7%91%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">http://lienhui68.gitee.io/2020/%E5%B7%A5%E4%BD%9C/100_%E8%AE%A1%E7%A7%91%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://lienhui68.gitee.io/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/6.jpeg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/5.jpeg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/%E5%B7%A5%E4%BD%9C/100_%E8%AE%A1%E7%A7%91%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E7%BD%91%E5%85%B3%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E3%80%81%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">网关、路由器、三层交换机</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/%E5%B7%A5%E4%BD%9C/100_%E8%AE%A1%E7%A7%91%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/cdn/"><span class="paginator-prev__text">cdn</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">
          概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络体系结构"><span class="toc-number">2.</span> <span class="toc-text">
          网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#osi参考模型"><span class="toc-number">2.1.</span> <span class="toc-text">
          OSI参考模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpip参考模型"><span class="toc-number">2.2.</span> <span class="toc-text">
          TCP&#x2F;IP参考模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络协议"><span class="toc-number">3.</span> <span class="toc-text">
          网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ip协议internet-protocol"><span class="toc-number">3.1.</span> <span class="toc-text">
          IP协议（Internet protocol）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp协议transmission-control-protocol"><span class="toc-number">3.2.</span> <span class="toc-text">
          TCP协议（Transmission Control Protocol）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp的报文格式"><span class="toc-number">3.2.1.</span> <span class="toc-text">
          TCP的报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手与四次挥手"><span class="toc-number">3.2.2.</span> <span class="toc-text">
          三次握手与四次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp协议"><span class="toc-number">3.3.</span> <span class="toc-text">
          UDP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#udp协议格式"><span class="toc-number">3.3.1.</span> <span class="toc-text">
          UDP协议格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp与udp的区别"><span class="toc-number">3.3.2.</span> <span class="toc-text">
          TCP与UDP的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http协议"><span class="toc-number">3.4.</span> <span class="toc-text">
          HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http报文"><span class="toc-number">3.4.1.</span> <span class="toc-text">
          Http报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http请求方法和响应状态码"><span class="toc-number">3.4.2.</span> <span class="toc-text">
          Http请求方法和响应状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http和https的区别"><span class="toc-number">3.4.3.</span> <span class="toc-text">
          Http和Https的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http和tcpip协议的关系"><span class="toc-number">3.4.4.</span> <span class="toc-text">
          Http和TCP&#x2F;IP协议的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-socket网络编程"><span class="toc-number">4.</span> <span class="toc-text">
          Java Socket网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket概述"><span class="toc-number">4.1.</span> <span class="toc-text">
          Socket概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket整体流程"><span class="toc-number">4.2.</span> <span class="toc-text">
          Socket整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket读写数据流程"><span class="toc-number">4.2.1.</span> <span class="toc-text">
          Socket读写数据流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket读写的细节过程分析"><span class="toc-number">4.2.2.</span> <span class="toc-text">
          Socket读写的细节过程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#细节过程"><span class="toc-number">4.2.3.</span> <span class="toc-text">
          细节过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码示例"><span class="toc-number">4.2.4.</span> <span class="toc-text">
          代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">
          总结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/3.png" alt="avatar"></div><p class="sidebar-ov-author__text">人类的悲欢并不相通</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/lienhui68" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.facebook.com/profile.php?id=100009351871465" target="_blank" rel="noopener" data-popover="Facebook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-facebook"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/lienhui68" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">313</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>lienhui68 All Rights Reserved</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'iTixDcNjX1XLIDnENLxM9F1E-gzGzoHsz',
    appKey: 'hKBKmiysmFkqF2ik6yCcEATU',
    notify: true,
    verify: true,
    placeholder: '欢迎评论',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: false,
    recordIP: false,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>